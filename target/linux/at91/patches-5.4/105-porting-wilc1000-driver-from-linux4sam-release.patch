From 1f2e980712061ae5def8be05dfd89f77940b2b9f Mon Sep 17 00:00:00 2001
From: Sandeep Sheriker M <sandeep.sheriker@microchip.com>
Date: Fri, 15 Jan 2021 12:01:13 -0700
Subject: [PATCH] porting wilc1000 driver from linux4sam release

Signed-off-by: Sandeep Sheriker M <sandeep.sheriker@microchip.com>
---
 drivers/staging/wilc1000/Kconfig              |   50 +-
 drivers/staging/wilc1000/Makefile             |   20 +-
 drivers/staging/wilc1000/bt.c                 |  697 ++++++
 .../{wilc_wfi_cfgoperations.c => cfg80211.c}  | 1450 ++++++++-----
 .../{wilc_wfi_cfgoperations.h => cfg80211.h}  |   19 +-
 drivers/staging/wilc1000/debugfs.c            |  426 ++++
 drivers/staging/wilc1000/debugfs.h            |   60 +
 drivers/staging/wilc1000/fw.h                 |  120 +
 .../staging/wilc1000/{wilc_hif.c => hif.c}    | 1069 ++++++---
 .../staging/wilc1000/{wilc_hif.h => hif.h}    |   74 +-
 .../wilc1000/microchip,wilc1000,sdio.txt      |   38 -
 .../wilc1000/microchip,wilc1000,spi.txt       |   34 -
 .../staging/wilc1000/microchip,wilc1000.yaml  |   71 +
 .../staging/wilc1000/{wilc_mon.c => mon.c}    |  186 +-
 drivers/staging/wilc1000/netdev.c             | 1351 ++++++++++++
 drivers/staging/wilc1000/netdev.h             |  476 ++++
 drivers/staging/wilc1000/power.c              |  103 +
 .../staging/wilc1000/{wilc_sdio.c => sdio.c}  |  753 ++++---
 drivers/staging/wilc1000/spi.c                | 1283 +++++++++++
 drivers/staging/wilc1000/sysfs.c              |  108 +
 drivers/staging/wilc1000/wilc_netdev.c        |  931 --------
 drivers/staging/wilc1000/wilc_spi.c           | 1134 ----------
 drivers/staging/wilc1000/wilc_wfi_netdevice.h |  293 ---
 drivers/staging/wilc1000/wilc_wlan.c          | 1268 -----------
 drivers/staging/wilc1000/wlan.c               | 1931 +++++++++++++++++
 .../staging/wilc1000/{wilc_wlan.h => wlan.h}  |  232 +-
 .../wilc1000/{wilc_wlan_cfg.c => wlan_cfg.c}  |  307 +--
 .../wilc1000/{wilc_wlan_cfg.h => wlan_cfg.h}  |   27 +-
 .../wilc1000/{wilc_wlan_if.h => wlan_if.h}    |   37 +-
 29 files changed, 9377 insertions(+), 5171 deletions(-)
 create mode 100644 drivers/staging/wilc1000/bt.c
 rename drivers/staging/wilc1000/{wilc_wfi_cfgoperations.c => cfg80211.c} (52%)
 rename drivers/staging/wilc1000/{wilc_wfi_cfgoperations.h => cfg80211.h} (73%)
 create mode 100644 drivers/staging/wilc1000/debugfs.c
 create mode 100644 drivers/staging/wilc1000/debugfs.h
 create mode 100644 drivers/staging/wilc1000/fw.h
 rename drivers/staging/wilc1000/{wilc_hif.c => hif.c} (63%)
 rename drivers/staging/wilc1000/{wilc_hif.h => hif.h} (80%)
 delete mode 100644 drivers/staging/wilc1000/microchip,wilc1000,sdio.txt
 delete mode 100644 drivers/staging/wilc1000/microchip,wilc1000,spi.txt
 create mode 100644 drivers/staging/wilc1000/microchip,wilc1000.yaml
 rename drivers/staging/wilc1000/{wilc_mon.c => mon.c} (52%)
 create mode 100644 drivers/staging/wilc1000/netdev.c
 create mode 100644 drivers/staging/wilc1000/netdev.h
 create mode 100644 drivers/staging/wilc1000/power.c
 rename drivers/staging/wilc1000/{wilc_sdio.c => sdio.c} (62%)
 create mode 100644 drivers/staging/wilc1000/spi.c
 create mode 100644 drivers/staging/wilc1000/sysfs.c
 delete mode 100644 drivers/staging/wilc1000/wilc_netdev.c
 delete mode 100644 drivers/staging/wilc1000/wilc_spi.c
 delete mode 100644 drivers/staging/wilc1000/wilc_wfi_netdevice.h
 delete mode 100644 drivers/staging/wilc1000/wilc_wlan.c
 create mode 100644 drivers/staging/wilc1000/wlan.c
 rename drivers/staging/wilc1000/{wilc_wlan.h => wlan.h} (58%)
 rename drivers/staging/wilc1000/{wilc_wlan_cfg.c => wlan_cfg.c} (55%)
 rename drivers/staging/wilc1000/{wilc_wlan_cfg.h => wlan_cfg.h} (58%)
 rename drivers/staging/wilc1000/{wilc_wlan_if.h => wlan_if.h} (97%)

diff --git a/drivers/staging/wilc1000/Kconfig b/drivers/staging/wilc1000/Kconfig
index 59e58550d..881edcdae 100644
--- a/drivers/staging/wilc1000/Kconfig
+++ b/drivers/staging/wilc1000/Kconfig
@@ -1,42 +1,56 @@
 # SPDX-License-Identifier: GPL-2.0
-config WILC1000
+config WILC
 	tristate
+
+config WLAN_VENDOR_MCHP
+        bool "Microhip devices"
+        default y
 	help
-	  This module only support IEEE 802.11n WiFi.
+	This adds support for WILC1000 & WILC3000 chips which support
+	IEEE 802.11n WiFi. WILC3000 is a WiFi-BT combo chip.
+
+if WLAN_VENDOR_MCHP
 
-config WILC1000_SDIO
-	tristate "Atmel WILC1000 SDIO (WiFi only)"
+config WILC_SDIO
+	tristate "WILC SDIO"
 	depends on CFG80211 && INET && MMC
-	select WILC1000
+	select WILC
+	select PWRSEQ_WILC
 	help
 	  This module adds support for the SDIO interface of adapters using
-	  WILC1000 chipset. The Atmel WILC1000 SDIO is a full speed interface.
+	  WILC1000 & WILC3000 chipset. The Atmel WILC1000 SDIO is a full speed interface.
 	  It meets SDIO card specification version 2.0. The interface supports
 	  the 1-bit/4-bit SD transfer mode at the clock range of 0-50 MHz.
 	  The host can use this interface to read and write from any register
 	  within the chip as well as configure the WILC1000 for data DMA.
 	  To use this interface, pin9 (SDIO_SPI_CFG) must be grounded. Select
 	  this if your platform is using the SDIO bus.
+	  WILC3000 additionally supports BT 4.0 and BLE modes.
 
-config WILC1000_SPI
-	tristate "Atmel WILC1000 SPI (WiFi only)"
+config WILC_SPI
+	tristate "WILC SPI"
 	depends on CFG80211 && INET && SPI
-	select WILC1000
+	select WILC
+	select PWRSEQ_WILC
+	select CRC7
 	help
 	  This module adds support for the SPI interface of adapters using
-	  WILC1000 chipset. The Atmel WILC1000 has a Serial Peripheral
+	  WILC1000 & WILC3000 chipset. The Atmel WILC1000 has a Serial Peripheral
 	  Interface (SPI) that operates as a SPI slave. This SPI interface can
 	  be used for control and for serial I/O of 802.11 data. The SPI is a
 	  full-duplex slave synchronous serial interface that is available
 	  immediately following reset when pin 9 (SDIO_SPI_CFG) is tied to
 	  VDDIO. Select this if your platform is using the SPI bus.
+	  WILC3000 additionally supports BT 4.0 and BLE modes.
 
-config WILC1000_HW_OOB_INTR
-	bool "WILC1000 out of band interrupt"
-	depends on WILC1000_SDIO
+config WILC_HW_OOB_INTR
+	bool "WILC out of band interrupt"
+	depends on WILC_SDIO
+	default n
 	help
-	  This option enables out-of-band interrupt support for the WILC1000
-	  chipset. This OOB interrupt is intended to provide a faster interrupt
-	  mechanism for SDIO host controllers that don't support SDIO interrupt.
-	  Select this option If the SDIO host controller in your platform
-	  doesn't support SDIO time devision interrupt.
+	  This option enables out-of-band interrupt support for the WILC1000 &
+	  WILC3000 chipset. This OOB interrupt is intended to provide a faster
+	  interrupt mechanism for SDIO host controllers that don't support SDIO
+	  interrupt. Select this option If the SDIO host controller in your
+	  platform doesn't support SDIO time devision interrupt.
+endif
diff --git a/drivers/staging/wilc1000/Makefile b/drivers/staging/wilc1000/Makefile
index a5a8e806b..a0b3e13d1 100644
--- a/drivers/staging/wilc1000/Makefile
+++ b/drivers/staging/wilc1000/Makefile
@@ -1,14 +1,14 @@
 # SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_WILC1000) += wilc1000.o
+ccflags-y += -I$(src)/ -DWILC_ASIC_A0 -DWILC_DEBUGFS
 
-ccflags-y += -DFIRMWARE_1002=\"atmel/wilc1002_firmware.bin\" \
-		-DFIRMWARE_1003=\"atmel/wilc1003_firmware.bin\"
+wilc-objs := cfg80211.o netdev.o mon.o \
+			hif.o wlan_cfg.o debugfs.o \
+			wlan.o sysfs.o bt.o power.o
 
-wilc1000-objs := wilc_wfi_cfgoperations.o wilc_netdev.o wilc_mon.o \
-			wilc_hif.o wilc_wlan_cfg.o wilc_wlan.o
+obj-$(CONFIG_WILC_SDIO) += wilc-sdio.o
+wilc-sdio-objs += $(wilc-objs)
+wilc-sdio-objs += sdio.o
 
-obj-$(CONFIG_WILC1000_SDIO) += wilc1000-sdio.o
-wilc1000-sdio-objs += wilc_sdio.o
-
-obj-$(CONFIG_WILC1000_SPI) += wilc1000-spi.o
-wilc1000-spi-objs += wilc_spi.o
+obj-$(CONFIG_WILC_SPI) += wilc-spi.o
+wilc-spi-objs += $(wilc-objs)
+wilc-spi-objs += spi.o 
diff --git a/drivers/staging/wilc1000/bt.c b/drivers/staging/wilc1000/bt.c
new file mode 100644
index 000000000..48a530250
--- /dev/null
+++ b/drivers/staging/wilc1000/bt.c
@@ -0,0 +1,697 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/firmware.h>
+
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/host.h>
+
+#include "netdev.h"
+
+static struct wilc *wilc_bt;
+static dev_t chc_dev_no; /* Global variable for the first device number */
+static struct cdev str_chc_dev; /* Global variable for the character */
+static struct device *dev;
+static struct class *chc_dev_class; /* Global variable for the device class */
+static bool device_created;
+static int bt_init_done;
+
+typedef void (wilc_cmd_handler)(char *);
+
+static void handle_cmd_bt_enable(char *param);
+static void handle_cmd_pwr_up(char *param);
+static void handle_cmd_pwr_down(char *param);
+static void handle_cmd_chip_wake_up(char *param);
+static void handle_cmd_chip_allow_sleep(char *param);
+static void handle_cmd_download_fw(char *param);
+static void handle_cmd_cca_thrshld(char *param);
+
+static void wilc_bt_firmware_download(struct wilc *);
+static void wilc_bt_start(struct wilc *);
+static int wilc_bt_dev_open(struct inode *i, struct file *f);
+static int wilc_bt_dev_close(struct inode *i, struct file *f);
+static ssize_t wilc_bt_dev_read(struct file *f, char __user *buf, size_t len,
+				loff_t *off);
+static ssize_t wilc_bt_dev_write(struct file *f, const char __user *buff,
+				 size_t len, loff_t *off);
+
+static const struct file_operations pugs_fops = {
+	.owner = THIS_MODULE,
+	.open = wilc_bt_dev_open,
+	.release = wilc_bt_dev_close,
+	.read = wilc_bt_dev_read,
+	.write = wilc_bt_dev_write
+};
+
+struct cmd_entry {
+	const char *str;
+	wilc_cmd_handler *wilc_handle_cmd;
+};
+
+static const struct cmd_entry cmd_table[] = {
+	{"BT_DOWNLOAD_FW", handle_cmd_download_fw},
+	{"BT_POWER_UP", handle_cmd_pwr_up},
+	{"BT_POWER_DOWN", handle_cmd_pwr_down},
+	{"BT_FW_CHIP_WAKEUP", handle_cmd_chip_wake_up},
+	{"BT_FW_CHIP_ALLOW_SLEEP", handle_cmd_chip_allow_sleep},
+	{"BT_ENABLE", handle_cmd_bt_enable},
+	{"CCA_THRESHOLD", handle_cmd_cca_thrshld},
+	/* Keep the NULL handler at the end of the table */
+	{(const char *)NULL, NULL},
+};
+
+static int wilc_bt_dev_open(struct inode *i, struct file *f)
+{
+	pr_info("at_pwr_dev: open()\n");
+	return 0;
+}
+
+static int wilc_bt_dev_close(struct inode *i, struct file *f)
+{
+	pr_info("at_pwr_dev: close()\n");
+	return 0;
+}
+
+static ssize_t wilc_bt_dev_read(struct file *f, char __user *buf, size_t len,
+				loff_t *off)
+{
+	pr_debug("at_pwr_dev: read()\n");
+	return 0;
+}
+
+static ssize_t wilc_bt_dev_write(struct file *f, const char __user *buff,
+				 size_t len, loff_t *off)
+{
+	struct cmd_entry *cmd;
+	char *usr_str;
+
+
+	if (len == 0) {
+		pr_debug("received invalid size <=0: %d\n", len);
+		return len;
+	}
+
+	usr_str = kmalloc(len, GFP_KERNEL);
+
+	if (copy_from_user(usr_str, buff, len))
+		return -EIO;
+
+	pr_debug("received %s, len %d\n", usr_str, len);
+	/* call the appropriate command handler */
+	cmd = (struct cmd_entry *)cmd_table;
+	while (cmd->wilc_handle_cmd != NULL) {
+		if (strncmp(cmd->str, usr_str, strlen(cmd->str)) == 0) {
+			pr_debug("param len: %d, string: %s\n",
+				 len - strlen(cmd->str), usr_str);
+			cmd->wilc_handle_cmd(usr_str + strlen(cmd->str));
+			break;
+		}
+		cmd++;
+	}
+
+	kfree(usr_str);
+	return len;
+}
+
+static void wilc_bt_create_device(void)
+{
+	int ret = 0;
+
+	if (device_created)
+		return;
+
+	ret = alloc_chrdev_region(&chc_dev_no, 0, 1, "atmel");
+	if (ret < 0)
+		return;
+	chc_dev_class = class_create(THIS_MODULE, "atmel");
+	if (IS_ERR(chc_dev_class)) {
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+	dev = device_create(chc_dev_class, NULL, chc_dev_no, NULL,
+			    "wilc_bt");
+	if (IS_ERR(dev)) {
+		class_destroy(chc_dev_class);
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+
+	cdev_init(&str_chc_dev, &pugs_fops);
+	ret = cdev_add(&str_chc_dev, chc_dev_no, 1);
+	if (ret < 0) {
+		device_destroy(chc_dev_class, chc_dev_no);
+		class_destroy(chc_dev_class);
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+	mutex_init(&wilc_bt->cs);
+	device_created = 1;
+}
+
+static void handle_cmd_cca_thrshld(char *param)
+{
+	int carrier_thrshld, noise_thrshld;
+	unsigned int carr_thrshld_frac, noise_thrshld_frac, carr_thrshld_int,
+		noise_thrshld_int, reg;
+
+	if (param == NULL) {
+		pr_err("Invalid parameter\n");
+		return;
+	}
+
+	if (sscanf(param, " %d %d", &noise_thrshld, &carrier_thrshld) != 2) {
+		pr_err("Failed to parse input parameters. Usage:\n");
+		pr_err("echo CCA_THRESHOLD NOISE_THRESHOLD CARRIER_THRESHOLD > /dev/at_pwr_dev\n");
+		pr_err("where threshold values are in dB * 10\n");
+		pr_err("e.g. echo CCA_THRESHOLD -625 -826 > /dev/at_pwr_dev to set thresholds to -62.5 and -82.6\n\n");
+		return;
+	}
+
+	pr_info("Changing CCA noise threshold to %d and carrier thresholds to %d\n",
+		noise_thrshld, carrier_thrshld);
+
+	carr_thrshld_int = carrier_thrshld/10;
+	if (carrier_thrshld < 0)
+		carr_thrshld_frac = (carr_thrshld_int * 10) - carrier_thrshld;
+	else
+		carr_thrshld_frac = carrier_thrshld - (carr_thrshld_int * 10);
+
+	noise_thrshld_int = noise_thrshld/10;
+	if (noise_thrshld < 0)
+		noise_thrshld_frac = (noise_thrshld_int * 10) - noise_thrshld;
+	else
+		noise_thrshld_frac = noise_thrshld - (noise_thrshld_int * 10);
+
+	wilc_bt->hif_func->hif_read_reg(wilc_bt, CCA_CTL_2, &reg);
+	reg &= ~(0x7FF0000);
+	reg |= ((noise_thrshld_frac & 0x7) | ((noise_thrshld_int & 0x1FF)
+					      << 3)) << 16;
+	wilc_bt->hif_func->hif_write_reg(wilc_bt, CCA_CTL_2, reg);
+
+	wilc_bt->hif_func->hif_read_reg(wilc_bt, CCA_CTL_7, &reg);
+	reg &= ~(0x7FF0000);
+	reg |= ((carr_thrshld_frac & 0x7) | ((carr_thrshld_int & 0x1FF) << 3))
+		<< 16;
+	wilc_bt->hif_func->hif_write_reg(wilc_bt, CCA_CTL_7, reg);
+}
+
+int wilc_bt_power_down(struct wilc *wilc, int source)
+{
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+	int ret;
+
+	if (source == DEV_BT) {
+		u32 reg;
+
+		pr_info("AT PWR: bt_power_down\n");
+
+		/* Adjust coexistence module. This should be done from the FW
+		 * in the future
+		 */
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+		ret = hif_func->hif_read_reg(wilc, GLOBAL_MODE_CONTROL,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       GLOBAL_MODE_CONTROL);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		/* Clear BT mode*/
+		reg &= ~BIT(1);
+		ret = hif_func->hif_write_reg(wilc, GLOBAL_MODE_CONTROL,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       GLOBAL_MODE_CONTROL);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+
+
+		/*TicketId1115*/
+		/*Disable awake coex null frames*/
+		ret = hif_func->hif_read_reg(wilc, COE_AUTO_PS_ON_NULL_PKT,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       COE_AUTO_PS_ON_NULL_PKT);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		reg &= ~BIT(30);
+		ret = hif_func->hif_write_reg(wilc, COE_AUTO_PS_ON_NULL_PKT,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       COE_AUTO_PS_ON_NULL_PKT);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+
+		/*TicketId1115*/
+		/*Disable doze coex null frames*/
+		ret = hif_func->hif_read_reg(wilc, COE_AUTO_PS_OFF_NULL_PKT,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       COE_AUTO_PS_OFF_NULL_PKT);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		reg &= ~BIT(30);
+		ret = hif_func->hif_write_reg(wilc, COE_AUTO_PS_OFF_NULL_PKT,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       COE_AUTO_PS_OFF_NULL_PKT);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		/* Disable BT wakeup */
+		ret = hif_func->hif_read_reg(wilc, PWR_SEQ_MISC_CTRL,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       PWR_SEQ_MISC_CTRL);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		reg &= ~BIT(29);
+		ret = hif_func->hif_write_reg(wilc, PWR_SEQ_MISC_CTRL,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       PWR_SEQ_MISC_CTRL);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+
+		bt_init_done = 0;
+	}
+
+	mutex_lock(&wilc->cs);
+
+	pr_info("source: %s, current bus status Wifi: %d, BT: %d\n",
+		 (source == DEV_WIFI ? "Wifi" : "BT"),
+		 wilc->power.status[DEV_WIFI],
+		 wilc->power.status[DEV_BT]);
+
+	if (wilc->power.status[source] == false) {
+		pr_err("power down request for already powered down source %s\n",
+		       (source == DEV_WIFI ? "Wifi" : "BT"));
+	} else if (((source == DEV_WIFI) &&
+		  (wilc->power.status[DEV_BT] == true)) ||
+		  ((source == DEV_BT) &&
+		  (wilc->power.status[DEV_WIFI] == true))) {
+		pr_warn("Another device is preventing power down. request source is %s\n",
+			(source == DEV_WIFI ? "Wifi" : "BT"));
+	} else {
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY, source);
+		ret = wilc->hif_func->hif_deinit(wilc);
+		release_bus(wilc, WILC_BUS_RELEASE_ONLY, source);
+		if (ret) {
+			mutex_unlock(&wilc->cs);
+			return ret;
+		}
+	}
+	wilc->power.status[source] = false;
+
+	mutex_unlock(&wilc->cs);
+
+	return 0;
+}
+
+int wilc_bt_power_up(struct wilc *wilc, int source)
+{
+	int count = 0;
+	int ret;
+	int reg;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	mutex_lock(&wilc->cs);
+
+	pr_debug("source: %s, current bus status Wifi: %d, BT: %d\n",
+		 (source == DEV_WIFI ? "Wifi" : "BT"),
+		 wilc->power.status[DEV_WIFI],
+		 wilc->power.status[DEV_BT]);
+
+	if (wilc->power.status[source] == true) {
+		pr_err("power up request for already powered up source %s\n",
+			 (source == DEV_WIFI ? "Wifi" : "BT"));
+	} else {
+		/*Bug 215*/
+		/*Avoid overlapping between BT and Wifi intialization*/
+		if (wilc->power.status[DEV_WIFI] == true) {
+			while (!wilc->initialized) {
+				msleep(100);
+				if (++count > 20) {
+					pr_warn("Wifi initialize timeout\n");
+					break;
+				}
+			}
+		} else if (wilc->power.status[DEV_BT] == true) {
+			while (!bt_init_done) {
+				msleep(200);
+				if (++count > 30) {
+					pr_warn("BT initialize timeout\n");
+					break;
+				}
+			}
+			/* An additional wait to give BT firmware time to do
+			 * CPLL update as the time measured since the start of
+			 * BT Fw till the end of function "rf_nmi_init_tuner"
+			 * was 71.2 ms
+			 */
+			msleep(100);
+		}
+	}
+
+	if ((wilc->power.status[DEV_WIFI] == true) ||
+		   (wilc->power.status[DEV_BT] == true)) {
+		pr_info("Device already up. request source is %s\n",
+			 (source == DEV_WIFI ? "Wifi" : "BT"));
+	} else {
+		pr_info("WILC POWER UP\n");
+	}
+	wilc->power.status[source] = true;
+	mutex_unlock(&wilc->cs);
+
+	if (source == DEV_BT) {
+		/*TicketId1092*/
+		/*If WiFi is off, force BT*/
+		if (wilc->power.status[DEV_WIFI] == false) {
+			acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+			/*TicketId1115*/
+			/*Disable awake coex null frames*/
+			ret = hif_func->hif_read_reg(wilc,
+						     COE_AUTO_PS_ON_NULL_PKT,
+						     &reg);
+			if (ret) {
+				pr_err("[wilc start]: fail read reg %x\n",
+				       COE_AUTO_PS_ON_NULL_PKT);
+				goto fail;
+			}
+			reg &= ~BIT(30);
+			ret = hif_func->hif_write_reg(wilc,
+						      COE_AUTO_PS_ON_NULL_PKT,
+						      reg);
+			if (ret) {
+				pr_err("[wilc start]: fail write reg %x\n",
+				       COE_AUTO_PS_ON_NULL_PKT);
+				goto fail;
+			}
+
+			/*TicketId1115*/
+			/*Disable doze coex null frames*/
+			ret = hif_func->hif_read_reg(wilc,
+						     COE_AUTO_PS_OFF_NULL_PKT,
+						     &reg);
+			if (ret) {
+				pr_err("[wilc start]: fail read reg %x\n",
+				       COE_AUTO_PS_OFF_NULL_PKT);
+				goto fail;
+			}
+			reg &= ~BIT(30);
+			ret = hif_func->hif_write_reg(wilc,
+						      COE_AUTO_PS_OFF_NULL_PKT,
+						      reg);
+			if (ret) {
+				pr_err("[wilc start]: fail write reg %x\n",
+				       COE_AUTO_PS_OFF_NULL_PKT);
+				goto fail;
+			}
+
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+		}
+
+		/* Enable BT wakeup */
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+		ret = hif_func->hif_read_reg(wilc, PWR_SEQ_MISC_CTRL,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x ...\n",
+			       PWR_SEQ_MISC_CTRL);
+			goto fail;
+		}
+		reg |= BIT(29);
+		ret = hif_func->hif_write_reg(wilc, PWR_SEQ_MISC_CTRL,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x ...\n",
+			       PWR_SEQ_MISC_CTRL);
+			goto fail;
+		}
+
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+	}
+
+	return 0;
+
+fail:
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+	wilc_bt_power_down(wilc, DEV_BT);
+	return ret;
+}
+
+static void wilc_bt_firmware_download(struct wilc *wilc)
+{
+	u32 offset;
+	u32 addr, size, size2, blksz;
+	u8 *dma_buffer;
+	const struct firmware *wilc_bt_firmware;
+	const u8 *buffer;
+	size_t buffer_size;
+	int ret = 0;
+	u32 reg;
+	const struct wilc_hif_func *hif_func;
+
+	hif_func = wilc->hif_func;
+
+	pr_info("Bluetooth firmware: %s\n", FW_WILC3000_BLE);
+	if (request_firmware(&wilc_bt_firmware, FW_WILC3000_BLE, dev) != 0) {
+		pr_err("%s - firmare not available. Skip!\n", FW_WILC3000_BLE);
+		ret = -1;
+		goto fail_1;
+	}
+
+	buffer = wilc_bt_firmware->data;
+	buffer_size = (size_t)wilc_bt_firmware->size;
+	if (buffer_size <= 0) {
+		pr_err("Firmware size = 0!\n");
+		ret = -1;
+		goto fail_1;
+	}
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+	ret = hif_func->hif_write_reg(wilc, 0x4f0000, 0x71);
+	if (ret) {
+		pr_err("[wilc start]: fail write reg 0x4f0000 ...\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+		goto fail_1;
+	}
+
+	/*
+	 * Avoid booting from BT boot ROM. Make sure that Drive IRQN
+	 * [SDIO platform] or SD_DAT3 [SPI platform] to ?1?
+	 */
+	/* Set cortus reset register to register control. */
+	ret = hif_func->hif_read_reg(wilc, 0x3b0090, &reg);
+	if (ret) {
+		pr_err("[wilc start]: fail read reg 0x3b0090 ...\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+		goto fail_1;
+	}
+
+	reg |= (1 << 0);
+	ret = hif_func->hif_write_reg(wilc, 0x3b0090, reg);
+	if (ret) {
+		pr_err("[wilc start]: fail write reg 0x3b0090 ...\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+		goto fail_1;
+	}
+
+	hif_func->hif_read_reg(wilc, 0x3B0400, &reg);
+
+	if (reg & (1ul << 2)) {
+		reg &= ~(1ul << 2);
+	} else {
+		reg |= (1ul << 2);
+		hif_func->hif_write_reg(wilc, 0x3B0400, reg);
+		reg &= ~(1ul << 2);
+	}
+	hif_func->hif_write_reg(wilc, 0x3B0400, reg);
+
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+
+	/* blocks of sizes > 512 causes the wifi to hang! */
+	blksz = (1ul << 9);
+	/* Allocate a DMA coherent  buffer. */
+	dma_buffer = kmalloc(blksz, GFP_KERNEL);
+	if (dma_buffer == NULL) {
+		ret = -5;
+		pr_err("Can't allocate buffer for BT firmware download IO error\n");
+		goto fail_1;
+	}
+	pr_info("Downloading BT firmware size = %d ...\n", buffer_size);
+
+	offset = 0;
+	addr = 0x400000;
+	size = buffer_size;
+	addr = cpu_to_le32(addr);
+	size = cpu_to_le32(size);
+	offset = 0;
+
+	while (((int)size) && (offset < buffer_size)) {
+		if (size <= blksz)
+			size2 = size;
+		else
+			size2 = blksz;
+
+		/* Copy firmware into a DMA coherent buffer */
+		memcpy(dma_buffer, &buffer[offset], size2);
+
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+		ret = hif_func->hif_block_tx(wilc, addr, dma_buffer, size2);
+
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+
+		if (ret)
+			break;
+
+		addr += size2;
+		offset += size2;
+		size -= size2;
+	}
+
+	if (ret) {
+		ret = -5;
+		pr_err("Can't download BT firmware IO error\n");
+		goto fail;
+	}
+
+fail:
+	kfree(dma_buffer);
+fail_1:
+	pr_debug("Freeing BT FW buffer ...\n");
+	pr_debug("Releasing BT firmware\n");
+	release_firmware(wilc_bt_firmware);
+}
+
+static void wilc_bt_start(struct wilc *wilc)
+{
+	u32 val32 = 0;
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+	pr_info("Starting BT firmware\n");
+	/*
+	 * Write the firmware download complete magic value 0x10ADD09E at
+	 * location 0xFFFF000C (Cortus map) or C000C (AHB map).
+	 * This will let the boot-rom code execute from RAM.
+	 */
+	wilc->hif_func->hif_write_reg(wilc, 0x4F000c, 0x10add09e);
+
+	wilc->hif_func->hif_read_reg(wilc, 0x3B0400, &val32);
+	val32 &= ~((1ul << 2) | (1ul << 3));
+	wilc->hif_func->hif_write_reg(wilc, 0x3B0400, val32);
+
+	msleep(100);
+
+	val32 |= ((1ul << 2) | (1ul << 3));
+
+	wilc->hif_func->hif_write_reg(wilc, 0x3B0400, val32);
+
+	pr_info("BT Start Succeeded\n");
+
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+}
+
+static void handle_cmd_pwr_up(char *param)
+{
+	pr_info("AT PWR: bt_power_up\n");
+	bt_init_done = 0;
+
+	if (!wilc_bt->initialized && !wilc_bt->hif_func->hif_is_init(wilc_bt)) {
+		acquire_bus(wilc_bt, WILC_BUS_ACQUIRE_ONLY, DEV_BT);
+		if (wilc_bt->hif_func->hif_init(wilc_bt, false)) {
+			release_bus(wilc_bt, WILC_BUS_RELEASE_ONLY, DEV_BT);
+			return;
+		}
+		release_bus(wilc_bt, WILC_BUS_RELEASE_ONLY, DEV_BT);
+	}
+
+	wilc_bt_power_up(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_pwr_down(char *param)
+{
+	wilc_bt_power_down(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_chip_wake_up(char *param)
+{
+	chip_wakeup(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_chip_allow_sleep(char *param)
+{
+	bt_init_done = 1;
+	chip_allow_sleep(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_download_fw(char *param)
+{
+	pr_info("AT PWR: bt_download_fw\n");
+
+	wilc_bt_firmware_download(wilc_bt);
+	wilc_bt_start(wilc_bt);
+}
+
+static void handle_cmd_bt_enable(char *param)
+{
+	wilc_bt_power_up(wilc_bt, DEV_BT);
+	wilc_bt_firmware_download(wilc_bt);
+	wilc_bt_start(wilc_bt);
+}
+
+void wilc_bt_init(struct wilc *wilc)
+{
+	wilc_bt = wilc;
+	pr_debug("at_pwr_dev: init\n");
+	wilc_bt_create_device();
+}
+
+void wilc_bt_deinit(void)
+{
+	pr_info("at_pwr_dev: deinit\n");
+
+	if (&wilc_bt->cs != NULL)
+		mutex_destroy(&wilc_bt->cs);
+
+	cdev_del(&str_chc_dev);
+	device_created = 0;
+	device_destroy(chc_dev_class, chc_dev_no);
+	class_destroy(chc_dev_class);
+	unregister_chrdev_region(chc_dev_no, 1);
+	pr_info("at_pwr_dev: unregistered\n");
+}
diff --git a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.c b/drivers/staging/wilc1000/cfg80211.c
similarity index 52%
rename from drivers/staging/wilc1000/wilc_wfi_cfgoperations.c
rename to drivers/staging/wilc1000/cfg80211.c
index c3cd6f389..f62b318da 100644
--- a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.c
+++ b/drivers/staging/wilc1000/cfg80211.c
@@ -4,31 +4,22 @@
  * All rights reserved.
  */
 
-#include "wilc_wfi_cfgoperations.h"
+#include <linux/etherdevice.h>
 
-#define FRAME_TYPE_ID			0
-#define ACTION_CAT_ID			24
-#define ACTION_SUBTYPE_ID		25
-#define P2P_PUB_ACTION_SUBTYPE		30
-
-#define ACTION_FRAME			0xd0
-#define GO_INTENT_ATTR_ID		0x04
-#define CHANLIST_ATTR_ID		0x0b
-#define OPERCHAN_ATTR_ID		0x11
-#define PUB_ACTION_ATTR_ID		0x04
-#define P2PELEM_ATTR_ID			0xdd
+#include "cfg80211.h"
+#include "netdev.h"
 
 #define GO_NEG_REQ			0x00
 #define GO_NEG_RSP			0x01
 #define GO_NEG_CONF			0x02
 #define P2P_INV_REQ			0x03
 #define P2P_INV_RSP			0x04
-#define PUBLIC_ACT_VENDORSPEC		0x09
-#define GAS_INITIAL_REQ			0x0a
-#define GAS_INITIAL_RSP			0x0b
 
 #define WILC_INVALID_CHANNEL		0
 
+/* Operation at 2.4 GHz with channels 1-13 */
+#define WILC_WLAN_OPERATING_CLASS_2_4GHZ		0x51
+
 static const struct ieee80211_txrx_stypes
 	wilc_wfi_cfg80211_mgmt_types[NUM_NL80211_IFTYPES] = {
 	[NL80211_IFTYPE_STATION] = {
@@ -55,28 +46,74 @@ static const struct ieee80211_txrx_stypes
 			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
 			BIT(IEEE80211_STYPE_AUTH >> 4) |
 			BIT(IEEE80211_STYPE_DEAUTH >> 4)
-	}
+	},
 };
 
+#ifdef CONFIG_PM
 static const struct wiphy_wowlan_support wowlan_support = {
 	.flags = WIPHY_WOWLAN_ANY
 };
+#endif
 
 struct wilc_p2p_mgmt_data {
 	int size;
 	u8 *buff;
 };
 
-static const u8 p2p_oui[] = {0x50, 0x6f, 0x9A, 0x09};
-static const u8 p2p_vendor_spec[] = {0xdd, 0x05, 0x00, 0x08, 0x40, 0x03};
+struct wilc_p2p_pub_act_frame {
+	u8 category;
+	u8 action;
+	u8 oui[3];
+	u8 oui_type;
+	u8 oui_subtype;
+	u8 dialog_token;
+	u8 elem[];
+} __packed;
+
+struct wilc_vendor_specific_ie {
+	u8 tag_number;
+	u8 tag_len;
+	u8 oui[3];
+	u8 oui_type;
+	u8 attr[];
+} __packed;
+
+struct wilc_attr_entry {
+	u8  attr_type;
+	__le16 attr_len;
+	u8 val[];
+} __packed;
+
+struct wilc_attr_oper_ch {
+	u8 attr_type;
+	__le16 attr_len;
+	u8 country_code[IEEE80211_COUNTRY_STRING_LEN];
+	u8 op_class;
+	u8 op_channel;
+} __packed;
+
+struct wilc_attr_ch_list {
+	u8 attr_type;
+	__le16 attr_len;
+	u8 country_code[IEEE80211_COUNTRY_STRING_LEN];
+	u8 elem[];
+} __packed;
+
+struct wilc_ch_list_elem {
+	u8 op_class;
+	u8 no_of_channels;
+	u8 ch_list[];
+} __packed;
 
 static void cfg_scan_result(enum scan_event scan_event,
 			    struct wilc_rcvd_net_info *info, void *user_void)
 {
 	struct wilc_priv *priv = user_void;
 
-	if (!priv->cfg_scanning)
+	if (!priv || !priv->cfg_scanning) {
+		pr_err("%s is NULL\n", __func__);
 		return;
+	}
 
 	if (scan_event == SCAN_EVENT_NETWORK_FOUND) {
 		s32 freq;
@@ -93,21 +130,30 @@ static void cfg_scan_result(enum scan_event scan_event,
 		if (!channel)
 			return;
 
+		PRINT_D(priv->dev, CFG80211_DBG,
+			"Network Info:: CHANNEL Frequency: %d, RSSI: %d,\n",
+			freq, ((s32)info->rssi * 100));
+
 		bss = cfg80211_inform_bss_frame(wiphy, channel, info->mgmt,
 						info->frame_len,
 						(s32)info->rssi * 100,
 						GFP_KERNEL);
-		if (!bss)
-			cfg80211_put_bss(wiphy, bss);
+		cfg80211_put_bss(wiphy, bss);
 	} else if (scan_event == SCAN_EVENT_DONE) {
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Scan Done[%p]\n",
+			   priv->dev);
 		mutex_lock(&priv->scan_req_lock);
 
 		if (priv->scan_req) {
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
 			struct cfg80211_scan_info info = {
 				.aborted = false,
 			};
 
 			cfg80211_scan_done(priv->scan_req, &info);
+#else
+			cfg80211_scan_done(priv->scan_req, false);
+#endif
 			priv->cfg_scanning = false;
 			priv->scan_req = NULL;
 		}
@@ -115,12 +161,17 @@ static void cfg_scan_result(enum scan_event scan_event,
 	} else if (scan_event == SCAN_EVENT_ABORTED) {
 		mutex_lock(&priv->scan_req_lock);
 
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Scan Aborted\n");
 		if (priv->scan_req) {
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
 			struct cfg80211_scan_info info = {
 				.aborted = false,
 			};
-
 			cfg80211_scan_done(priv->scan_req, &info);
+#else
+			cfg80211_scan_done(priv->scan_req, false);
+#endif
+
 			priv->cfg_scanning = false;
 			priv->scan_req = NULL;
 		}
@@ -128,73 +179,113 @@ static void cfg_scan_result(enum scan_event scan_event,
 	}
 }
 
-static void cfg_connect_result(enum conn_event conn_disconn_evt, u8 mac_status,
-			       void *priv_data)
+static void cfg_connect_result(enum conn_event conn_disconn_evt,
+			       u8 mac_status, void *priv_data)
 {
 	struct wilc_priv *priv = priv_data;
 	struct net_device *dev = priv->dev;
 	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wl = vif->wilc;
 	struct host_if_drv *wfi_drv = priv->hif_drv;
 	struct wilc_conn_info *conn_info = &wfi_drv->conn_info;
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+	struct wiphy *wiphy = dev->ieee80211_ptr->wiphy;
+#endif
 
 	vif->connecting = false;
 
-	if (conn_disconn_evt == CONN_DISCONN_EVENT_CONN_RESP) {
+	if (conn_disconn_evt == EVENT_CONN_RESP) {
 		u16 connect_status = conn_info->status;
 
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Connection response received=%d connect_stat[%d]\n",
+			   mac_status, connect_status);
 		if (mac_status == WILC_MAC_STATUS_DISCONNECTED &&
 		    connect_status == WLAN_STATUS_SUCCESS) {
 			connect_status = WLAN_STATUS_UNSPECIFIED_FAILURE;
 			wilc_wlan_set_bssid(priv->dev, NULL, WILC_STATION_MODE);
 
 			if (vif->iftype != WILC_CLIENT_MODE)
-				wl->sta_ch = WILC_INVALID_CHANNEL;
+				vif->wilc->sta_ch = WILC_INVALID_CHANNEL;
 
-			netdev_err(dev, "Unspecified failure\n");
+			PRINT_ER(dev, "Unspecified failure\n");
 		}
 
-		if (connect_status == WLAN_STATUS_SUCCESS)
+		if (connect_status == WLAN_STATUS_SUCCESS) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				"Connection Successful: BSSID: %x%x%x%x%x%x\n",
+				conn_info->bssid[0], conn_info->bssid[1],
+				conn_info->bssid[2], conn_info->bssid[3],
+				conn_info->bssid[4], conn_info->bssid[5]);
 			memcpy(priv->associated_bss, conn_info->bssid,
 			       ETH_ALEN);
+		}
 
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Association request info elements length = %d\n",
+			   conn_info->req_ies_len);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Association response info elements length = %d\n",
+			   conn_info->resp_ies_len);
+#if KERNEL_VERSION(4, 11, 0) <= LINUX_VERSION_CODE
+		cfg80211_ref_bss(wiphy, vif->bss);
+		cfg80211_connect_bss(dev, conn_info->bssid, vif->bss,
+				     conn_info->req_ies,
+				     conn_info->req_ies_len,
+				     conn_info->resp_ies,
+				     conn_info->resp_ies_len,
+				     connect_status, GFP_KERNEL,
+				     NL80211_TIMEOUT_UNSPECIFIED);
+#elif KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+		cfg80211_ref_bss(wiphy, vif->bss);
+		cfg80211_connect_bss(dev, conn_info->bssid, vif->bss,
+				     conn_info->req_ies,
+				     conn_info->req_ies_len,
+				     conn_info->resp_ies,
+				     conn_info->resp_ies_len,
+				     connect_status, GFP_KERNEL);
+#else
 		cfg80211_connect_result(dev, conn_info->bssid,
 					conn_info->req_ies,
 					conn_info->req_ies_len,
 					conn_info->resp_ies,
 					conn_info->resp_ies_len, connect_status,
 					GFP_KERNEL);
-	} else if (conn_disconn_evt == CONN_DISCONN_EVENT_DISCONN_NOTIF) {
+#endif
+		vif->bss = NULL;
+	} else if (conn_disconn_evt == EVENT_DISCONN_NOTIF) {
 		u16 reason = 0;
 
-		priv->p2p.local_random = 0x01;
-		priv->p2p.recv_random = 0x00;
-		priv->p2p.is_wilc_ie = false;
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			 "Received WILC_MAC_STATUS_DISCONNECTED dev [%p]\n",
+			 priv->dev);
 		eth_zero_addr(priv->associated_bss);
 		wilc_wlan_set_bssid(priv->dev, NULL, WILC_STATION_MODE);
 
 		if (vif->iftype != WILC_CLIENT_MODE) {
-			wl->sta_ch = WILC_INVALID_CHANNEL;
+			vif->wilc->sta_ch = WILC_INVALID_CHANNEL;
 		} else {
 			if (wfi_drv->ifc_up)
 				reason = 3;
 			else
 				reason = 1;
 		}
-
+#if KERNEL_VERSION(4, 2, 0) > LINUX_VERSION_CODE
+		cfg80211_disconnected(dev, reason, NULL, 0, GFP_KERNEL);
+#else
 		cfg80211_disconnected(dev, reason, NULL, 0, false, GFP_KERNEL);
+#endif
 	}
 }
 
-static struct wilc_vif *wilc_get_wl_to_vif(struct wilc *wl)
+struct wilc_vif *wilc_get_wl_to_vif(struct wilc *wl)
 {
-	int i;
+	struct wilc_vif *vif;
 
-	for (i = 0; i < wl->vif_num; i++)
-		if (wl->vif[i])
-			return wl->vif[i];
+	vif = list_first_or_null_rcu(&wl->vif_list, typeof(*vif), list);
+	if (!vif)
+		return ERR_PTR(-EINVAL);
 
-	return ERR_PTR(-EINVAL);
+	return vif;
 }
 
 static int set_channel(struct wiphy *wiphy,
@@ -202,24 +293,29 @@ static int set_channel(struct wiphy *wiphy,
 {
 	struct wilc *wl = wiphy_priv(wiphy);
 	struct wilc_vif *vif;
-	u32 channelnum;
-	int result;
+	u32 channelnum = 0;
+	int result = 0;
+	int srcu_idx;
 
-	mutex_lock(&wl->vif_mutex);
+	srcu_idx = srcu_read_lock(&wl->srcu);
 	vif = wilc_get_wl_to_vif(wl);
 	if (IS_ERR(vif)) {
-		mutex_unlock(&wl->vif_mutex);
-		return PTR_ERR(vif);
+		srcu_read_unlock(&wl->srcu, srcu_idx);
+		return 0;
 	}
 
 	channelnum = ieee80211_frequency_to_channel(chandef->chan->center_freq);
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Setting channel %d with frequency %d\n",
+		   channelnum, chandef->chan->center_freq);
 
 	wl->op_ch = channelnum;
 	result = wilc_set_mac_chnl_num(vif, channelnum);
-	if (result)
-		netdev_err(vif->ndev, "Error in setting channel\n");
+	if (result != 0)
+		PRINT_ER(vif->ndev, "Error in setting channel %d\n",
+			 channelnum);
 
-	mutex_unlock(&wl->vif_mutex);
+	srcu_read_unlock(&wl->srcu, srcu_idx);
 	return result;
 }
 
@@ -233,7 +329,7 @@ static int scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)
 	u8 scan_type;
 
 	if (request->n_channels > WILC_MAX_NUM_SCANNED_CH) {
-		netdev_err(vif->ndev, "Requested scanned channels over\n");
+		PRINT_ER(priv->dev, "Requested scanned channels over\n");
 		return -EINVAL;
 	}
 
@@ -242,9 +338,22 @@ static int scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)
 	for (i = 0; i < request->n_channels; i++) {
 		u16 freq = request->channels[i]->center_freq;
 
-		scan_ch_list[i] = ieee80211_frequency_to_channel(freq);
+		scan_ch_list[i] = (u8)ieee80211_frequency_to_channel(freq);
+		PRINT_D(vif->ndev, CFG80211_DBG,
+			"ScanChannel List[%d] = %d",
+			i, scan_ch_list[i]);
 	}
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Requested num of channel %d\n",
+		   request->n_channels);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Scan Request IE len =  %d\n",
+		   request->ie_len);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Number of SSIDs %d\n",
+		   request->n_ssids);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Trigger Scan Request\n");
+
 	if (request->n_ssids)
 		scan_type = WILC_FW_ACTIVE_SCAN;
 	else
@@ -257,6 +366,8 @@ static int scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)
 	if (ret) {
 		priv->scan_req = NULL;
 		priv->cfg_scanning = false;
+		PRINT_WRN(vif->ndev, CFG80211_DBG,
+			  "Device is busy: Error(%d)\n", ret);
 	}
 
 	return ret;
@@ -279,13 +390,44 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 
 	vif->connecting = true;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Connecting to SSID [%s] on netdev [%p] host if [%x]\n",
+		   sme->ssid, dev, (u32)priv->hif_drv);
+
+	if (vif->iftype == WILC_CLIENT_MODE)
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Connected to Direct network,OBSS disabled\n");
+
+	PRINT_D(vif->ndev, CFG80211_DBG, "Required SSID= %s\n, AuthType= %d\n",
+		sme->ssid, sme->auth_type);
+
 	memset(priv->wep_key, 0, sizeof(priv->wep_key));
 	memset(priv->wep_key_len, 0, sizeof(priv->wep_key_len));
 
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.wpa_versions=%x\n",
+		sme->crypto.wpa_versions);
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.cipher_group=%x\n",
+		sme->crypto.cipher_group);
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.n_ciphers_pairwise=%d\n",
+		sme->crypto.n_ciphers_pairwise);
+	for (i = 0; i < sme->crypto.n_ciphers_pairwise; i++)
+		PRINT_D(vif->ndev, CORECONFIG_DBG,
+			"sme->crypto.ciphers_pairwise[%d]=%x\n", i,
+			sme->crypto.ciphers_pairwise[i]);
+
 	cipher_group = sme->crypto.cipher_group;
 	if (cipher_group != 0) {
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   ">> sme->crypto.wpa_versions: %x\n",
+			   sme->crypto.wpa_versions);
 		if (cipher_group == WLAN_CIPHER_SUITE_WEP40) {
 			security = WILC_FW_SEC_WEP;
+			PRINT_D(vif->ndev, CFG80211_DBG,
+				"WEP Default Key Idx = %d\n", sme->key_idx);
+
+			for (i = 0; i < sme->key_len; i++)
+				PRINT_D(vif->ndev, CORECONFIG_DBG,
+				"WEP Key Value[%d] = %d\n", i, sme->key[i]);
 
 			priv->wep_key_len[sme->key_idx] = sme->key_len;
 			memcpy(priv->wep_key[sme->key_idx], sme->key,
@@ -316,8 +458,7 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 				security = WILC_FW_SEC_WPA_AES;
 		} else {
 			ret = -ENOTSUPP;
-			netdev_err(dev, "%s: Unsupported cipher\n",
-				   __func__);
+			PRINT_ER(dev, "Unsupported cipher\n");
 			goto out_error;
 		}
 	}
@@ -334,16 +475,26 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 		}
 	}
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Adding key with cipher group %x\n",
+		   cipher_group);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Authentication Type = %d\n",
+		   sme->auth_type);
 	switch (sme->auth_type) {
 	case NL80211_AUTHTYPE_OPEN_SYSTEM:
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "In OPEN SYSTEM\n");
 		auth_type = WILC_FW_AUTH_OPEN_SYSTEM;
 		break;
 
 	case NL80211_AUTHTYPE_SHARED_KEY:
 		auth_type = WILC_FW_AUTH_SHARED_KEY;
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "In SHARED KEY\n");
 		break;
 
 	default:
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Automatic Authentication type= %d\n",
+			   sme->auth_type);
 		break;
 	}
 
@@ -358,14 +509,19 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 		goto out_error;
 	}
 
+#if KERNEL_VERSION(4, 1, 0) > LINUX_VERSION_CODE
+	bss = cfg80211_get_bss(wiphy, sme->channel, sme->bssid, sme->ssid,
+			       sme->ssid_len, WLAN_CAPABILITY_ESS,
+			       WLAN_CAPABILITY_ESS);
+#else
 	bss = cfg80211_get_bss(wiphy, sme->channel, sme->bssid, sme->ssid,
 			       sme->ssid_len, IEEE80211_BSS_TYPE_ANY,
 			       IEEE80211_PRIVACY(sme->privacy));
+#endif
 	if (!bss) {
 		ret = -EINVAL;
 		goto out_error;
 	}
-
 	if (ether_addr_equal_unaligned(vif->bssid, bss->bssid)) {
 		ret = -EALREADY;
 		goto out_put_bss;
@@ -373,13 +529,13 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 
 	join_params = wilc_parse_join_bss_param(bss, &sme->crypto);
 	if (!join_params) {
-		netdev_err(dev, "%s: failed to construct join param\n",
-			   __func__);
+		PRINT_ER(vif->ndev, "%s: failed to construct join param\n",
+			 __func__);
 		ret = -EINVAL;
 		goto out_put_bss;
 	}
-
 	ch = ieee80211_frequency_to_channel(bss->channel->center_freq);
+	PRINT_D(vif->ndev, CFG80211_DBG, "Required Channel = %d\n", ch);
 	vif->wilc->op_ch = ch;
 	if (vif->iftype != WILC_CLIENT_MODE)
 		vif->wilc->sta_ch = ch;
@@ -395,7 +551,7 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 
 	ret = wilc_set_join_req(vif, bss->bssid, sme->ie, sme->ie_len);
 	if (ret) {
-		netdev_err(dev, "wilc_set_join_req(): Error\n");
+		PRINT_ER(dev, "wilc_set_join_req(): Error(%d)\n", ret);
 		ret = -ENOENT;
 		if (vif->iftype != WILC_CLIENT_MODE)
 			vif->wilc->sta_ch = WILC_INVALID_CHANNEL;
@@ -405,6 +561,7 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 		goto out_put_bss;
 	}
 	kfree(join_params);
+	vif->bss = bss;
 	cfg80211_put_bss(wiphy, bss);
 	return 0;
 
@@ -422,34 +579,30 @@ static int disconnect(struct wiphy *wiphy, struct net_device *dev,
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
 	struct wilc *wilc = vif->wilc;
+	struct host_if_drv *wfi_drv;
 	int ret;
 
 	vif->connecting = false;
 
 	if (!wilc)
 		return -EIO;
-
-	if (wilc->close) {
-		/* already disconnected done */
-		cfg80211_disconnected(dev, 0, NULL, 0, true, GFP_KERNEL);
-		return 0;
-	}
-
+	wfi_drv = (struct host_if_drv *)priv->hif_drv;
 	if (vif->iftype != WILC_CLIENT_MODE)
 		wilc->sta_ch = WILC_INVALID_CHANNEL;
 	wilc_wlan_set_bssid(priv->dev, NULL, WILC_STATION_MODE);
 
-	priv->p2p.local_random = 0x01;
-	priv->p2p.recv_random = 0x00;
-	priv->p2p.is_wilc_ie = false;
-	priv->hif_drv->p2p_timeout = 0;
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Disconnecting with reason code(%d)\n", reason_code);
+	wfi_drv->p2p_timeout = 0;
 
 	ret = wilc_disconnect(vif);
 	if (ret != 0) {
-		netdev_err(priv->dev, "Error in disconnecting\n");
+		PRINT_ER(priv->dev, "Error in disconnecting (%d)\n", ret);
 		ret = -EINVAL;
 	}
 
+	vif->bss = NULL;
+
 	return ret;
 }
 
@@ -506,7 +659,8 @@ static int wilc_wfi_cfg_copy_wpa_info(struct wilc_wfi_key *key_info,
 }
 
 static int add_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
-		   bool pairwise, const u8 *mac_addr, struct key_params *params)
+		   bool pairwise,
+		   const u8 *mac_addr, struct key_params *params)
 
 {
 	int ret = 0, keylen = params->key_len;
@@ -514,15 +668,35 @@ static int add_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
 	const u8 *tx_mic = NULL;
 	u8 mode = WILC_FW_SEC_NO;
 	u8 op_mode;
+	int i;
 	struct wilc_vif *vif = netdev_priv(netdev);
 	struct wilc_priv *priv = &vif->priv;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Adding key with cipher suite = %x\n", params->cipher);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "%x %x %d\n", (u32)wiphy,
+		   (u32)netdev, key_index);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "key %x %x %x\n", params->key[0],
+		   params->key[1],
+		   params->key[2]);
 	switch (params->cipher) {
 	case WLAN_CIPHER_SUITE_WEP40:
 	case WLAN_CIPHER_SUITE_WEP104:
 		if (priv->wdev.iftype == NL80211_IFTYPE_AP) {
 			wilc_wfi_cfg_copy_wep_info(priv, key_index, params);
 
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Adding AP WEP Default key Idx = %d\n",
+				   key_index);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Adding AP WEP Key len= %d\n",
+				   params->key_len);
+
+			for (i = 0; i < params->key_len; i++)
+				PRINT_INFO(vif->ndev, CFG80211_DBG,
+					   "WEP AP key val[%d] = %x\n", i,
+					   params->key[i]);
+
 			if (params->cipher == WLAN_CIPHER_SUITE_WEP40)
 				mode = WILC_FW_SEC_WEP;
 			else
@@ -538,6 +712,12 @@ static int add_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
 			   params->key_len)) {
 			wilc_wfi_cfg_copy_wep_info(priv, key_index, params);
 
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Adding WEP Default key Idx = %d\n",
+				   key_index);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Adding WEP Key length = %d\n",
+				   params->key_len);
 			ret = wilc_add_wep_key_bss_sta(vif, params->key,
 						       params->key_len,
 						       key_index);
@@ -572,10 +752,15 @@ static int add_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
 
 				key = priv->wilc_gtk[key_index];
 			} else {
+				PRINT_D(vif->ndev, CFG80211_DBG,
+					"STA Address: %x%x%x%x%x\n",
+					mac_addr[0], mac_addr[1], mac_addr[2],
+					mac_addr[3], mac_addr[4]);
 				if (params->cipher == WLAN_CIPHER_SUITE_TKIP)
 					mode = WILC_FW_SEC_WPA_TKIP;
 				else
-					mode = priv->wilc_groupkey | WILC_FW_AES;
+					mode = (priv->wilc_groupkey |
+						WILC_FW_AES);
 
 				key = priv->wilc_ptk[key_index];
 			}
@@ -608,7 +793,7 @@ static int add_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
 		break;
 
 	default:
-		netdev_err(netdev, "%s: Unsupported cipher\n", __func__);
+		PRINT_ER(netdev, "Unsupported cipher\n");
 		ret = -ENOTSUPP;
 	}
 
@@ -620,11 +805,12 @@ static int del_key(struct wiphy *wiphy, struct net_device *netdev,
 		   bool pairwise,
 		   const u8 *mac_addr)
 {
-	struct wilc *wl = wiphy_priv(wiphy);
+	int ret = 0;
 	struct wilc_vif *vif = netdev_priv(netdev);
 	struct wilc_priv *priv = &vif->priv;
 
-	if (netdev == wl->vif[0]->ndev) {
+	//TODO: Why to compare with only interface vif[0]
+	//if (netdev == wl->vif[0]->ndev) {
 		if (priv->wilc_gtk[key_index]) {
 			kfree(priv->wilc_gtk[key_index]->key);
 			priv->wilc_gtk[key_index]->key = NULL;
@@ -643,16 +829,18 @@ static int del_key(struct wiphy *wiphy, struct net_device *netdev,
 			kfree(priv->wilc_ptk[key_index]);
 			priv->wilc_ptk[key_index] = NULL;
 		}
-	}
+	//}
 
 	if (key_index <= 3 && priv->wep_key_len[key_index]) {
 		memset(priv->wep_key[key_index], 0,
 		       priv->wep_key_len[key_index]);
 		priv->wep_key_len[key_index] = 0;
-		wilc_remove_wep_key(vif, key_index);
+		pr_info("%s: Removing WEP key with index = %d\n", __func__,
+			   key_index);
+		ret = wilc_remove_wep_key(vif, key_index);
 	}
 
-	return 0;
+	return ret;
 }
 
 static int get_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
@@ -664,12 +852,15 @@ static int get_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
 	struct  key_params key_params;
 
 	if (!pairwise) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Getting group key idx: %x\n", key_index);
 		key_params.key = priv->wilc_gtk[key_index]->key;
 		key_params.cipher = priv->wilc_gtk[key_index]->cipher;
 		key_params.key_len = priv->wilc_gtk[key_index]->key_len;
 		key_params.seq = priv->wilc_gtk[key_index]->seq;
 		key_params.seq_len = priv->wilc_gtk[key_index]->seq_len;
 	} else {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Getting pairwise key\n");
 		key_params.key = priv->wilc_ptk[key_index]->key;
 		key_params.cipher = priv->wilc_ptk[key_index]->cipher;
 		key_params.key_len = priv->wilc_ptk[key_index]->key_len;
@@ -692,16 +883,24 @@ static int set_default_key(struct wiphy *wiphy, struct net_device *netdev,
 	return 0;
 }
 
+#if KERNEL_VERSION(3, 16, 0) <= LINUX_VERSION_CODE
 static int get_station(struct wiphy *wiphy, struct net_device *dev,
 		       const u8 *mac, struct station_info *sinfo)
+#else
+static int get_station(struct wiphy *wiphy, struct net_device *dev,
+		       u8 *mac, struct station_info *sinfo)
+#endif
 {
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
+	struct wilc *wilc = vif->wilc;
 	u32 i = 0;
 	u32 associatedsta = ~0;
 	u32 inactive_time = 0;
 
 	if (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Getting station parameters\n");
 		for (i = 0; i < NUM_STA_ASSOCIATED; i++) {
 			if (!(memcmp(mac,
 				     priv->assoc_stainfo.sta_associated_bss[i],
@@ -712,25 +911,42 @@ static int get_station(struct wiphy *wiphy, struct net_device *dev,
 		}
 
 		if (associatedsta == ~0) {
-			netdev_err(dev, "sta required is not associated\n");
+			PRINT_ER(dev, "sta required is not associated\n");
 			return -ENOENT;
 		}
 
-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_INACTIVE_TIME);
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
+		sinfo->filled |= BIT(NL80211_STA_INFO_INACTIVE_TIME);
+#else
+		sinfo->filled |= STATION_INFO_INACTIVE_TIME;
+#endif
 
 		wilc_get_inactive_time(vif, mac, &inactive_time);
 		sinfo->inactive_time = 1000 * inactive_time;
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Inactive time %d\n",
+			   sinfo->inactive_time);
 	} else if (vif->iftype == WILC_STATION_MODE) {
 		struct rf_info stats;
 
+		if (!wilc->initialized) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "driver not initialized\n");
+			return -EBUSY;
+		}
 		wilc_get_statistics(vif, &stats);
-
-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL) |
-				 BIT_ULL(NL80211_STA_INFO_RX_PACKETS) |
-				 BIT_ULL(NL80211_STA_INFO_TX_PACKETS) |
-				 BIT_ULL(NL80211_STA_INFO_TX_FAILED) |
-				 BIT_ULL(NL80211_STA_INFO_TX_BITRATE);
-
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
+		sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL) |
+			      BIT(NL80211_STA_INFO_RX_PACKETS) |
+			      BIT(NL80211_STA_INFO_TX_PACKETS) |
+			      BIT(NL80211_STA_INFO_TX_FAILED) |
+			      BIT(NL80211_STA_INFO_TX_BITRATE);
+#else
+		sinfo->filled |= STATION_INFO_SIGNAL |
+			      STATION_INFO_RX_PACKETS |
+			      STATION_INFO_TX_PACKETS |
+			      STATION_INFO_TX_FAILED |
+			      STATION_INFO_TX_BITRATE;
+#endif
 		sinfo->signal = stats.rssi;
 		sinfo->rx_packets = stats.rx_cnt;
 		sinfo->tx_packets = stats.tx_cnt + stats.tx_fail_cnt;
@@ -742,6 +958,11 @@ static int get_station(struct wiphy *wiphy, struct net_device *dev,
 			wilc_enable_tcp_ack_filter(vif, true);
 		else if (stats.link_speed != DEFAULT_LINK_SPEED)
 			wilc_enable_tcp_ack_filter(vif, false);
+
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "*** stats[%d][%d][%d][%d][%d]\n", sinfo->signal,
+			   sinfo->rx_packets, sinfo->tx_packets,
+			   sinfo->tx_failed, sinfo->txrate.legacy);
 	}
 	return 0;
 }
@@ -749,25 +970,10 @@ static int get_station(struct wiphy *wiphy, struct net_device *dev,
 static int change_bss(struct wiphy *wiphy, struct net_device *dev,
 		      struct bss_parameters *params)
 {
+	PRINT_INFO(dev, CFG80211_DBG, "Changing Bss parametrs\n");
 	return 0;
 }
 
-struct wilc_vif *wilc_get_interface(struct wilc *wl)
-{
-	int i;
-	struct wilc_vif *vif = NULL;
-
-	mutex_lock(&wl->vif_mutex);
-	for (i = 0; i < wl->vif_num; i++) {
-		if (wl->vif[i]) {
-			vif = wl->vif[i];
-			break;
-		}
-	}
-	mutex_unlock(&wl->vif_mutex);
-	return vif;
-}
-
 static int set_wiphy_params(struct wiphy *wiphy, u32 changed)
 {
 	int ret;
@@ -775,23 +981,29 @@ static int set_wiphy_params(struct wiphy *wiphy, u32 changed)
 	struct wilc *wl = wiphy_priv(wiphy);
 	struct wilc_vif *vif;
 	struct wilc_priv *priv;
+	int srcu_idx;
 
-	vif = wilc_get_interface(wl);
-	if (!vif)
-		return -EINVAL;
+	srcu_idx = srcu_read_lock(&wl->srcu);
+	vif = wilc_get_wl_to_vif(wl);
+	if (IS_ERR(vif)) {
+		srcu_read_unlock(&wl->srcu, srcu_idx);
+		return 0;
+	}
 
 	priv = &vif->priv;
+
 	cfg_param_val.flag = 0;
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting Wiphy params\n");
 
 	if (changed & WIPHY_PARAM_RETRY_SHORT) {
-		netdev_dbg(vif->ndev,
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
 			   "Setting WIPHY_PARAM_RETRY_SHORT %d\n",
 			   wiphy->retry_short);
 		cfg_param_val.flag  |= WILC_CFG_PARAM_RETRY_SHORT;
 		cfg_param_val.short_retry_limit = wiphy->retry_short;
 	}
 	if (changed & WIPHY_PARAM_RETRY_LONG) {
-		netdev_dbg(vif->ndev,
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
 			   "Setting WIPHY_PARAM_RETRY_LONG %d\n",
 			   wiphy->retry_long);
 		cfg_param_val.flag |= WILC_CFG_PARAM_RETRY_LONG;
@@ -800,34 +1012,41 @@ static int set_wiphy_params(struct wiphy *wiphy, u32 changed)
 	if (changed & WIPHY_PARAM_FRAG_THRESHOLD) {
 		if (wiphy->frag_threshold > 255 &&
 		    wiphy->frag_threshold < 7937) {
-			netdev_dbg(vif->ndev,
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
 				   "Setting WIPHY_PARAM_FRAG_THRESHOLD %d\n",
 				   wiphy->frag_threshold);
 			cfg_param_val.flag |= WILC_CFG_PARAM_FRAG_THRESHOLD;
 			cfg_param_val.frag_threshold = wiphy->frag_threshold;
 		} else {
-			netdev_err(vif->ndev,
-				   "Fragmentation threshold out of range\n");
-			return -EINVAL;
+			PRINT_ER(vif->ndev,
+				 "Fragmentation threshold out of range\n");
+			ret = -EINVAL;
+			goto out;
 		}
 	}
 
 	if (changed & WIPHY_PARAM_RTS_THRESHOLD) {
 		if (wiphy->rts_threshold > 255) {
-			netdev_dbg(vif->ndev,
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
 				   "Setting WIPHY_PARAM_RTS_THRESHOLD %d\n",
 				   wiphy->rts_threshold);
 			cfg_param_val.flag |= WILC_CFG_PARAM_RTS_THRESHOLD;
 			cfg_param_val.rts_threshold = wiphy->rts_threshold;
 		} else {
-			netdev_err(vif->ndev, "RTS threshold out of range\n");
-			return -EINVAL;
+			PRINT_ER(vif->ndev, "RTS threshold out of range\n");
+			ret = -EINVAL;
+			goto out;
 		}
 	}
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Setting CFG params in the host interface\n");
 	ret = wilc_hif_set_cfg(vif, &cfg_param_val);
 	if (ret)
-		netdev_err(priv->dev, "Error in setting WIPHY PARAMS\n");
+		PRINT_ER(priv->dev, "Error in setting WIPHY PARAMS\n");
+
+out:
+	srcu_read_unlock(&wl->srcu, srcu_idx);
 
 	return ret;
 }
@@ -841,14 +1060,20 @@ static int set_pmksa(struct wiphy *wiphy, struct net_device *netdev,
 	int ret = 0;
 	u8 flag = 0;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting PMKSA\n");
+
 	for (i = 0; i < priv->pmkid_list.numpmkid; i++)	{
 		if (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,
 			    ETH_ALEN)) {
 			flag = PMKID_FOUND;
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "PMKID already exists\n");
 			break;
 		}
 	}
 	if (i < WILC_MAX_NUM_PMKIDS) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting PMKID in private structure\n");
 		memcpy(priv->pmkid_list.pmkidlist[i].bssid, pmksa->bssid,
 		       ETH_ALEN);
 		memcpy(priv->pmkid_list.pmkidlist[i].pmkid, pmksa->pmkid,
@@ -856,13 +1081,15 @@ static int set_pmksa(struct wiphy *wiphy, struct net_device *netdev,
 		if (!(flag == PMKID_FOUND))
 			priv->pmkid_list.numpmkid++;
 	} else {
-		netdev_err(netdev, "Invalid PMKID index\n");
+		PRINT_ER(netdev, "Invalid PMKID index\n");
 		ret = -EINVAL;
 	}
 
-	if (!ret)
+	if (!ret) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting pmkid in the host interface\n");
 		ret = wilc_set_pmkid_info(vif, &priv->pmkid_list);
-
+	}
 	return ret;
 }
 
@@ -870,220 +1097,190 @@ static int del_pmksa(struct wiphy *wiphy, struct net_device *netdev,
 		     struct cfg80211_pmksa *pmksa)
 {
 	u32 i;
-	int ret = 0;
 	struct wilc_vif *vif = netdev_priv(netdev);
 	struct wilc_priv *priv = &vif->priv;
 
+	PRINT_INFO(netdev, CFG80211_DBG, "Deleting PMKSA keys\n");
+
 	for (i = 0; i < priv->pmkid_list.numpmkid; i++)	{
 		if (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,
 			    ETH_ALEN)) {
+			PRINT_INFO(netdev, CFG80211_DBG,
+				   "Reseting PMKID values\n");
 			memset(&priv->pmkid_list.pmkidlist[i], 0,
 			       sizeof(struct wilc_pmkid));
 			break;
 		}
 	}
 
-	if (i < priv->pmkid_list.numpmkid && priv->pmkid_list.numpmkid > 0) {
-		for (; i < (priv->pmkid_list.numpmkid - 1); i++) {
-			memcpy(priv->pmkid_list.pmkidlist[i].bssid,
-			       priv->pmkid_list.pmkidlist[i + 1].bssid,
-			       ETH_ALEN);
-			memcpy(priv->pmkid_list.pmkidlist[i].pmkid,
-			       priv->pmkid_list.pmkidlist[i + 1].pmkid,
-			       WLAN_PMKID_LEN);
-		}
-		priv->pmkid_list.numpmkid--;
-	} else {
-		ret = -EINVAL;
+	if (i == priv->pmkid_list.numpmkid)
+		return -EINVAL;
+
+	for (; i < (priv->pmkid_list.numpmkid - 1); i++) {
+		memcpy(priv->pmkid_list.pmkidlist[i].bssid,
+		       priv->pmkid_list.pmkidlist[i + 1].bssid,
+		       ETH_ALEN);
+		memcpy(priv->pmkid_list.pmkidlist[i].pmkid,
+		       priv->pmkid_list.pmkidlist[i + 1].pmkid,
+		       WLAN_PMKID_LEN);
 	}
+	priv->pmkid_list.numpmkid--;
 
-	return ret;
+	return 0;
 }
 
 static int flush_pmksa(struct wiphy *wiphy, struct net_device *netdev)
 {
 	struct wilc_vif *vif = netdev_priv(netdev);
+	struct wilc_priv *priv = &vif->priv;
 
-	memset(&vif->priv.pmkid_list, 0, sizeof(struct wilc_pmkid_attr));
+	PRINT_INFO(netdev, CFG80211_DBG, "Flushing  PMKID key values\n");
+	memset(&priv->pmkid_list, 0, sizeof(struct wilc_pmkid_attr));
 
 	return 0;
 }
 
-static inline void wilc_wfi_cfg_parse_ch_attr(u8 *buf, u8 ch_list_attr_idx,
-					      u8 op_ch_attr_idx, u8 sta_ch)
+static inline void wilc_wfi_cfg_parse_p2p_intent_attr(u8 *buf, u32 len,
+						      bool p2p_mode)
 {
-	int i = 0;
-	int j = 0;
-
-	if (ch_list_attr_idx) {
-		u8 limit = ch_list_attr_idx + 3 + buf[ch_list_attr_idx + 1];
+	struct wilc_attr_entry *e;
+	u32 index = 0;
 
-		for (i = ch_list_attr_idx + 3; i < limit; i++) {
-			if (buf[i] == 0x51) {
-				for (j = i + 2; j < ((i + 2) + buf[i + 1]); j++)
-					buf[j] = sta_ch;
-				break;
-			}
+	while (index + sizeof(*e) <= len) {
+		e = (struct wilc_attr_entry *)&buf[index];
+		if (e->attr_type == IEEE80211_P2P_ATTR_GO_INTENT) {
+			if (p2p_mode == WILC_P2P_ROLE_GO)
+				e->val[0] = (e->val[0]  & 0x01) | (0x0f << 1);
+			else
+				e->val[0] = (e->val[0]  & 0x01) | (0x00 << 1);
+			return;
 		}
-	}
-
-	if (op_ch_attr_idx) {
-		buf[op_ch_attr_idx + 6] = 0x51;
-		buf[op_ch_attr_idx + 7] = sta_ch;
+		index += le16_to_cpu(e->attr_len) + sizeof(*e);
 	}
 }
 
-static void wilc_wfi_cfg_parse_rx_action(u8 *buf, u32 len, u8 sta_ch)
+static inline void wilc_wfi_cfg_parse_p2p_attr(u8 *buf, u32 len, u8 sta_ch)
 {
+	struct wilc_attr_entry *e;
+	struct wilc_attr_ch_list *ch_list;
+	struct wilc_attr_oper_ch *op_ch;
 	u32 index = 0;
-	u8 op_channel_attr_index = 0;
-	u8 channel_list_attr_index = 0;
-
-	while (index < len) {
-		if (buf[index] == GO_INTENT_ATTR_ID)
-			buf[index + 3] = (buf[index + 3]  & 0x01) | (0x00 << 1);
-
-		if (buf[index] ==  CHANLIST_ATTR_ID)
-			channel_list_attr_index = index;
-		else if (buf[index] ==  OPERCHAN_ATTR_ID)
-			op_channel_attr_index = index;
-		index += buf[index + 1] + 3;
-	}
-	if (sta_ch != WILC_INVALID_CHANNEL)
-		wilc_wfi_cfg_parse_ch_attr(buf, channel_list_attr_index,
-					   op_channel_attr_index, sta_ch);
-}
+	u8 ch_list_idx = 0;
+	u8 op_ch_idx = 0;
 
-static void wilc_wfi_cfg_parse_tx_action(u8 *buf, u32 len, bool oper_ch,
-					 u8 iftype, u8 sta_ch)
-{
-	u32 index = 0;
-	u8 op_channel_attr_index = 0;
-	u8 channel_list_attr_index = 0;
-
-	while (index < len) {
-		if (buf[index] == GO_INTENT_ATTR_ID) {
-			buf[index + 3] = (buf[index + 3]  & 0x01) | (0x0f << 1);
+	if (sta_ch == WILC_INVALID_CHANNEL)
+		return;
 
+	while (index + sizeof(*e) <= len) {
+		e = (struct wilc_attr_entry *)&buf[index];
+		if (e->attr_type == IEEE80211_P2P_ATTR_CHANNEL_LIST)
+			ch_list_idx = index;
+		else if (e->attr_type == IEEE80211_P2P_ATTR_OPER_CHANNEL)
+			op_ch_idx = index;
+		if (ch_list_idx && op_ch_idx)
 			break;
-		}
-
-		if (buf[index] ==  CHANLIST_ATTR_ID)
-			channel_list_attr_index = index;
-		else if (buf[index] ==  OPERCHAN_ATTR_ID)
-			op_channel_attr_index = index;
-		index += buf[index + 1] + 3;
+		index += le16_to_cpu(e->attr_len) + sizeof(*e);
 	}
-	if (sta_ch != WILC_INVALID_CHANNEL && oper_ch)
-		wilc_wfi_cfg_parse_ch_attr(buf, channel_list_attr_index,
-					   op_channel_attr_index, sta_ch);
-}
 
-static void wilc_wfi_cfg_parse_rx_vendor_spec(struct wilc_priv *priv, u8 *buff,
-					      u32 size)
-{
-	int i;
-	u8 subtype;
-	struct wilc_vif *vif = netdev_priv(priv->dev);
-
-	subtype = buff[P2P_PUB_ACTION_SUBTYPE];
-	if ((subtype == GO_NEG_REQ || subtype == GO_NEG_RSP) &&
-	    !priv->p2p.is_wilc_ie) {
-		for (i = P2P_PUB_ACTION_SUBTYPE; i < size; i++) {
-			if (!memcmp(p2p_vendor_spec, &buff[i], 6)) {
-				priv->p2p.recv_random = buff[i + 6];
-				priv->p2p.is_wilc_ie = true;
+	if (ch_list_idx) {
+		u16 attr_size;
+		struct wilc_ch_list_elem *e;
+		int i;
+
+		ch_list = (struct wilc_attr_ch_list *)&buf[ch_list_idx];
+		attr_size = le16_to_cpu(ch_list->attr_len);
+		for (i = 0; i < attr_size;) {
+			e = (struct wilc_ch_list_elem *)(ch_list->elem + i);
+			if (e->op_class == WILC_WLAN_OPERATING_CLASS_2_4GHZ) {
+				memset(e->ch_list, sta_ch, e->no_of_channels);
 				break;
 			}
+			i += e->no_of_channels;
 		}
 	}
 
-	if (priv->p2p.local_random <= priv->p2p.recv_random) {
-		netdev_dbg(vif->ndev,
-			   "PEER WILL BE GO LocaRand=%02x RecvRand %02x\n",
-			   priv->p2p.local_random, priv->p2p.recv_random);
-		return;
-	}
-
-	if (subtype == GO_NEG_REQ || subtype == GO_NEG_RSP ||
-	    subtype == P2P_INV_REQ || subtype == P2P_INV_RSP) {
-		for (i = P2P_PUB_ACTION_SUBTYPE + 2; i < size; i++) {
-			if (buff[i] == P2PELEM_ATTR_ID &&
-			    !(memcmp(p2p_oui, &buff[i + 2], 4))) {
-				wilc_wfi_cfg_parse_rx_action(&buff[i + 6],
-							     size - (i + 6),
-							     vif->wilc->sta_ch);
-				break;
-			}
-		}
+	if (op_ch_idx) {
+		op_ch = (struct wilc_attr_oper_ch *)&buf[op_ch_idx];
+		op_ch->op_class = WILC_WLAN_OPERATING_CLASS_2_4GHZ;
+		op_ch->op_channel = sta_ch;
 	}
 }
 
-void wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size)
+bool wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size)
 {
 	struct wilc *wl = vif->wilc;
 	struct wilc_priv *priv = &vif->priv;
 	struct host_if_drv *wfi_drv = priv->hif_drv;
+	struct ieee80211_mgmt *mgmt;
+	struct wilc_vendor_specific_ie *p;
+	struct wilc_p2p_pub_act_frame *d;
+	int ie_offset = offsetof(struct ieee80211_mgmt, u) + sizeof(*d);
+	const u8 *vendor_ie;
 	u32 header, pkt_offset;
 	s32 freq;
-	__le16 fc;
+	int ret;
 
 	header = get_unaligned_le32(buff - HOST_HDR_OFFSET);
-	pkt_offset = GET_PKT_OFFSET(header);
+	pkt_offset = FIELD_GET(WILC_PKT_HDR_OFFSET_FIELD, header);
 
 	if (pkt_offset & IS_MANAGMEMENT_CALLBACK) {
+		struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)buff;
 		bool ack = false;
 
-		if (buff[FRAME_TYPE_ID] == IEEE80211_STYPE_PROBE_RESP ||
+		if (ieee80211_is_probe_resp(hdr->frame_control) ||
 		    pkt_offset & IS_MGMT_STATUS_SUCCES)
 			ack = true;
 
-		cfg80211_mgmt_tx_status(&priv->wdev, priv->tx_cookie, buff,
+		cfg80211_mgmt_tx_status(&vif->priv.wdev, priv->tx_cookie, buff,
 					size, ack, GFP_KERNEL);
-		return;
+		return true;
 	}
 
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
 	freq = ieee80211_channel_to_frequency(wl->op_ch, NL80211_BAND_2GHZ);
-
-	fc = ((struct ieee80211_hdr *)buff)->frame_control;
-	if (!ieee80211_is_action(fc)) {
-		cfg80211_rx_mgmt(&priv->wdev, freq, 0, buff, size, 0);
-		return;
-	}
+ #else
+	freq = ieee80211_channel_to_frequency(wl->op_ch, IEEE80211_BAND_2GHZ);
+ #endif
+	mgmt = (struct ieee80211_mgmt *)buff;
+	PRINT_D(vif->ndev, GENERIC_DBG, "Rx Frame Type:%x\n",
+		mgmt->frame_control);
+	if (!ieee80211_is_action(mgmt->frame_control))
+		goto out_rx_mgmt;
 
 	if (priv->cfg_scanning &&
 	    time_after_eq(jiffies, (unsigned long)wfi_drv->p2p_timeout)) {
-		netdev_dbg(vif->ndev, "Receiving action wrong ch\n");
-		return;
-	}
-	if (buff[ACTION_CAT_ID] == PUB_ACTION_ATTR_ID) {
-		u8 subtype = buff[P2P_PUB_ACTION_SUBTYPE];
-
-		switch (buff[ACTION_SUBTYPE_ID]) {
-		case GAS_INITIAL_REQ:
-		case GAS_INITIAL_RSP:
-			break;
-
-		case PUBLIC_ACT_VENDORSPEC:
-			if (!memcmp(p2p_oui, &buff[ACTION_SUBTYPE_ID + 1], 4))
-				wilc_wfi_cfg_parse_rx_vendor_spec(priv, buff,
-								  size);
-
-			if ((subtype == GO_NEG_REQ || subtype == GO_NEG_RSP) &&
-			    priv->p2p.is_wilc_ie)
-				size -= 7;
-
-			break;
-
-		default:
-			netdev_dbg(vif->ndev,
-				   "%s: Not handled action frame type:%x\n",
-				   __func__, buff[ACTION_SUBTYPE_ID]);
-			break;
-		}
-	}
-
-	cfg80211_rx_mgmt(&priv->wdev, freq, 0, buff, size, 0);
+		PRINT_WRN(vif->ndev, GENERIC_DBG,
+			  "Receiving action wrong ch\n");
+		return false;
+	}
+	if (!ieee80211_is_public_action((struct ieee80211_hdr *)buff, size))
+		goto out_rx_mgmt;
+
+	d = (struct wilc_p2p_pub_act_frame *)(&mgmt->u.action);
+	PRINT_D(vif->ndev, GENERIC_DBG,
+		"Rx Action action: %x category %x oui type %x sub_type[%d]\n",
+		d->action, d->category, d->oui_type, d->oui_subtype);
+
+	if (d->oui_subtype != GO_NEG_REQ && d->oui_subtype != GO_NEG_RSP &&
+	    d->oui_subtype != P2P_INV_REQ && d->oui_subtype != P2P_INV_RSP)
+		goto out_rx_mgmt;
+
+	vendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,
+					    buff + ie_offset, size - ie_offset);
+	if (!vendor_ie)
+		goto out_rx_mgmt;
+
+	p = (struct wilc_vendor_specific_ie *)vendor_ie;
+	/* use p2p mode invert value to treat other p2p device
+	 * opposite of mode set on this device.
+	 */
+	wilc_wfi_cfg_parse_p2p_intent_attr(p->attr, p->tag_len - 4,
+					   !vif->wilc->attr_sysfs.p2p_mode);
+	wilc_wfi_cfg_parse_p2p_attr(p->attr, p->tag_len - 4, vif->wilc->sta_ch);
+
+out_rx_mgmt:
+	ret = cfg80211_rx_mgmt(&vif->priv.wdev, freq, 0, buff, size, 0);
+	return ret;
 }
 
 static void wilc_wfi_mgmt_tx_complete(void *priv, int status)
@@ -1100,12 +1297,16 @@ static void wilc_wfi_remain_on_channel_expired(void *data, u64 cookie)
 	struct wilc_priv *priv = &vif->priv;
 	struct wilc_wfi_p2p_listen_params *params = &priv->remain_on_ch_params;
 
-	if (cookie != params->listen_cookie)
+	if (cookie != priv->remain_on_ch_params.listen_cookie) {
+		PRINT_INFO(priv->dev, GENERIC_DBG,
+			   "Received cookies didn't match received[%llu] Expected[%llu]\n",
+			   cookie, priv->remain_on_ch_params.listen_cookie);
 		return;
+	}
 
-	priv->p2p_listen_state = false;
+	vif->p2p_listen_state = false;
 
-	cfg80211_remain_on_channel_expired(&priv->wdev, params->listen_cookie,
+	cfg80211_remain_on_channel_expired(&vif->priv.wdev, cookie,
 					   params->listen_ch, GFP_KERNEL);
 }
 
@@ -1120,7 +1321,7 @@ static int remain_on_channel(struct wiphy *wiphy,
 	u64 id;
 
 	if (wdev->iftype == NL80211_IFTYPE_AP) {
-		netdev_dbg(vif->ndev, "Required while in AP mode\n");
+		pr_err("Required while in AP mode\n");
 		return ret;
 	}
 
@@ -1135,17 +1336,23 @@ static int remain_on_channel(struct wiphy *wiphy,
 		return ret;
 
 	vif->wilc->op_ch = chan->hw_value;
-
 	priv->remain_on_ch_params.listen_ch = chan;
 	priv->remain_on_ch_params.listen_cookie = id;
 	*cookie = id;
-	priv->p2p_listen_state = true;
 	priv->remain_on_ch_params.listen_duration = duration;
-
+	vif->p2p_listen_state = true;
 	cfg80211_ready_on_channel(wdev, *cookie, chan, duration, GFP_KERNEL);
+
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+	vif->hif_drv->remain_on_ch_timer.data = (unsigned long)vif->hif_drv;
+#endif
 	mod_timer(&vif->hif_drv->remain_on_ch_timer,
-		  jiffies + msecs_to_jiffies(duration));
+		  jiffies + msecs_to_jiffies(duration + 1000));
 
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "Remaining on duration [%d] [%llu] op_ch[%d]\n",
+		   duration, priv->remain_on_ch_params.listen_cookie,
+		   vif->wilc->op_ch);
 	return ret;
 }
 
@@ -1156,150 +1363,133 @@ static int cancel_remain_on_channel(struct wiphy *wiphy,
 	struct wilc_vif *vif = netdev_priv(wdev->netdev);
 	struct wilc_priv *priv = &vif->priv;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "cookie received[%llu] expected[%llu]\n",
+		   cookie, priv->remain_on_ch_params.listen_cookie);
 	if (cookie != priv->remain_on_ch_params.listen_cookie)
 		return -ENOENT;
 
 	return wilc_listen_state_expired(vif, cookie);
 }
 
-static void wilc_wfi_cfg_tx_vendor_spec(struct wilc_priv *priv,
-					struct wilc_p2p_mgmt_data *mgmt_tx,
-					struct cfg80211_mgmt_tx_params *params,
-					u8 iftype, u32 buf_len)
-{
-	const u8 *buf = params->buf;
-	size_t len = params->len;
-	u32 i;
-	u8 subtype = buf[P2P_PUB_ACTION_SUBTYPE];
-	struct wilc_vif *vif = netdev_priv(priv->dev);
-
-	if (subtype == GO_NEG_REQ || subtype == GO_NEG_RSP) {
-		if (priv->p2p.local_random == 1 &&
-		    priv->p2p.recv_random < priv->p2p.local_random) {
-			get_random_bytes(&priv->p2p.local_random, 1);
-			priv->p2p.local_random++;
-		}
-	}
-
-	if (priv->p2p.local_random <= priv->p2p.recv_random ||
-	    !(subtype == GO_NEG_REQ || subtype == GO_NEG_RSP ||
-	      subtype == P2P_INV_REQ || subtype == P2P_INV_RSP))
-		return;
-
-	for (i = P2P_PUB_ACTION_SUBTYPE + 2; i < len; i++) {
-		if (buf[i] == P2PELEM_ATTR_ID &&
-		    !memcmp(p2p_oui, &buf[i + 2], 4)) {
-			bool oper_ch = false;
-			u8 *tx_buff = &mgmt_tx->buff[i + 6];
-
-			if (subtype == P2P_INV_REQ || subtype == P2P_INV_RSP)
-				oper_ch = true;
-
-			wilc_wfi_cfg_parse_tx_action(tx_buff, len - (i + 6),
-						     oper_ch, iftype,
-						     vif->wilc->sta_ch);
-
-			break;
-		}
-	}
-
-	if (subtype != P2P_INV_REQ && subtype != P2P_INV_RSP) {
-		int vendor_spec_len = sizeof(p2p_vendor_spec);
-
-		memcpy(&mgmt_tx->buff[len], p2p_vendor_spec,
-		       vendor_spec_len);
-		mgmt_tx->buff[len + vendor_spec_len] = priv->p2p.local_random;
-		mgmt_tx->size = buf_len;
-	}
-}
 
+#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
 static int mgmt_tx(struct wiphy *wiphy,
 		   struct wireless_dev *wdev,
 		   struct cfg80211_mgmt_tx_params *params,
 		   u64 *cookie)
+#else
+static int mgmt_tx(struct wiphy *wiphy,
+		   struct wireless_dev *wdev,
+		   struct ieee80211_channel *chan, bool offchan,
+		   unsigned int wait, const u8 *buf, size_t len,
+		   bool no_cck, bool dont_wait_for_ack, u64 *cookie)
+#endif
 {
+#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
 	struct ieee80211_channel *chan = params->chan;
 	unsigned int wait = params->wait;
 	const u8 *buf = params->buf;
 	size_t len = params->len;
+#endif
 	const struct ieee80211_mgmt *mgmt;
 	struct wilc_p2p_mgmt_data *mgmt_tx;
 	struct wilc_vif *vif = netdev_priv(wdev->netdev);
 	struct wilc_priv *priv = &vif->priv;
 	struct host_if_drv *wfi_drv = priv->hif_drv;
-	u32 buf_len = len + sizeof(p2p_vendor_spec) +
-			sizeof(priv->p2p.local_random);
+	struct wilc_vendor_specific_ie *p;
+	struct wilc_p2p_pub_act_frame *d;
+	int ie_offset = offsetof(struct ieee80211_mgmt, u) + sizeof(*d);
+	const u8 *vendor_ie;
 	int ret = 0;
 
 	*cookie = prandom_u32();
 	priv->tx_cookie = *cookie;
 	mgmt = (const struct ieee80211_mgmt *)buf;
 
-	if (!ieee80211_is_mgmt(mgmt->frame_control))
+	if (!ieee80211_is_mgmt(mgmt->frame_control)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "This function transmits only management frames\n");
 		goto out;
+	}
 
 	mgmt_tx = kmalloc(sizeof(*mgmt_tx), GFP_KERNEL);
 	if (!mgmt_tx) {
-		ret = -ENOMEM;
-		goto out;
+		PRINT_ER(vif->ndev,
+			 "Failed to allocate memory for mgmt_tx structure\n");
+		return -ENOMEM;
 	}
 
-	mgmt_tx->buff = kmalloc(buf_len, GFP_KERNEL);
+	mgmt_tx->buff = kmemdup(buf, len, GFP_KERNEL);
 	if (!mgmt_tx->buff) {
 		ret = -ENOMEM;
+		PRINT_ER(vif->ndev,
+			 "Failed to allocate memory for mgmt_tx buff\n");
 		kfree(mgmt_tx);
 		goto out;
 	}
 
-	memcpy(mgmt_tx->buff, buf, len);
 	mgmt_tx->size = len;
 
 	if (ieee80211_is_probe_resp(mgmt->frame_control)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "TX: Probe Response\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Setting channel: %d\n",
+			   chan->hw_value);
 		wilc_set_mac_chnl_num(vif, chan->hw_value);
 		vif->wilc->op_ch = chan->hw_value;
 		goto out_txq_add_pkt;
 	}
 
-	if (!ieee80211_is_action(mgmt->frame_control))
-		goto out_txq_add_pkt;
+	if (!ieee80211_is_public_action((struct ieee80211_hdr *)buf, len))
+		goto out_set_timeout;
 
-	if (buf[ACTION_CAT_ID] == PUB_ACTION_ATTR_ID) {
-		if (buf[ACTION_SUBTYPE_ID] != PUBLIC_ACT_VENDORSPEC ||
-		    buf[P2P_PUB_ACTION_SUBTYPE] != GO_NEG_CONF) {
-			wilc_set_mac_chnl_num(vif, chan->hw_value);
-			vif->wilc->op_ch = chan->hw_value;
-		}
-		switch (buf[ACTION_SUBTYPE_ID]) {
-		case GAS_INITIAL_REQ:
-		case GAS_INITIAL_RSP:
-			break;
-
-		case PUBLIC_ACT_VENDORSPEC:
-			if (!memcmp(p2p_oui, &buf[ACTION_SUBTYPE_ID + 1], 4))
-				wilc_wfi_cfg_tx_vendor_spec(priv, mgmt_tx,
-							    params, vif->iftype,
-							    buf_len);
-			else
-				netdev_dbg(vif->ndev,
-					   "Not a P2P public action frame\n");
-
-			break;
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "ACTION FRAME:%x\n",
+		   (u16)mgmt->frame_control);
 
-		default:
-			netdev_dbg(vif->ndev,
-				   "%s: Not handled action frame type:%x\n",
-				   __func__, buf[ACTION_SUBTYPE_ID]);
-			break;
-		}
+	d = (struct wilc_p2p_pub_act_frame *)(&mgmt->u.action);
+	if (d->oui_type != WLAN_OUI_TYPE_WFA_P2P ||
+	    d->oui_subtype != GO_NEG_CONF) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Setting channel: %d\n",
+			   chan->hw_value);
+		wilc_set_mac_chnl_num(vif, chan->hw_value);
+		vif->wilc->op_ch = chan->hw_value;
 	}
 
+	if (d->oui_subtype != GO_NEG_REQ && d->oui_subtype != GO_NEG_RSP &&
+		d->oui_subtype != P2P_INV_REQ && d->oui_subtype != P2P_INV_RSP)
+		goto out_set_timeout;
+
+	vendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,
+					    mgmt_tx->buff + ie_offset,
+					    len - ie_offset);
+	if (!vendor_ie)
+		goto out_set_timeout;
+
+	p = (struct wilc_vendor_specific_ie *)vendor_ie;
+	wilc_wfi_cfg_parse_p2p_intent_attr(p->attr, p->tag_len - 4,
+					   vif->wilc->attr_sysfs.p2p_mode);
+	/*
+	 * Update only the go_intent value and don't modify the channel list
+	 * attributes values for GO_REQ and GO_Response to retain
+	 * previous logic.  For mgmt_tx only INVITATION_REQ and INVITATION_RES
+	 * frame update the channel list attribute.
+	 */
+
+	if (d->oui_subtype == P2P_INV_REQ && d->oui_subtype == P2P_INV_RSP)
+		wilc_wfi_cfg_parse_p2p_attr(p->attr, p->tag_len - 4,
+					    vif->wilc->sta_ch);
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "TX: ACTION FRAME Type:%x : Chan:%d\n", d->action,
+		   chan->hw_value);
+out_set_timeout:
 	wfi_drv->p2p_timeout = (jiffies + msecs_to_jiffies(wait));
 
 out_txq_add_pkt:
-
-	wilc_wlan_txq_add_mgmt_pkt(wdev->netdev, mgmt_tx,
-				   mgmt_tx->buff, mgmt_tx->size,
-				   wilc_wfi_mgmt_tx_complete);
+	txq_add_mgmt_pkt(priv->wdev.netdev, mgmt_tx,
+			 mgmt_tx->buff, mgmt_tx->size,
+			 wilc_wfi_mgmt_tx_complete);
 
 out:
 
@@ -1316,7 +1506,7 @@ static int mgmt_tx_cancel_wait(struct wiphy *wiphy,
 
 	wfi_drv->p2p_timeout = jiffies;
 
-	if (!priv->p2p_listen_state) {
+	if (!vif->p2p_listen_state) {
 		struct wilc_wfi_p2p_listen_params *params;
 
 		params = &priv->remain_on_ch_params;
@@ -1339,6 +1529,9 @@ void wilc_mgmt_frame_register(struct wiphy *wiphy, struct wireless_dev *wdev,
 	if (!frame_type)
 		return;
 
+	PRINT_D(vif->ndev, GENERIC_DBG,
+		   "Frame registering Frame Type: %x: Boolean: %d\n",
+		   frame_type, reg);
 	switch (frame_type) {
 	case IEEE80211_STYPE_PROBE_REQ:
 		vif->frame_reg[0].type = frame_type;
@@ -1354,14 +1547,18 @@ void wilc_mgmt_frame_register(struct wiphy *wiphy, struct wireless_dev *wdev,
 		break;
 	}
 
-	if (!wl->initialized)
+	if (!wl->initialized) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Return since mac is closed\n");
 		return;
+	}
 	wilc_frame_register(vif, frame_type, reg);
 }
 
 static int set_cqm_rssi_config(struct wiphy *wiphy, struct net_device *dev,
 			       s32 rssi_thold, u32 rssi_hyst)
 {
+	PRINT_INFO(dev, CFG80211_DBG, "Setting CQM RSSi Function\n");
 	return 0;
 }
 
@@ -1374,13 +1571,18 @@ static int dump_station(struct wiphy *wiphy, struct net_device *dev,
 	if (idx != 0)
 		return -ENOENT;
 
-	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Dumping station information\n");
 
 	ret = wilc_get_rssi(vif, &sinfo->signal);
 	if (ret)
 		return ret;
 
-	memcpy(mac, vif->priv.associated_bss, ETH_ALEN);
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
+	sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
+#else
+	sinfo->filled |= STATION_INFO_SIGNAL;
+#endif
+
 	return 0;
 }
 
@@ -1390,29 +1592,45 @@ static int set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
 
-	if (!priv->hif_drv)
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "dev [%s]\n", dev->name);
+	if (!priv->hif_drv) {
+		PRINT_ER(dev, "hif driver is NULL\n");
 		return -EIO;
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   " Power save Enabled= %d , TimeOut = %d\n", enabled,
+		   timeout);
 
 	wilc_set_power_mgmt(vif, enabled, timeout);
 
 	return 0;
 }
 
+#if KERNEL_VERSION(4, 11, 0) <= LINUX_VERSION_CODE
 static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
 			       enum nl80211_iftype type,
 			       struct vif_params *params)
+#else
+static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
+			       enum nl80211_iftype type, u32 *flags,
+			       struct vif_params *params)
+#endif
 {
 	struct wilc *wl = wiphy_priv(wiphy);
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
 
-	priv->p2p.local_random = 0x01;
-	priv->p2p.recv_random = 0x00;
-	priv->p2p.is_wilc_ie = false;
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+		   "In Change virtual interface function\n");
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+		   "Wireless interface name =%s\n", dev->name);
 
 	switch (type) {
 	case NL80211_IFTYPE_STATION:
 		vif->connecting = false;
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_STATION\n");
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev.iftype = type;
 		vif->monitor_flag = 0;
@@ -1430,6 +1648,8 @@ static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
 
 	case NL80211_IFTYPE_P2P_CLIENT:
 		vif->connecting = false;
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_P2P_CLIENT\n");
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev.iftype = type;
 		vif->monitor_flag = 0;
@@ -1441,16 +1661,22 @@ static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
 		break;
 
 	case NL80211_IFTYPE_AP:
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_AP\n");
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev.iftype = type;
 		vif->iftype = WILC_AP_MODE;
 
 		if (wl->initialized)
 			wilc_set_operation_mode(vif, wilc_get_vif_idx(vif),
-						WILC_AP_MODE, vif->idx);
+						 WILC_AP_MODE, vif->idx);
 		break;
 
 	case NL80211_IFTYPE_P2P_GO:
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_GO\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "start duringIP timer\n");
+
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev.iftype = type;
 		vif->iftype = WILC_GO_MODE;
@@ -1459,9 +1685,22 @@ static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
 			wilc_set_operation_mode(vif, wilc_get_vif_idx(vif),
 						WILC_AP_MODE, vif->idx);
 		break;
+	case NL80211_IFTYPE_MONITOR:
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_MONITOR\n");
+		dev->ieee80211_ptr->iftype = type;
+		dev->type = ARPHRD_IEEE80211_RADIOTAP;
+		priv->wdev.iftype = type;
+		vif->iftype = WILC_MONITOR_MODE;
+
+		if (wl->initialized)
+			wilc_set_operation_mode(vif, wilc_get_vif_idx(vif),
+						 WILC_MONITOR_MODE,
+						 vif->idx);
+		break;
 
 	default:
-		netdev_err(dev, "Unknown interface type= %d\n", type);
+		PRINT_ER(dev, "Unknown interface type= %d\n", type);
 		return -EINVAL;
 	}
 
@@ -1471,17 +1710,28 @@ static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
 static int start_ap(struct wiphy *wiphy, struct net_device *dev,
 		    struct cfg80211_ap_settings *settings)
 {
-	struct wilc_vif *vif = netdev_priv(dev);
 	int ret;
+	struct wilc_vif *vif = netdev_priv(dev);
+	int freq = settings->chandef.chan->center_freq;
+	int channelnum = ieee80211_frequency_to_channel(freq);
+
+	pr_info("%s,dev[%s]\n", __func__, dev->name);
 
-	ret = set_channel(wiphy, &settings->chandef);
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG, "Starting ap\n");
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Interval= %d\n DTIM period= %d\n Head length= %d Tail length= %d channelnum[%d]\n",
+		   settings->beacon_interval, settings->dtim_period,
+		   settings->beacon.head_len, settings->beacon.tail_len,
+		   channelnum);
+	ret = wilc_set_mac_chnl_num(vif, channelnum);
 	if (ret != 0)
-		netdev_err(dev, "Error in setting channel\n");
+		PRINT_ER(dev, "Error in setting channel\n");
 
 	wilc_wlan_set_bssid(dev, dev->dev_addr, WILC_AP_MODE);
 
 	return wilc_add_beacon(vif, settings->beacon_interval,
-				   settings->dtim_period, &settings->beacon);
+			       settings->dtim_period, &settings->beacon);
 }
 
 static int change_beacon(struct wiphy *wiphy, struct net_device *dev,
@@ -1489,6 +1739,8 @@ static int change_beacon(struct wiphy *wiphy, struct net_device *dev,
 {
 	struct wilc_vif *vif = netdev_priv(dev);
 
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG, "Setting beacon\n");
+
 	return wilc_add_beacon(vif, 0, 0, beacon);
 }
 
@@ -1497,39 +1749,91 @@ static int stop_ap(struct wiphy *wiphy, struct net_device *dev)
 	int ret;
 	struct wilc_vif *vif = netdev_priv(dev);
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Deleting beacon\n");
+
 	wilc_wlan_set_bssid(dev, NULL, WILC_AP_MODE);
 
 	ret = wilc_del_beacon(vif);
 
 	if (ret)
-		netdev_err(dev, "Host delete beacon fail\n");
-
+		PRINT_ER(dev, "Host delete beacon fail\n");
 	return ret;
 }
 
+#if KERNEL_VERSION(3, 16, 0) <= LINUX_VERSION_CODE
 static int add_station(struct wiphy *wiphy, struct net_device *dev,
 		       const u8 *mac, struct station_parameters *params)
+#else
+static int add_station(struct wiphy *wiphy, struct net_device *dev,
+		       u8 *mac, struct station_parameters *params)
+#endif
 {
 	int ret = 0;
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
+	u8 *assoc_bss = priv->assoc_stainfo.sta_associated_bss[params->aid];
 
 	if (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {
-		memcpy(priv->assoc_stainfo.sta_associated_bss[params->aid], mac,
-		       ETH_ALEN);
+		memcpy(assoc_bss, mac, ETH_ALEN);
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Adding station parameters %d\n", params->aid);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+			   assoc_bss[0], assoc_bss[1], assoc_bss[2],
+			   assoc_bss[3], assoc_bss[4], assoc_bss[5]);
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG, "ASSOC ID = %d\n",
+			   params->aid);
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Number of supported rates = %d\n",
+			   params->supported_rates_len);
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "IS HT supported = %d\n",
+			   (!params->ht_capa) ? false : true);
+
+		if (params->ht_capa) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Capability Info = %d\n",
+				   params->ht_capa->cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "AMPDU Params = %d\n",
+				   params->ht_capa->ampdu_params_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "HT Extended params= %d\n",
+				   params->ht_capa->extended_ht_cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Tx Beamforming Cap= %d\n",
+				   params->ht_capa->tx_BF_cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Antenna selection info = %d\n",
+				   params->ht_capa->antenna_selection_info);
+		}
 
-		ret = wilc_add_station(vif, mac, params);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Mask = %d\n",
+			   params->sta_flags_mask);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Set = %d\n",
+			   params->sta_flags_set);
+		ret = wilc_add_station(vif, (const u8 *)mac, params);
 		if (ret)
-			netdev_err(dev, "Host add station fail\n");
+			PRINT_ER(dev, "Host add station fail\n");
 	}
 
 	return ret;
 }
 
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
 static int del_station(struct wiphy *wiphy, struct net_device *dev,
 		       struct station_del_parameters *params)
+#elif KERNEL_VERSION(3, 16, 0) <= LINUX_VERSION_CODE
+static int del_station(struct wiphy *wiphy, struct net_device *dev,
+		       const u8 *mac)
+#else
+static int del_station(struct wiphy *wiphy, struct net_device *dev,
+		       u8 *mac)
+#endif
 {
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
 	const u8 *mac = params->mac;
+#endif
 	int ret = 0;
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
@@ -1538,90 +1842,175 @@ static int del_station(struct wiphy *wiphy, struct net_device *dev,
 	if (!(vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE))
 		return ret;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Deleting station\n");
+
 	info = &priv->assoc_stainfo;
 
-	if (!mac)
+	if (!mac) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "All associated stations\n");
 		ret = wilc_del_allstation(vif, info->sta_associated_bss);
+	} else {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "With mac address: %x%x%x%x%x%x\n",
+			   mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+	}
 
 	ret = wilc_del_station(vif, mac);
 	if (ret)
-		netdev_err(dev, "Host delete station fail\n");
+		PRINT_ER(dev, "Host delete station fail\n");
+
 	return ret;
 }
 
+#if KERNEL_VERSION(3, 16, 0) <= LINUX_VERSION_CODE
 static int change_station(struct wiphy *wiphy, struct net_device *dev,
 			  const u8 *mac, struct station_parameters *params)
+#else
+static int change_station(struct wiphy *wiphy, struct net_device *dev,
+			  u8 *mac, struct station_parameters *params)
+#endif
 {
 	int ret = 0;
 	struct wilc_vif *vif = netdev_priv(dev);
 
+	PRINT_D(vif->ndev, CFG80211_DBG, "Change station paramters\n");
+
 	if (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {
-		ret = wilc_edit_station(vif, mac, params);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+			  mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "ASSOC ID = %d\n",
+			   params->aid);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Number of supported rates = %d\n",
+			   params->supported_rates_len);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "IS HT supported = %d\n",
+			   (!params->ht_capa) ? false : true);
+		if (params->ht_capa) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Capability Info = %d\n",
+				   params->ht_capa->cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "AMPDU Params = %d\n",
+				   params->ht_capa->ampdu_params_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "HT Extended params= %d\n",
+				   params->ht_capa->extended_ht_cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Tx Beamforming Cap= %d\n",
+				   params->ht_capa->tx_BF_cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Antenna selection info = %d\n",
+				   params->ht_capa->antenna_selection_info);
+		}
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Mask = %d\n",
+			   params->sta_flags_mask);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Set = %d\n",
+			   params->sta_flags_set);
+		ret = wilc_edit_station(vif, (const u8 *)mac, params);
 		if (ret)
-			netdev_err(dev, "Host edit station fail\n");
+			PRINT_ER(dev, "Host edit station fail\n");
 	}
 	return ret;
 }
 
-static int wilc_get_vif_from_type(struct wilc *wl, int type)
+struct wilc_vif *wilc_get_vif_from_type(struct wilc *wl, int type)
 {
-	int i;
+	struct wilc_vif *vif;
 
-	mutex_lock(&wl->vif_mutex);
-	for (i = 0; i < wl->vif_num; i++) {
-		if (wl->vif[i]->iftype == type) {
-			mutex_unlock(&wl->vif_mutex);
-			return i;
-		}
+	list_for_each_entry_rcu(vif, &wl->vif_list, list) {
+		if (vif->iftype == type)
+			return vif;
 	}
-	mutex_unlock(&wl->vif_mutex);
-
-	return -EINVAL;
+	return NULL;
 }
 
+#if KERNEL_VERSION(4, 12, 0) <= LINUX_VERSION_CODE
 static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
 					     const char *name,
 					     unsigned char name_assign_type,
 					     enum nl80211_iftype type,
 					     struct vif_params *params)
+#elif KERNEL_VERSION(4, 1, 0) <= LINUX_VERSION_CODE
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     const char *name,
+					     unsigned char name_assign_type,
+					     enum nl80211_iftype type,
+					     u32 *flags,
+					     struct vif_params *params)
+#elif KERNEL_VERSION(3, 7, 0) <= LINUX_VERSION_CODE
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     const char *name,
+					     enum nl80211_iftype type,
+					     u32 *flags,
+					     struct vif_params *params)
+#else
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     char *name,
+					     enum nl80211_iftype type,
+					     u32 *flags,
+					     struct vif_params *params)
+#endif
 {
 	struct wilc *wl = wiphy_priv(wiphy);
 	struct wilc_vif *vif;
 	struct wireless_dev *wdev;
-	int iftype;
-	int ret;
+	u8 iftype;
 
+	/* check if interface type is mointor because AP mode is supported over
+	 * monitor interface. No need to increment interface count check if
+	 * monitor mode is associated with AP interface. The same approach is
+	 * applied with p2p_device interface
+	 */
 	if (type == NL80211_IFTYPE_MONITOR) {
+		struct wilc_vif *vif;
 		struct net_device *ndev;
-		int ap_index = wilc_get_vif_from_type(wl, WILC_AP_MODE);
+		int srcu_idx;
 
-		if (ap_index < 0) {
-			ap_index = wilc_get_vif_from_type(wl, WILC_GO_MODE);
-			if (ap_index < 0)
+		srcu_idx = srcu_read_lock(&wl->srcu);
+		vif = wilc_get_vif_from_type(wl, WILC_AP_MODE);
+
+		if (!vif) {
+			vif = wilc_get_vif_from_type(wl, WILC_GO_MODE);
+			if (!vif) {
+				srcu_read_unlock(&wl->srcu, srcu_idx);
 				goto validate_interface;
+			}
 		}
 
-		vif  = wl->vif[ap_index];
-		if (vif->monitor_flag)
+		if (vif->monitor_flag) {
+			srcu_read_unlock(&wl->srcu, srcu_idx);
 			goto validate_interface;
-
-		ndev = wilc_wfi_init_mon_interface(wl, name, vif->ndev);
-		if (ndev)
+		}
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Initializing mon ifc virtual device driver\n");
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Adding monitor interface[%p]\n", vif->ndev);
+		ndev = wilc_wfi_init_mon_interface(vif->wilc, name, vif->ndev);
+		if (ndev) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+			"Setting monitor flag in private structure\n");
 			vif->monitor_flag = 1;
-		else
-			return ERR_PTR(-EINVAL);
-
+		} else {
+			PRINT_ER(vif->ndev,
+				 "Error in initializing monitor interface\n");
+		}
 		wdev = &vif->priv.wdev;
+		srcu_read_unlock(&wl->srcu, srcu_idx);
 		return wdev;
 	}
 
 validate_interface:
 	mutex_lock(&wl->vif_mutex);
 	if (wl->vif_num == WILC_NUM_CONCURRENT_IFC) {
-		pr_err("Reached maximum number of interface\n");
-		ret = -EINVAL;
-		goto out_err;
+		pr_err("Reached maximum number of supported vif\n");
+		mutex_unlock(&wl->vif_mutex);
+		return ERR_PTR(-EINVAL);
 	}
+	mutex_unlock(&wl->vif_mutex);
+
+	pr_info("add_interaface [%d] name[%s] type[%d]\n", wl->vif_num,
+	       name, type);
 
 	switch (type) {
 	case NL80211_IFTYPE_STATION:
@@ -1630,68 +2019,50 @@ static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
 	case NL80211_IFTYPE_AP:
 		iftype = WILC_AP_MODE;
 		break;
+	case NL80211_IFTYPE_MONITOR:
+		iftype = WILC_MONITOR_MODE;
+		break;
 	default:
-		ret = -EOPNOTSUPP;
-		goto out_err;
+		return ERR_PTR(-EINVAL);
 	}
 
 	vif = wilc_netdev_ifc_init(wl, name, iftype, type, true);
-	if (IS_ERR(vif)) {
-		ret = PTR_ERR(vif);
-		goto out_err;
-	}
-
-	mutex_unlock(&wl->vif_mutex);
+	if (IS_ERR(vif))
+		return ERR_PTR(-EINVAL);
 
 	return &vif->priv.wdev;
-
-out_err:
-	mutex_unlock(&wl->vif_mutex);
-	return ERR_PTR(ret);
 }
 
 static int del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)
 {
 	struct wilc *wl = wiphy_priv(wiphy);
 	struct wilc_vif *vif;
-	int i;
 
+	/* delete the monitor mode interface */
+	if (wdev->iftype == NL80211_IFTYPE_MONITOR) {
+		wilc_wfi_deinit_mon_interface(wl, true);
+		return 0;
+	}
+	/* delete the AP monitor mode interface */
 	if (wdev->iftype == NL80211_IFTYPE_AP ||
 	    wdev->iftype == NL80211_IFTYPE_P2P_GO)
 		wilc_wfi_deinit_mon_interface(wl, true);
 	vif = netdev_priv(wdev->netdev);
-	cfg80211_stop_iface(wiphy, wdev, GFP_KERNEL);
 	unregister_netdevice(vif->ndev);
 	vif->monitor_flag = 0;
 
+	/* update the vif list */
 	mutex_lock(&wl->vif_mutex);
-	wilc_set_operation_mode(vif, 0, 0, 0);
-	for (i = vif->idx; i < wl->vif_num; i++) {
-		if ((i + 1) >= wl->vif_num) {
-			wl->vif[i] = NULL;
-		} else {
-			vif = wl->vif[i + 1];
-			vif->idx = i;
-			wl->vif[i] = vif;
-			wilc_set_operation_mode(vif, wilc_get_vif_idx(vif),
-						vif->iftype, vif->idx);
-		}
-	}
+	/* delete the interface from rcu list */
+	list_del_rcu(&vif->list);
 	wl->vif_num--;
 	mutex_unlock(&wl->vif_mutex);
-
+	synchronize_srcu(&wl->srcu);
 	return 0;
 }
 
 static int wilc_suspend(struct wiphy *wiphy, struct cfg80211_wowlan *wow)
 {
-	struct wilc *wl = wiphy_priv(wiphy);
-
-	if (!wow && wilc_wlan_get_num_conn_ifcs(wl))
-		wl->suspend_event = true;
-	else
-		wl->suspend_event = false;
-
 	return 0;
 }
 
@@ -1704,32 +2075,49 @@ static void wilc_set_wakeup(struct wiphy *wiphy, bool enabled)
 {
 	struct wilc *wl = wiphy_priv(wiphy);
 	struct wilc_vif *vif;
+	int srcu_idx;
 
-	mutex_lock(&wl->vif_mutex);
+	srcu_idx = srcu_read_lock(&wl->srcu);
 	vif = wilc_get_wl_to_vif(wl);
 	if (IS_ERR(vif)) {
-		mutex_unlock(&wl->vif_mutex);
+		srcu_read_unlock(&wl->srcu, srcu_idx);
 		return;
 	}
 
-	netdev_info(vif->ndev, "cfg set wake up = %d\n", enabled);
-	mutex_unlock(&wl->vif_mutex);
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "cfg set wake up = %d\n", enabled);
+	wilc_set_wowlan_trigger(vif, (u8)enabled);
+	srcu_read_unlock(&wl->srcu, srcu_idx);
 }
 
 static int set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,
 			enum nl80211_tx_power_setting type, int mbm)
 {
 	int ret;
+	int srcu_idx;
 	s32 tx_power = MBM_TO_DBM(mbm);
-	struct wilc_vif *vif = netdev_priv(wdev->netdev);
+	struct wilc *wl = wiphy_priv(wiphy);
+	struct wilc_vif *vif;
 
+	if (!wl->initialized)
+		return -EIO;
+
+	srcu_idx = srcu_read_lock(&wl->srcu);
+	vif = wilc_get_wl_to_vif(wl);
+	if (IS_ERR(vif)) {
+		srcu_read_unlock(&wl->srcu, srcu_idx);
+		return -EINVAL;
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting tx power %d\n", tx_power);
 	if (tx_power < 0)
 		tx_power = 0;
 	else if (tx_power > 18)
 		tx_power = 18;
 	ret = wilc_set_tx_power(vif, tx_power);
 	if (ret)
-		netdev_err(vif->ndev, "Failed to set tx power\n");
+		PRINT_ER(vif->ndev, "Failed to set tx power\n");
+
+	srcu_read_unlock(&wl->srcu, srcu_idx);
 
 	return ret;
 }
@@ -1744,10 +2132,40 @@ static int get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,
 	/* If firmware is not started, return. */
 	if (!wl->initialized)
 		return -EIO;
-
+	*dbm = 0;
 	ret = wilc_get_tx_power(vif, (u8 *)dbm);
 	if (ret)
-		netdev_err(vif->ndev, "Failed to get tx power\n");
+		PRINT_ER(vif->ndev, "Failed to get tx power\n");
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Got tx power %d\n", *dbm);
+
+	return ret;
+}
+
+static int set_antenna(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant)
+{
+	int ret;
+	struct wilc *wl = wiphy_priv(wiphy);
+	struct wilc_vif *vif;
+	int srcu_idx;
+
+	srcu_idx = srcu_read_lock(&wl->srcu);
+	vif = wilc_get_wl_to_vif(wl);
+	if (IS_ERR(vif)) {
+		srcu_read_unlock(&wl->srcu, srcu_idx);
+		return -EINVAL;
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Select antenna mode %d\n", tx_ant);
+	if (!tx_ant || !rx_ant) {
+		srcu_read_unlock(&wl->srcu, srcu_idx);
+		return -EINVAL;
+	}
+
+	ret = wilc_set_antenna(vif, (u8)(tx_ant-1));
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set tx antenna\n");
+	srcu_read_unlock(&wl->srcu, srcu_idx);
 
 	return ret;
 }
@@ -1792,75 +2210,103 @@ static const struct cfg80211_ops wilc_cfg80211_ops = {
 	.set_wakeup = wilc_set_wakeup,
 	.set_tx_power = set_tx_power,
 	.get_tx_power = get_tx_power,
-
+	.set_antenna = set_antenna,
 };
 
 static void wlan_init_locks(struct wilc *wl)
 {
-	mutex_init(&wl->hif_cs);
+	pr_info("Initializing Locks ...\n");
+	mutex_init(&wl->vif_mutex);
 	mutex_init(&wl->rxq_cs);
 	mutex_init(&wl->cfg_cmd_lock);
-	mutex_init(&wl->vif_mutex);
+	mutex_init(&wl->deinit_lock);
+	mutex_init(&wl->hif_cs);
+	mutex_init(&wl->cs);
 
 	spin_lock_init(&wl->txq_spinlock);
 	mutex_init(&wl->txq_add_to_head_cs);
 
 	init_completion(&wl->txq_event);
+
 	init_completion(&wl->cfg_event);
 	init_completion(&wl->sync_event);
 	init_completion(&wl->txq_thread_started);
+	init_completion(&wl->debug_thread_started);
+	init_srcu_struct(&wl->srcu);
+}
+
+void wlan_deinit_locks(struct wilc *wl)
+{
+	pr_info("De-Initializing Locks\n");
+	mutex_destroy(&wl->hif_cs);
+	mutex_destroy(&wl->rxq_cs);
+	mutex_destroy(&wl->cfg_cmd_lock);
+	mutex_destroy(&wl->vif_mutex);
+	mutex_destroy(&wl->txq_add_to_head_cs);
+	mutex_destroy(&wl->cs);
+	mutex_destroy(&wl->deinit_lock);
+	cleanup_srcu_struct(&wl->srcu);
 }
 
 int wilc_cfg80211_init(struct wilc **wilc, struct device *dev, int io_type,
 		       const struct wilc_hif_func *ops)
 {
+	int i, ret;
 	struct wilc *wl;
 	struct wilc_vif *vif;
-	int ret;
 
 	wl = wilc_create_wiphy(dev);
-	if (!wl)
+	if (!wl) {
+		pr_err("failed to create wiphy\n");
 		return -EINVAL;
+	}
+
+	wlan_init_locks(wl);
 
-	ret = wilc_wlan_cfg_init(wl);
+	ret = cfg_init(wl);
 	if (ret)
 		goto free_wl;
 
+#ifdef WILC_DEBUGFS
+	wilc_debugfs_init();
+#endif
 	*wilc = wl;
 	wl->io_type = io_type;
 	wl->hif_func = ops;
-	wl->chip_ps_state = WILC_CHIP_WAKEDUP;
-	INIT_LIST_HEAD(&wl->txq_head.list);
+	for (i = 0; i < NQUEUES; i++)
+		INIT_LIST_HEAD(&wl->txq[i].txq_head.list);
+
 	INIT_LIST_HEAD(&wl->rxq_head.list);
+	INIT_LIST_HEAD(&wl->vif_list);
 
 	wl->hif_workqueue = create_singlethread_workqueue("WILC_wq");
 	if (!wl->hif_workqueue) {
 		ret = -ENOMEM;
-		goto free_cfg;
+		goto free_debug_fs;
 	}
 	vif = wilc_netdev_ifc_init(wl, "wlan%d", WILC_STATION_MODE,
 				   NL80211_IFTYPE_STATION, false);
 	if (IS_ERR(vif)) {
 		ret = PTR_ERR(vif);
-		goto free_hq;
+		goto free_wq;
 	}
 
-	wlan_init_locks(wl);
+	wilc_sysfs_init(wl);
 
 	return 0;
-
-free_hq:
+free_wq:
 	destroy_workqueue(wl->hif_workqueue);
-
-free_cfg:
-	wilc_wlan_cfg_deinit(wl);
-
+free_debug_fs:
+#ifdef WILC_DEBUGFS
+	wilc_debugfs_remove();
+#endif
+	cfg_deinit(wl);
 free_wl:
+	wlan_deinit_locks(wl);
 	wiphy_unregister(wl->wiphy);
 	wiphy_free(wl->wiphy);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(wilc_cfg80211_init);
 
 struct wilc *wilc_create_wiphy(struct device *dev)
 {
@@ -1868,11 +2314,14 @@ struct wilc *wilc_create_wiphy(struct device *dev)
 	struct wilc *wl;
 	int ret;
 
-	wiphy = wiphy_new(&wilc_cfg80211_ops, sizeof(*wl));
-	if (!wiphy)
-		return NULL;
+	wiphy = wiphy_new(&wilc_cfg80211_ops, sizeof(struct wilc));
+	if (!wiphy) {
+		pr_err("wiphy new allocate failed\n");
+		return ERR_PTR(-EFAULT);
+	}
 
 	wl = wiphy_priv(wiphy);
+	pr_info("Registering wifi device\n");
 
 	memcpy(wl->bitrates, wilc_bitrates, sizeof(wilc_bitrates));
 	memcpy(wl->channels, wilc_2ghz_channels, sizeof(wilc_2ghz_channels));
@@ -1887,11 +2336,19 @@ struct wilc *wilc_create_wiphy(struct device *dev)
 	wl->band.ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_8K;
 	wl->band.ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;
 
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
 	wiphy->bands[NL80211_BAND_2GHZ] = &wl->band;
+#else
+	wiphy->bands[IEEE80211_BAND_2GHZ] = &wl->band;
+#endif
 
 	wiphy->max_scan_ssids = WILC_MAX_NUM_PROBED_SSID;
 #ifdef CONFIG_PM
+#if KERNEL_VERSION(3, 11, 0) <= LINUX_VERSION_CODE
 	wiphy->wowlan = &wowlan_support;
+#else
+	wiphy->wowlan = wowlan_support;
+#endif
 #endif
 	wiphy->max_num_pmkids = WILC_MAX_NUM_PMKIDS;
 	wiphy->max_scan_ie_len = 1000;
@@ -1900,22 +2357,28 @@ struct wilc *wilc_create_wiphy(struct device *dev)
 	       sizeof(wilc_cipher_suites));
 	wiphy->cipher_suites = wl->cipher_suites;
 	wiphy->n_cipher_suites = ARRAY_SIZE(wilc_cipher_suites);
+	wiphy->available_antennas_tx = 0x3;
+	wiphy->available_antennas_rx = 0x3;
 	wiphy->mgmt_stypes = wilc_wfi_cfg80211_mgmt_types;
 
 	wiphy->max_remain_on_channel_duration = 500;
 	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
-				BIT(NL80211_IFTYPE_AP) |
-				BIT(NL80211_IFTYPE_MONITOR) |
-				BIT(NL80211_IFTYPE_P2P_GO) |
-				BIT(NL80211_IFTYPE_P2P_CLIENT);
+					BIT(NL80211_IFTYPE_AP) |
+					BIT(NL80211_IFTYPE_MONITOR) |
+					BIT(NL80211_IFTYPE_P2P_GO) |
+					BIT(NL80211_IFTYPE_P2P_CLIENT);
 	wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+	pr_info("Max scan ids= %d,Max scan IE len= %d,Signal Type= %d,Interface Modes= %d\n",
+		wiphy->max_scan_ssids, wiphy->max_scan_ie_len,
+		wiphy->signal_type, wiphy->interface_modes);
 
 	set_wiphy_dev(wiphy, dev);
 	wl->wiphy = wiphy;
 	ret = wiphy_register(wiphy);
 	if (ret) {
+		pr_err("Cannot register wiphy device\n");
 		wiphy_free(wiphy);
-		return NULL;
+		return ERR_PTR(-EFAULT);
 	}
 	return wl;
 }
@@ -1926,12 +2389,20 @@ int wilc_init_host_int(struct net_device *net)
 	struct wilc_vif *vif = netdev_priv(net);
 	struct wilc_priv *priv = &vif->priv;
 
-	priv->p2p_listen_state = false;
+	PRINT_INFO(net, INIT_DBG, "Host[%p][%p]\n", net, net->ieee80211_ptr);
+
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	timer_setup(&priv->eap_buff_timer, eap_buff_timeout, 0);
+#else
+	setup_timer(&priv->eap_buff_timer, eap_buff_timeout, 0);
+#endif
+
+	vif->p2p_listen_state = false;
 
 	mutex_init(&priv->scan_req_lock);
 	ret = wilc_init(net, &priv->hif_drv);
 	if (ret)
-		netdev_err(net, "Error while initializing hostinterface\n");
+		PRINT_ER(net, "Error while initializing hostinterface\n");
 
 	return ret;
 }
@@ -1942,13 +2413,14 @@ void wilc_deinit_host_int(struct net_device *net)
 	struct wilc_vif *vif = netdev_priv(net);
 	struct wilc_priv *priv = &vif->priv;
 
-	priv->p2p_listen_state = false;
+	vif->p2p_listen_state = false;
 
 	flush_workqueue(vif->wilc->hif_workqueue);
 	mutex_destroy(&priv->scan_req_lock);
 	ret = wilc_deinit(vif);
 
+	del_timer_sync(&priv->eap_buff_timer);
+
 	if (ret)
-		netdev_err(net, "Error while deinitializing host interface\n");
+		PRINT_ER(net, "Error while deinitializing host interface\n");
 }
-
diff --git a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.h b/drivers/staging/wilc1000/cfg80211.h
similarity index 73%
rename from drivers/staging/wilc1000/wilc_wfi_cfgoperations.h
rename to drivers/staging/wilc1000/cfg80211.h
index 234faaabd..24c5f6881 100644
--- a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.h
+++ b/drivers/staging/wilc1000/cfg80211.h
@@ -4,24 +4,25 @@
  * All rights reserved.
  */
 
-#ifndef NM_WFI_CFGOPERATIONS
-#define NM_WFI_CFGOPERATIONS
-#include "wilc_wfi_netdevice.h"
+#ifndef WILC_CFG80211_H
+#define WILC_CFG80211_H
+#include "netdev.h"
 
-struct wiphy *wilc_cfg_alloc(void);
-int wilc_cfg80211_init(struct wilc **wilc, struct device *dev, int io_type,
-		       const struct wilc_hif_func *ops);
 struct wilc *wilc_create_wiphy(struct device *dev);
 void wilc_deinit_host_int(struct net_device *net);
 int wilc_init_host_int(struct net_device *net);
 void wilc_wfi_monitor_rx(struct net_device *mon_dev, u8 *buff, u32 size);
-struct wilc_vif *wilc_netdev_interface(struct wilc *wl, const char *name,
-				       enum nl80211_iftype type);
 void wilc_wfi_deinit_mon_interface(struct wilc *wl, bool rtnl_locked);
 struct net_device *wilc_wfi_init_mon_interface(struct wilc *wl,
 					       const char *name,
 					       struct net_device *real_dev);
 void wilc_mgmt_frame_register(struct wiphy *wiphy, struct wireless_dev *wdev,
 			      u16 frame_type, bool reg);
-struct wilc_vif *wilc_get_interface(struct wilc *wl);
+void wilc_sysfs_init(struct wilc *wilc);
+void wilc_sysfs_exit(void);
+int wilc_cfg80211_init(struct wilc **wilc, struct device *dev, int io_type,
+		       const struct wilc_hif_func *ops);
+struct wilc_vif *wilc_get_vif_from_type(struct wilc *wl, int type);
+struct wilc_vif *wilc_get_wl_to_vif(struct wilc *wl);
+void wlan_deinit_locks(struct wilc *wl);
 #endif
diff --git a/drivers/staging/wilc1000/debugfs.c b/drivers/staging/wilc1000/debugfs.c
new file mode 100644
index 000000000..132066f3a
--- /dev/null
+++ b/drivers/staging/wilc1000/debugfs.c
@@ -0,0 +1,426 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/module.h>
+#include <linux/debugfs.h>
+
+#include "debugfs.h"
+
+atomic_t WILC_DEBUG_REGION = ATOMIC_INIT(INIT_DBG | GENERIC_DBG |
+					 CFG80211_DBG | HOSTAPD_DBG |
+					 PWRDEV_DBG);
+#if KERNEL_VERSION(3, 15, 0) > LINUX_VERSION_CODE
+/**
+ * of_irq_parse_raw - Low level interrupt tree parsing
+ * @parent:	the device interrupt parent
+ * @addr:	address specifier (start of "reg" property of the device)
+ *              in be32 format
+ * @out_irq:	structure of_irq updated by this function
+ *
+ * Returns 0 on success and a negative number on error
+ *
+ * This function is a low-level interrupt tree walking function. It
+ * can be used to do a partial walk with synthetized reg and interrupts
+ * properties, for example when resolving PCI interrupts when no device
+ * node exist for the parent. It takes an interrupt specifier structure as
+ * input, walks the tree looking for any interrupt-map properties, translates
+ * the specifier for each map, and then returns the translated map.
+ */
+int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
+{
+	struct device_node *ipar, *tnode, *old = NULL, *newpar = NULL;
+	__be32 initial_match_array[MAX_PHANDLE_ARGS];
+	const __be32 *match_array = initial_match_array;
+	const __be32 *tmp, *imap, *imask;
+	const __be32 dummy_imask[] = { [0 ... MAX_PHANDLE_ARGS] = ~0 };
+	u32 intsize = 1, addrsize, newintsize = 0, newaddrsize = 0;
+	int imaplen, match, i;
+
+#ifdef DEBUG
+	of_print_phandle_args("of_irq_parse_raw: ", out_irq);
+#endif
+
+	ipar = of_node_get(out_irq->np);
+
+	/* First get the #interrupt-cells property of the current cursor
+	 * that tells us how to interpret the passed-in intspec. If there
+	 * is none, we are nice and just walk up the tree
+	 */
+	do {
+		tmp = of_get_property(ipar, "#interrupt-cells", NULL);
+		if (tmp != NULL) {
+			intsize = be32_to_cpu(*tmp);
+			break;
+		}
+		tnode = ipar;
+		ipar = of_irq_find_parent(ipar);
+		of_node_put(tnode);
+	} while (ipar);
+	if (ipar == NULL) {
+		pr_debug(" -> no parent found !\n");
+		goto fail;
+	}
+
+	pr_debug("of_irq_parse_raw: ipar=%s, size=%d\n",
+		 of_node_full_name(ipar), intsize);
+
+	if (out_irq->args_count != intsize)
+		return -EINVAL;
+
+	/* Look for this #address-cells. We have to implement the old linux
+	 * trick of looking for the parent here as some device-trees rely on it
+	 */
+	old = of_node_get(ipar);
+	do {
+		tmp = of_get_property(old, "#address-cells", NULL);
+		tnode = of_get_parent(old);
+		of_node_put(old);
+		old = tnode;
+	} while (old && tmp == NULL);
+	of_node_put(old);
+	old = NULL;
+	addrsize = (tmp == NULL) ? 2 : be32_to_cpu(*tmp);
+
+	pr_debug(" -> addrsize=%d\n", addrsize);
+
+	/* Range check so that the temporary buffer doesn't overflow */
+	if (WARN_ON(addrsize + intsize > MAX_PHANDLE_ARGS))
+		goto fail;
+
+	/* Precalculate the match array - this simplifies match loop */
+	for (i = 0; i < addrsize; i++)
+		initial_match_array[i] = addr ? addr[i] : 0;
+	for (i = 0; i < intsize; i++)
+		initial_match_array[addrsize + i] =
+			cpu_to_be32(out_irq->args[i]);
+
+	/* Now start the actual "proper" walk of the interrupt tree */
+	while (ipar != NULL) {
+		/* Now check if cursor is an interrupt-controller and if it is
+		 * then we are done
+		 */
+		if (of_get_property(ipar, "interrupt-controller", NULL) !=
+				NULL) {
+			pr_debug(" -> got it !\n");
+			return 0;
+		}
+
+		/*
+		 * interrupt-map parsing does not work without a reg
+		 * property when #address-cells != 0
+		 */
+		if (addrsize && !addr) {
+			pr_debug(" -> no reg passed in when needed !\n");
+			goto fail;
+		}
+
+		/* Now look for an interrupt-map */
+		imap = of_get_property(ipar, "interrupt-map", &imaplen);
+		/* No interrupt map, check for an interrupt parent */
+		if (imap == NULL) {
+			pr_debug(" -> no map, getting parent\n");
+			newpar = of_irq_find_parent(ipar);
+			goto skiplevel;
+		}
+		imaplen /= sizeof(u32);
+
+		/* Look for a mask */
+		imask = of_get_property(ipar, "interrupt-map-mask", NULL);
+		if (!imask)
+			imask = dummy_imask;
+
+		/* Parse interrupt-map */
+		match = 0;
+		while (imaplen > (addrsize + intsize + 1) && !match) {
+			/* Compare specifiers */
+			match = 1;
+			for (i = 0; i < (addrsize + intsize); i++, imaplen--)
+				match &= !((match_array[i] ^ *imap++) &
+					   imask[i]);
+
+			pr_debug(" -> match=%d (imaplen=%d)\n", match, imaplen);
+
+			/* Get the interrupt parent */
+			if (of_irq_workarounds & OF_IMAP_NO_PHANDLE)
+				newpar = of_node_get(of_irq_dflt_pic);
+			else
+				newpar =
+				of_find_node_by_phandle(be32_to_cpup(imap));
+			imap++;
+			--imaplen;
+
+			/* Check if not found */
+			if (newpar == NULL) {
+				pr_debug(" -> imap parent not found !\n");
+				goto fail;
+			}
+
+			if (!of_device_is_available(newpar))
+				match = 0;
+
+			/* Get #interrupt-cells and #address-cells of new
+			 * parent
+			 */
+			tmp = of_get_property(newpar, "#interrupt-cells", NULL);
+			if (tmp == NULL) {
+				pr_debug(" -> parent lacks #interrupt-cells!\n");
+				goto fail;
+			}
+			newintsize = be32_to_cpu(*tmp);
+			tmp = of_get_property(newpar, "#address-cells", NULL);
+			newaddrsize = (tmp == NULL) ? 0 : be32_to_cpu(*tmp);
+
+			pr_debug(" -> newintsize=%d, newaddrsize=%d\n",
+			    newintsize, newaddrsize);
+
+			/* Check for malformed properties */
+			if (WARN_ON(newaddrsize + newintsize >
+				    MAX_PHANDLE_ARGS))
+				goto fail;
+			if (imaplen < (newaddrsize + newintsize))
+				goto fail;
+
+			imap += newaddrsize + newintsize;
+			imaplen -= newaddrsize + newintsize;
+
+			pr_debug(" -> imaplen=%d\n", imaplen);
+		}
+		if (!match)
+			goto fail;
+
+		/*
+		 * Successfully parsed an interrrupt-map translation; copy new
+		 * interrupt specifier into the out_irq structure
+		 */
+		out_irq->np = newpar;
+
+		match_array = imap - newaddrsize - newintsize;
+		for (i = 0; i < newintsize; i++)
+			out_irq->args[i] = be32_to_cpup(imap - newintsize + i);
+		out_irq->args_count = intsize = newintsize;
+		addrsize = newaddrsize;
+
+skiplevel:
+		/* Iterate again with new parent */
+		pr_debug(" -> new parent: %s\n", of_node_full_name(newpar));
+		of_node_put(ipar);
+		ipar = newpar;
+		newpar = NULL;
+	}
+ fail:
+	of_node_put(ipar);
+	of_node_put(newpar);
+
+	return -EINVAL;
+}
+
+static inline int of_irq_parse_oldworld(struct device_node *device, int index,
+				      struct of_phandle_args *out_irq)
+{
+	return -EINVAL;
+}
+/**
+ * of_irq_parse_one - Resolve an interrupt for a device
+ * @device: the device whose interrupt is to be resolved
+ * @index: index of the interrupt to resolve
+ * @out_irq: structure of_irq filled by this function
+ *
+ * This function resolves an interrupt for a node by walking the interrupt tree,
+ * finding which interrupt controller node it is attached to, and returning the
+ * interrupt specifier that can be used to retrieve a Linux IRQ number.
+ */
+int of_irq_parse_one(struct device_node *device, int index,
+		     struct of_phandle_args *out_irq)
+{
+	struct device_node *p;
+	const __be32 *intspec, *tmp, *addr;
+	u32 intsize, intlen;
+	int i, res;
+
+	pr_debug("of_irq_parse_one: dev=%s, index=%d\n",
+		 of_node_full_name(device), index);
+
+	/* OldWorld mac stuff is "special", handle out of line */
+	if (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)
+		return of_irq_parse_oldworld(device, index, out_irq);
+
+	/* Get the reg property (if any) */
+	addr = of_get_property(device, "reg", NULL);
+
+	/* Try the new-style interrupts-extended first */
+	res = of_parse_phandle_with_args(device, "interrupts-extended",
+					"#interrupt-cells", index, out_irq);
+	if (!res)
+		return of_irq_parse_raw(addr, out_irq);
+
+	/* Get the interrupts property */
+	intspec = of_get_property(device, "interrupts", &intlen);
+	if (intspec == NULL)
+		return -EINVAL;
+
+	intlen /= sizeof(*intspec);
+
+	pr_debug(" intspec=%d intlen=%d\n", be32_to_cpup(intspec), intlen);
+
+	/* Look for the interrupt parent. */
+	p = of_irq_find_parent(device);
+	if (p == NULL)
+		return -EINVAL;
+
+	/* Get size of interrupt specifier */
+	tmp = of_get_property(p, "#interrupt-cells", NULL);
+	if (tmp == NULL) {
+		res = -EINVAL;
+		goto out;
+	}
+	intsize = be32_to_cpu(*tmp);
+
+	pr_debug(" intsize=%d intlen=%d\n", intsize, intlen);
+
+	/* Check index */
+	if ((index + 1) * intsize > intlen) {
+		res = -EINVAL;
+		goto out;
+	}
+
+	/* Copy intspec into irq structure */
+	intspec += index * intsize;
+	out_irq->np = p;
+	out_irq->args_count = intsize;
+	for (i = 0; i < intsize; i++)
+		out_irq->args[i] = be32_to_cpup(intspec++);
+
+	/* Check if there are any interrupt-map translations to process */
+	res = of_irq_parse_raw(addr, out_irq);
+ out:
+	of_node_put(p);
+	return res;
+}
+
+/**
+ * of_irq_get - Decode a node's IRQ and return it as a Linux IRQ number
+ * @dev: pointer to device tree node
+ * @index: zero-based index of the IRQ
+ *
+ * Returns Linux IRQ number on success, or 0 on the IRQ mapping failure, or
+ * -EPROBE_DEFER if the IRQ domain is not yet created, or error code in case
+ * of any other failure.
+ */
+int of_irq_get(struct device_node *dev, int index)
+{
+	int rc;
+	struct of_phandle_args oirq;
+	struct irq_domain *domain;
+
+	rc = of_irq_parse_one(dev, index, &oirq);
+	if (rc)
+		return rc;
+
+	domain = irq_find_host(oirq.np);
+	if (!domain)
+		return -EPROBE_DEFER;
+
+	return irq_create_of_mapping(oirq.np, (const u32 *)&oirq.args,
+				     oirq.args_count);
+}
+#endif
+
+#if defined(WILC_DEBUGFS)
+static struct dentry *wilc_dir;
+
+static ssize_t wilc_debug_region_read(struct file *file, char __user *userbuf,
+				     size_t count, loff_t *ppos)
+{
+	char buf[128];
+	int res = 0;
+
+	/* only allow read from start */
+	if (*ppos > 0)
+		return 0;
+
+	res = scnprintf(buf, sizeof(buf), "Debug Region: (0x%08x)\n",
+				    atomic_read(&WILC_DEBUG_REGION));
+
+	return simple_read_from_buffer(userbuf, count, ppos, buf, res);
+}
+
+static ssize_t wilc_debug_region_write(struct file *filp,
+				      const char __user *buf, size_t count,
+				      loff_t *ppos)
+{
+	int flag = 0;
+	int ret;
+
+	ret = kstrtouint_from_user(buf, count, 16, &flag);
+	if (ret)
+		return ret;
+
+	if (flag > DBG_REGION_ALL) {
+		pr_err("%s, value (0x%08x) is out of range, stay previous flag (0x%08x)\n",
+			   __func__, flag, atomic_read(&WILC_DEBUG_REGION));
+		pr_err("allowed bits are 0 to 15\n");
+		return -EINVAL;
+	}
+
+	atomic_set(&WILC_DEBUG_REGION, (int)flag);
+
+	pr_info("Debug region set to %x\n", atomic_read(&WILC_DEBUG_REGION));
+
+	return count;
+}
+
+#define FOPS(_open, _read, _write, _poll) { \
+		.owner	= THIS_MODULE, \
+		.open	= (_open), \
+		.read	= (_read), \
+		.write	= (_write), \
+		.poll		= (_poll), \
+}
+
+struct wilc_debugfs_info_t {
+	const char *name;
+	int perm;
+	unsigned int data;
+	const struct file_operations fops;
+};
+
+static struct wilc_debugfs_info_t debugfs_info[] = {
+	{
+		"wilc_debug_region",
+		0666,
+		0,
+		FOPS(NULL, wilc_debug_region_read, wilc_debug_region_write,
+		     NULL),
+	},
+};
+
+int wilc_debugfs_init(void)
+{
+	int i;
+	struct wilc_debugfs_info_t *info;
+
+	wilc_dir = debugfs_create_dir("wilc", NULL);
+	if (wilc_dir == NULL) {
+		pr_err("Error creating debugfs\n");
+		return -EFAULT;
+	}
+	for (i = 0; i < ARRAY_SIZE(debugfs_info); i++) {
+		info = &debugfs_info[i];
+		debugfs_create_file(info->name,
+				    info->perm,
+				    wilc_dir,
+				    &info->data,
+				    &info->fops);
+	}
+	return 0;
+}
+
+void wilc_debugfs_remove(void)
+{
+	debugfs_remove_recursive(wilc_dir);
+}
+
+#endif
diff --git a/drivers/staging/wilc1000/debugfs.h b/drivers/staging/wilc1000/debugfs.h
new file mode 100644
index 000000000..2de82a194
--- /dev/null
+++ b/drivers/staging/wilc1000/debugfs.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#ifndef WILC_DEBUGFS_H
+#define WILC_DEBUGFS_H
+
+#include <linux/kern_levels.h>
+#include <linux/version.h>
+#if KERNEL_VERSION(3, 15, 0) > LINUX_VERSION_CODE
+#include <linux/of_irq.h>
+#endif
+
+#define GENERIC_DBG		BIT(0)
+#define HOSTAPD_DBG		BIT(1)
+#define HOSTINF_DBG		BIT(2)
+#define CORECONFIG_DBG		BIT(3)
+#define CFG80211_DBG		BIT(4)
+#define INT_DBG			BIT(5)
+#define TX_DBG			BIT(6)
+#define RX_DBG			BIT(7)
+#define TCP_ENH			BIT(8)
+#define INIT_DBG		BIT(9)
+#define PWRDEV_DBG		BIT(10)
+#define DBG_REGION_ALL		(BIT(11)-1)
+
+extern atomic_t WILC_DEBUG_REGION;
+
+#define PRINT_D(netdev, region, format, ...) do { \
+	if (atomic_read(&WILC_DEBUG_REGION)&(region))\
+		netdev_dbg(netdev, "DBG [%s: %d] "format, __func__, __LINE__,\
+		   ##__VA_ARGS__); } \
+	while (0)
+
+#define PRINT_INFO(netdev, region, format, ...) do { \
+	if (atomic_read(&WILC_DEBUG_REGION)&(region))\
+		netdev_info(netdev, "INFO [%s]"format, __func__, \
+		##__VA_ARGS__); } \
+	while (0)
+
+#define PRINT_WRN(netdev, region, format, ...) do { \
+	if (atomic_read(&WILC_DEBUG_REGION)&(region))\
+		netdev_warn(netdev, "WRN [%s: %d]"format, __func__, __LINE__,\
+		    ##__VA_ARGS__); } \
+	while (0)
+
+#define PRINT_ER(netdev, format, ...) netdev_err(netdev, "ERR [%s:%d] "format,\
+	__func__, __LINE__, ##__VA_ARGS__)
+
+#ifdef WILC_DEBUGFS
+int wilc_debugfs_init(void);
+void wilc_debugfs_remove(void);
+#endif
+
+#if KERNEL_VERSION(3, 15, 0) > LINUX_VERSION_CODE
+int of_irq_get(struct device_node *dev, int index);
+#endif
+#endif /* WILC_DEBUGFS_H */
diff --git a/drivers/staging/wilc1000/fw.h b/drivers/staging/wilc1000/fw.h
new file mode 100644
index 000000000..1fedff4e4
--- /dev/null
+++ b/drivers/staging/wilc1000/fw.h
@@ -0,0 +1,120 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#ifndef WILC_FW_H
+#define WILC_FW_H
+
+#include <linux/ieee80211.h>
+
+#define WILC_MAX_NUM_STA			9
+#define WILC_MAX_RATES_SUPPORTED		12
+#define WILC_MAX_NUM_PMKIDS			16
+#define WILC_MAX_NUM_SCANNED_CH			14
+
+struct wilc_assoc_resp {
+	__le16 capab_info;
+	__le16 status_code;
+	__le16 aid;
+} __packed;
+
+struct wilc_pmkid {
+	u8 bssid[ETH_ALEN];
+	u8 pmkid[WLAN_PMKID_LEN];
+} __packed;
+
+struct wilc_pmkid_attr {
+	u8 numpmkid;
+	struct wilc_pmkid pmkidlist[WILC_MAX_NUM_PMKIDS];
+} __packed;
+
+struct wilc_reg_frame {
+	u8 reg;
+	u8 reg_id;
+	__le16 frame_type;
+} __packed;
+struct wilc_drv_handler {
+	__le32 handler;
+	u8 mode;
+} __packed;
+
+struct wilc_wep_key {
+	u8 index;
+	u8 key_len;
+	u8 key[];
+} __packed;
+
+struct wilc_sta_wpa_ptk {
+	u8 mac_addr[ETH_ALEN];
+	u8 key_len;
+	u8 key[];
+} __packed;
+
+struct wilc_ap_wpa_ptk {
+	u8 mac_addr[ETH_ALEN];
+	u8 index;
+	u8 key_len;
+	u8 key[];
+} __packed;
+
+struct wilc_gtk_key {
+	u8 mac_addr[ETH_ALEN];
+	u8 rsc[8];
+	u8 index;
+	u8 key_len;
+	u8 key[];
+} __packed;
+
+struct wilc_op_mode {
+	__le32 mode;
+} __packed;
+
+struct wilc_noa_opp_enable {
+	u8 ct_window;
+	u8 cnt;
+	__le32 duration;
+	__le32 interval;
+	__le32 start_time;
+} __packed;
+
+struct wilc_noa_opp_disable {
+	u8 cnt;
+	__le32 duration;
+	__le32 interval;
+	__le32 start_time;
+} __packed;
+
+struct wilc_join_bss_param {
+	char ssid[IEEE80211_MAX_SSID_LEN];
+	u8 ssid_terminator;
+	u8 bss_type;
+	u8 ch;
+	__le16 cap_info;
+	u8 sa[ETH_ALEN];
+	u8 bssid[ETH_ALEN];
+	__le16 beacon_period;
+	u8 dtim_period;
+	u8 supp_rates[WILC_MAX_RATES_SUPPORTED + 1];
+	u8 wmm_cap;
+	u8 uapsd_cap;
+	u8 ht_capable;
+	u8 rsn_found;
+	u8 rsn_grp_policy;
+	u8 mode_802_11i;
+	u8 p_suites[3];
+	u8 akm_suites[3];
+	u8 rsn_cap[2];
+	u8 noa_enabled;
+	__le32 tsf_lo;
+	u8 idx;
+	u8 opp_enabled;
+	union {
+		struct wilc_noa_opp_disable opp_dis;
+		struct wilc_noa_opp_enable opp_en;
+	};
+} __packed;
+
+#endif
+
diff --git a/drivers/staging/wilc1000/wilc_hif.c b/drivers/staging/wilc1000/hif.c
similarity index 63%
rename from drivers/staging/wilc1000/wilc_hif.c
rename to drivers/staging/wilc1000/hif.c
index 221e3d93d..8d9cbc07a 100644
--- a/drivers/staging/wilc1000/wilc_hif.c
+++ b/drivers/staging/wilc1000/hif.c
@@ -4,13 +4,78 @@
  * All rights reserved.
  */
 
-#include "wilc_wfi_netdevice.h"
+#include <linux/etherdevice.h>
 
-#define WILC_HIF_SCAN_TIMEOUT_MS                5000
-#define WILC_HIF_CONNECT_TIMEOUT_MS             9500
+#include "netdev.h"
+#include "cfg80211.h"
 
-#define WILC_FALSE_FRMWR_CHANNEL		100
-#define WILC_MAX_RATES_SUPPORTED		12
+#define WILC_HIF_SCAN_TIMEOUT_MS                    5000
+#define WILC_HIF_CONNECT_TIMEOUT_MS                 9500
+
+#define WILC_FALSE_FRMWR_CHANNEL		    100
+#define WILC_MAX_RATES_SUPPORTED		    12
+
+/* Generic success will return 0 */
+#define WILC_SUCCESS		0	/* Generic success */
+
+/* Negative numbers to indicate failures */
+/* Generic Fail */
+#define	WILC_FAIL		-100
+/* Busy with another operation*/
+#define	WILC_BUSY		-101
+/* A given argument is invalid*/
+#define	WILC_INVALID_ARGUMENT	-102
+/* An API request would violate the Driver state machine
+ * (i.e. to start PID while not camped)
+ */
+#define	WILC_INVALID_STATE	-103
+/* In copy operations if the copied data is larger than the allocated buffer*/
+#define	WILC_BUFFER_OVERFLOW	-104
+/* null pointer is passed or used */
+#define WILC_NULL_PTR		-105
+#define	WILC_EMPTY		-107
+#define WILC_FULL		-108
+#define	WILC_TIMEOUT		-109
+/* The required operation have been canceled by the user*/
+#define WILC_CANCELED		-110
+/* The Loaded file is corruped or having an invalid format */
+#define WILC_INVALID_FILE	-112
+/* Cant find the file to load */
+#define WILC_NOT_FOUND		-113
+#define WILC_NO_MEM		-114
+#define WILC_UNSUPPORTED_VERSION -115
+#define WILC_FILE_EOF		-116
+
+#if KERNEL_VERSION(3, 17, 0) > LINUX_VERSION_CODE
+struct ieee80211_wmm_ac_param {
+	u8 aci_aifsn; /* AIFSN, ACM, ACI */
+	u8 cw; /* ECWmin, ECWmax (CW = 2^ECW - 1) */
+	__le16 txop_limit;
+} __packed;
+
+struct ieee80211_wmm_param_ie {
+	u8 element_id; /* Element ID: 221 (0xdd); */
+	u8 len; /* Length: 24 */
+	u8 oui[3]; /* 00:50:f2 */
+	u8 oui_type; /* 2 */
+	u8 oui_subtype; /* 1 */
+	u8 version; /* 1 for WMM version 1.0 */
+	u8 qos_info; /* AP/STA specific QoS info */
+	u8 reserved; /* 0 */
+	/* AC_BE, AC_BK, AC_VI, AC_VO */
+	struct ieee80211_wmm_ac_param ac[4];
+} __packed;
+#endif
+
+struct send_buffered_eap {
+	void (*deliver_to_stack)(struct wilc_vif *vif, u8 *buff, u32 size,
+			      u32 pkt_offset, u8 status);
+	void (*eap_buf_param)(void *priv);
+	u8 *buff;
+	unsigned int size;
+	unsigned int pkt_offset;
+	void *user_arg;
+};
 
 #define WILC_SCAN_WID_LIST_SIZE		6
 
@@ -24,52 +89,25 @@ struct wilc_set_multicast {
 	u8 *mc_list;
 };
 
-struct wilc_del_all_sta {
-	u8 assoc_sta;
-	u8 mac[WILC_MAX_NUM_STA][ETH_ALEN];
+struct host_if_wowlan_trigger {
+	u8 wowlan_trigger;
 };
 
-struct wilc_op_mode {
-	__le32 mode;
+struct bt_coex_mode {
+	u8 bt_coex;
 };
 
-struct wilc_reg_frame {
-	bool reg;
-	u8 reg_id;
-	__le16 frame_type;
-} __packed;
-
-struct wilc_drv_handler {
-	__le32 handler;
+struct host_if_set_ant {
 	u8 mode;
-} __packed;
-
-struct wilc_wep_key {
-	u8 index;
-	u8 key_len;
-	u8 key[0];
-} __packed;
-
-struct wilc_sta_wpa_ptk {
-	u8 mac_addr[ETH_ALEN];
-	u8 key_len;
-	u8 key[0];
-} __packed;
-
-struct wilc_ap_wpa_ptk {
-	u8 mac_addr[ETH_ALEN];
-	u8 index;
-	u8 key_len;
-	u8 key[0];
-} __packed;
+	u8 antenna1;
+	u8 antenna2;
+	u8 gpio_mode;
+};
 
-struct wilc_gtk_key {
-	u8 mac_addr[ETH_ALEN];
-	u8 rsc[8];
-	u8 index;
-	u8 key_len;
-	u8 key[0];
-} __packed;
+struct wilc_del_all_sta {
+	u8 assoc_sta;
+	u8 mac[WILC_MAX_NUM_STA][ETH_ALEN];
+};
 
 union wilc_message_body {
 	struct wilc_rcvd_net_info net_info;
@@ -77,6 +115,10 @@ union wilc_message_body {
 	struct wilc_set_multicast mc_info;
 	struct wilc_remain_ch remain_on_ch;
 	char *data;
+	struct send_buffered_eap send_buff_eap;
+	struct host_if_set_ant set_ant;
+	struct host_if_wowlan_trigger wow_trigger;
+	struct bt_coex_mode bt_coex_mode;
 };
 
 struct host_if_msg {
@@ -88,50 +130,6 @@ struct host_if_msg {
 	bool is_sync;
 };
 
-struct wilc_noa_opp_enable {
-	u8 ct_window;
-	u8 cnt;
-	__le32 duration;
-	__le32 interval;
-	__le32 start_time;
-} __packed;
-
-struct wilc_noa_opp_disable {
-	u8 cnt;
-	__le32 duration;
-	__le32 interval;
-	__le32 start_time;
-} __packed;
-
-struct wilc_join_bss_param {
-	char ssid[IEEE80211_MAX_SSID_LEN];
-	u8 ssid_terminator;
-	u8 bss_type;
-	u8 ch;
-	__le16 cap_info;
-	u8 sa[ETH_ALEN];
-	u8 bssid[ETH_ALEN];
-	__le16 beacon_period;
-	u8 dtim_period;
-	u8 supp_rates[WILC_MAX_RATES_SUPPORTED + 1];
-	u8 wmm_cap;
-	u8 uapsd_cap;
-	u8 ht_capable;
-	u8 rsn_found;
-	u8 rsn_grp_policy;
-	u8 mode_802_11i;
-	u8 p_suites[3];
-	u8 akm_suites[3];
-	u8 rsn_cap[2];
-	u8 noa_enabled;
-	__le32 tsf_lo;
-	u8 idx;
-	u8 opp_enabled;
-	union {
-		struct wilc_noa_opp_disable opp_dis;
-		struct wilc_noa_opp_enable opp_en;
-	};
-} __packed;
 
 /* 'msg' should be free by the caller for syc */
 static struct host_if_msg*
@@ -185,47 +183,44 @@ int wilc_get_vif_idx(struct wilc_vif *vif)
 static struct wilc_vif *wilc_get_vif_from_idx(struct wilc *wilc, int idx)
 {
 	int index = idx - 1;
+	struct wilc_vif *vif;
 
 	if (index < 0 || index >= WILC_NUM_CONCURRENT_IFC)
 		return NULL;
 
-	return wilc->vif[index];
+	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
+		if (vif->idx == index)
+			return vif;
+	}
+
+	return NULL;
 }
 
-static int handle_scan_done(struct wilc_vif *vif, enum scan_event evt)
+static void handle_send_buffered_eap(struct work_struct *work)
 {
-	int result = 0;
-	u8 abort_running_scan;
-	struct wid wid;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-	struct wilc_user_scan_req *scan_req;
-
-	if (evt == SCAN_EVENT_ABORTED) {
-		abort_running_scan = 1;
-		wid.id = WID_ABORT_RUNNING_SCAN;
-		wid.type = WID_CHAR;
-		wid.val = (s8 *)&abort_running_scan;
-		wid.size = sizeof(char);
-
-		result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
-		if (result) {
-			netdev_err(vif->ndev, "Failed to set abort running\n");
-			result = -EFAULT;
-		}
-	}
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct send_buffered_eap *hif_buff_eap = &msg->body.send_buff_eap;
 
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "%s: hif driver is NULL\n", __func__);
-		return result;
-	}
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending bufferd eapol to WPAS\n");
+	if (!hif_buff_eap->buff)
+		goto out;
 
-	scan_req = &hif_drv->usr_scan_req;
-	if (scan_req->scan_result) {
-		scan_req->scan_result(evt, NULL, scan_req->arg);
-		scan_req->scan_result = NULL;
+	if (hif_buff_eap->deliver_to_stack)
+		hif_buff_eap->deliver_to_stack(vif, hif_buff_eap->buff,
+					       hif_buff_eap->size,
+					       hif_buff_eap->pkt_offset,
+					       PKT_STATUS_BUFFERED);
+	if (hif_buff_eap->eap_buf_param)
+		hif_buff_eap->eap_buf_param(hif_buff_eap->user_arg);
+
+	if (hif_buff_eap->buff != NULL) {
+		kfree(hif_buff_eap->buff);
+		hif_buff_eap->buff = NULL;
 	}
 
-	return result;
+out:
+	kfree(msg);
 }
 
 int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
@@ -242,20 +237,42 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 	u8 valuesize = 0;
 	u8 *search_ssid_vals = NULL;
 	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (hif_drv->hif_state >= HOST_IF_SCANNING &&
-	    hif_drv->hif_state < HOST_IF_CONNECTED) {
-		netdev_err(vif->ndev, "Already scan\n");
-		result = -EBUSY;
-		goto error;
+	struct wilc_vif *vif_tmp;
+	int srcu_idx;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting SCAN params\n");
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Scanning: In [%d] state\n",
+		   hif_drv->hif_state);
+
+	srcu_idx = srcu_read_lock(&vif->wilc->srcu);
+	list_for_each_entry_rcu(vif_tmp, &vif->wilc->vif_list, list) {
+		struct host_if_drv *hif_drv_tmp;
+
+		if (vif_tmp == NULL || vif_tmp->hif_drv == NULL)
+			continue;
+
+		hif_drv_tmp = vif_tmp->hif_drv;
+
+		if (hif_drv_tmp->hif_state != HOST_IF_IDLE &&
+		    hif_drv_tmp->hif_state != HOST_IF_CONNECTED) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "Abort scan. In state [%d]\n",
+				   hif_drv_tmp->hif_state);
+			result = -EBUSY;
+			srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
+			goto error;
+		}
 	}
+	srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
 
 	if (vif->connecting) {
-		netdev_err(vif->ndev, "Don't do obss scan\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Don't do scan in (CONNECTING) state\n");
 		result = -EBUSY;
 		goto error;
 	}
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting SCAN params\n");
 	hif_drv->usr_scan_req.ch_cnt = 0;
 
 	if (request->n_ssids) {
@@ -270,6 +287,9 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 
 			*buffer++ = request->n_ssids;
 
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "In Handle_ProbeRequest number of ssid %d\n",
+			 request->n_ssids);
 			for (i = 0; i < request->n_ssids; i++) {
 				*buffer++ = request->ssids[i].ssid_len;
 				memcpy(buffer, request->ssids[i].ssid,
@@ -293,6 +313,9 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 	wid_list[index].val = (s8 *)&scan_type;
 	index++;
 
+#if KERNEL_VERSION(4, 8, 0) > LINUX_VERSION_CODE
+	scan_timeout = WILC_HIF_SCAN_TIMEOUT_MS;
+#else
 	if (scan_type == WILC_FW_PASSIVE_SCAN && request->duration) {
 		wid_list[index].id = WID_PASSIVE_SCAN_TIME;
 		wid_list[index].type = WID_SHORT;
@@ -304,7 +327,7 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 	} else {
 		scan_timeout = WILC_HIF_SCAN_TIMEOUT_MS;
 	}
-
+#endif
 	wid_list[index].id = WID_SCAN_CHANNEL_LIST;
 	wid_list[index].type = WID_BIN_DATA;
 
@@ -327,17 +350,21 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 
 	hif_drv->usr_scan_req.scan_result = scan_result_fn;
 	hif_drv->usr_scan_req.arg = user_arg;
-
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list, index);
 	if (result) {
-		netdev_err(vif->ndev, "Failed to send scan parameters\n");
+		PRINT_ER(vif->ndev, "Failed to send scan parameters\n");
 		goto error;
+	} else {
+		hif_drv->scan_timer_vif = vif;
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   ">> Starting the SCAN timer\n");
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+		hif_drv->scan_timer.data = (unsigned long)hif_drv;
+#endif
+		mod_timer(&hif_drv->scan_timer,
+			  jiffies + msecs_to_jiffies(scan_timeout));
 	}
 
-	hif_drv->scan_timer_vif = vif;
-	mod_timer(&hif_drv->scan_timer,
-		  jiffies + msecs_to_jiffies(scan_timeout));
-
 error:
 
 	kfree(search_ssid_vals);
@@ -345,6 +372,51 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 	return result;
 }
 
+s32 handle_scan_done(struct wilc_vif *vif, enum scan_event evt)
+{
+	s32 result = 0;
+	u8 abort_running_scan;
+	struct wid wid;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct wilc_user_scan_req *scan_req;
+	u8 null_bssid[6] = {0};
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "handling scan done\n");
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
+		return result;
+	}
+
+	if (evt == SCAN_EVENT_DONE) {
+		if (memcmp(hif_drv->assoc_bssid, null_bssid, ETH_ALEN) == 0)
+			hif_drv->hif_state = HOST_IF_IDLE;
+		else
+			hif_drv->hif_state = HOST_IF_CONNECTED;
+	} else if (evt == SCAN_EVENT_ABORTED) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Abort running scan\n");
+		abort_running_scan = 1;
+		wid.id = WID_ABORT_RUNNING_SCAN;
+		wid.type = WID_CHAR;
+		wid.val = (s8 *)&abort_running_scan;
+		wid.size = sizeof(char);
+
+		result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
+		if (result) {
+			PRINT_ER(vif->ndev, "Failed to set abort running\n");
+			result = -EFAULT;
+		}
+	}
+
+	scan_req = &hif_drv->usr_scan_req;
+	if (scan_req->scan_result) {
+		scan_req->scan_result(evt, NULL, scan_req->arg);
+		scan_req->scan_result = NULL;
+	}
+
+	return result;
+}
+
 static int wilc_send_connect_wid(struct wilc_vif *vif)
 {
 	int result = 0;
@@ -352,7 +424,29 @@ static int wilc_send_connect_wid(struct wilc_vif *vif)
 	u32 wid_cnt = 0;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 	struct wilc_conn_info *conn_attr = &hif_drv->conn_info;
-	struct wilc_join_bss_param *bss_param = conn_attr->param;
+	struct wilc_join_bss_param *bss_param = hif_drv->conn_info.param;
+	struct wilc_vif *vif_tmp;
+	int srcu_idx;
+
+	srcu_idx = srcu_read_lock(&vif->wilc->srcu);
+	list_for_each_entry_rcu(vif_tmp, &vif->wilc->vif_list, list) {
+		struct host_if_drv *hif_drv_tmp;
+
+		if (vif_tmp == NULL || vif_tmp->hif_drv == NULL)
+			continue;
+
+		hif_drv_tmp = vif_tmp->hif_drv;
+
+		if (hif_drv_tmp->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "Abort connect in state [%d]\n",
+				   hif_drv_tmp->hif_state);
+			result = -EBUSY;
+			srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
+			goto error;
+		}
+	}
+	srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
 
 	wid_list[wid_cnt].id = WID_INFO_ELEMENT_ASSOCIATE;
 	wid_list[wid_cnt].type = WID_BIN_DATA;
@@ -366,23 +460,34 @@ static int wilc_send_connect_wid(struct wilc_vif *vif)
 	wid_list[wid_cnt].val = (s8 *)&conn_attr->security;
 	wid_cnt++;
 
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Encrypt Mode = %x\n",
+		conn_attr->security);
 	wid_list[wid_cnt].id = WID_AUTH_TYPE;
 	wid_list[wid_cnt].type = WID_CHAR;
 	wid_list[wid_cnt].size = sizeof(char);
 	wid_list[wid_cnt].val = (s8 *)&conn_attr->auth_type;
 	wid_cnt++;
 
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Authentication Type = %x\n",
+		conn_attr->auth_type);
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Connecting to network on channel %d\n", conn_attr->ch);
+
 	wid_list[wid_cnt].id = WID_JOIN_REQ_EXTENDED;
 	wid_list[wid_cnt].type = WID_STR;
 	wid_list[wid_cnt].size = sizeof(*bss_param);
 	wid_list[wid_cnt].val = (u8 *)bss_param;
 	wid_cnt++;
 
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "send HOST_IF_WAITING_CONN_RESP\n");
+
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list, wid_cnt);
 	if (result) {
-		netdev_err(vif->ndev, "failed to send config packet\n");
+		PRINT_ER(vif->ndev, "failed to send config packet\n");
 		goto error;
 	} else {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "set HOST_IF_WAITING_CONN_RESP\n");
 		hif_drv->hif_state = HOST_IF_WAITING_CONN_RESP;
 	}
 
@@ -396,6 +501,23 @@ static int wilc_send_connect_wid(struct wilc_vif *vif)
 	return result;
 }
 
+void handle_connect_cancel(struct wilc_vif *vif)
+{
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (hif_drv->conn_info.conn_result) {
+		hif_drv->conn_info.conn_result(EVENT_DISCONN_NOTIF,
+					       0, hif_drv->conn_info.arg);
+	}
+
+	eth_zero_addr(hif_drv->assoc_bssid);
+
+	hif_drv->conn_info.req_ies_len = 0;
+	kfree(hif_drv->conn_info.req_ies);
+	hif_drv->conn_info.req_ies = NULL;
+	hif_drv->hif_state = HOST_IF_IDLE;
+}
+
 static void handle_connect_timeout(struct work_struct *work)
 {
 	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
@@ -406,19 +528,19 @@ static void handle_connect_timeout(struct work_struct *work)
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
 	if (!hif_drv) {
-		netdev_err(vif->ndev, "%s: hif driver is NULL\n", __func__);
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		goto out;
 	}
 
 	hif_drv->hif_state = HOST_IF_IDLE;
 
 	if (hif_drv->conn_info.conn_result) {
-		hif_drv->conn_info.conn_result(CONN_DISCONN_EVENT_CONN_RESP,
+		hif_drv->conn_info.conn_result(EVENT_CONN_RESP,
 					       WILC_MAC_STATUS_DISCONNECTED,
 					       hif_drv->conn_info.arg);
 
 	} else {
-		netdev_err(vif->ndev, "%s: conn_result is NULL\n", __func__);
+		PRINT_ER(vif->ndev, "conn_result is NULL\n");
 	}
 
 	wid.id = WID_DISCONNECT;
@@ -426,9 +548,10 @@ static void handle_connect_timeout(struct work_struct *work)
 	wid.val = (s8 *)&dummy_reason_code;
 	wid.size = sizeof(char);
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending disconnect request\n");
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to send disconnect\n");
+		PRINT_ER(vif->ndev, "Failed to send disconect\n");
 
 	hif_drv->conn_info.req_ies_len = 0;
 	kfree(hif_drv->conn_info.req_ies);
@@ -553,7 +676,7 @@ void *wilc_parse_join_bss_param(struct cfg80211_bss *bss,
 
 		param->mode_802_11i = 2;
 		param->rsn_found = true;
-		//extract RSN capabilities
+		/* extract RSN capabilities */
 		offset += (rsn_ie[offset] * 4) + 2;
 		offset += (rsn_ie[offset] * 4) + 2;
 		memcpy(param->rsn_cap, &rsn_ie[offset], 2);
@@ -583,6 +706,9 @@ static void handle_rcvd_ntwrk_info(struct work_struct *work)
 	int ies_len;
 	size_t offset;
 
+	PRINT_D(msg->vif->ndev, HOSTINF_DBG,
+		"Handling received network info\n");
+
 	if (ieee80211_is_probe_resp(rcvd_info->mgmt->frame_control))
 		offset = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
 	else if (ieee80211_is_beacon(rcvd_info->mgmt->frame_control))
@@ -595,13 +721,15 @@ static void handle_rcvd_ntwrk_info(struct work_struct *work)
 	if (ies_len <= 0)
 		goto done;
 
+	PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "New network found\n");
+	/* extract the channel from recevied mgmt frame */
 	ch_elm = cfg80211_find_ie(WLAN_EID_DS_PARAMS, ies, ies_len);
 	if (ch_elm && ch_elm[1] > 0)
 		rcvd_info->ch = ch_elm[2];
 
 	if (scan_req->scan_result)
-		scan_req->scan_result(SCAN_EVENT_NETWORK_FOUND, rcvd_info,
-				      scan_req->arg);
+		scan_req->scan_result(SCAN_EVENT_NETWORK_FOUND,
+				      rcvd_info, scan_req->arg);
 
 done:
 	kfree(rcvd_info->mgmt);
@@ -624,7 +752,7 @@ static void host_int_get_assoc_res_info(struct wilc_vif *vif,
 	result = wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);
 	if (result) {
 		*rcvd_assoc_resp_info_len = 0;
-		netdev_err(vif->ndev, "Failed to send association response\n");
+		PRINT_ER(vif->ndev, "Failed to send association response\n");
 		return;
 	}
 
@@ -636,7 +764,7 @@ static s32 wilc_parse_assoc_resp_info(u8 *buffer, u32 buffer_len,
 {
 	u8 *ies;
 	u16 ies_len;
-	struct assoc_resp *res = (struct assoc_resp *)buffer;
+	struct wilc_assoc_resp *res = (struct wilc_assoc_resp *)buffer;
 
 	ret_conn_info->status = le16_to_cpu(res->status_code);
 	if (ret_conn_info->status == WLAN_STATUS_SUCCESS) {
@@ -668,28 +796,37 @@ static inline void host_int_parse_assoc_resp_info(struct wilc_vif *vif,
 					    WILC_MAX_ASSOC_RESP_FRAME_SIZE,
 					    &assoc_resp_info_len);
 
+		PRINT_D(vif->ndev, HOSTINF_DBG,
+			"Received association response = %d\n",
+			assoc_resp_info_len);
 		if (assoc_resp_info_len != 0) {
 			s32 err = 0;
 
+			PRINT_INFO(vif->ndev, HOSTINF_DBG,
+				   "Parsing association response\n");
 			err = wilc_parse_assoc_resp_info(hif_drv->assoc_resp,
 							 assoc_resp_info_len,
 							 conn_info);
 			if (err)
-				netdev_err(vif->ndev,
-					   "wilc_parse_assoc_resp_info() returned error %d\n",
-					   err);
+				PRINT_ER(vif->ndev,
+					 "wilc_parse_assoc_resp_info() returned error %d\n",
+					 err);
 		}
 	}
 
 	del_timer(&hif_drv->connect_timer);
-	conn_info->conn_result(CONN_DISCONN_EVENT_CONN_RESP, mac_status,
-			       hif_drv->conn_info.arg);
+	conn_info->conn_result(EVENT_CONN_RESP, mac_status, conn_info->arg);
 
 	if (mac_status == WILC_MAC_STATUS_CONNECTED &&
 	    conn_info->status == WLAN_STATUS_SUCCESS) {
-		ether_addr_copy(hif_drv->assoc_bssid, conn_info->bssid);
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "MAC status : CONNECTED and Connect Status : Successful\n");
 		hif_drv->hif_state = HOST_IF_CONNECTED;
+		ether_addr_copy(hif_drv->assoc_bssid, conn_info->bssid);
 	} else {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "MAC status : %d and Connect Status : %d\n",
+			   mac_status, conn_info->status);
 		hif_drv->hif_state = HOST_IF_IDLE;
 	}
 
@@ -706,16 +843,21 @@ static inline void host_int_handle_disconnect(struct wilc_vif *vif)
 {
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Received WILC_MAC_STATUS_DISCONNECTED from the FW\n");
 	if (hif_drv->usr_scan_req.scan_result) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "\n\n<< Abort the running OBSS Scan >>\n\n");
 		del_timer(&hif_drv->scan_timer);
 		handle_scan_done(vif, SCAN_EVENT_ABORTED);
 	}
 
-	if (hif_drv->conn_info.conn_result)
-		hif_drv->conn_info.conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
+	if (hif_drv->conn_info.conn_result) {
+		hif_drv->conn_info.conn_result(EVENT_DISCONN_NOTIF,
 					       0, hif_drv->conn_info.arg);
-	else
-		netdev_err(vif->ndev, "%s: conn_result is NULL\n", __func__);
+	} else {
+		PRINT_ER(vif->ndev, "Connect result NULL\n");
+	}
 
 	eth_zero_addr(hif_drv->assoc_bssid);
 
@@ -737,17 +879,22 @@ static void handle_rcvd_gnrl_async_info(struct work_struct *work)
 		goto free_msg;
 	}
 
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "Current State = %d,Received state = %d\n",
+		   hif_drv->hif_state, mac_info->status);
+
 	if (!hif_drv->conn_info.conn_result) {
-		netdev_err(vif->ndev, "%s: conn_result is NULL\n", __func__);
+		PRINT_ER(vif->ndev, "conn_result is NULL\n");
 		goto free_msg;
 	}
-
 	if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {
 		host_int_parse_assoc_resp_info(vif, mac_info->status);
 	} else if (mac_info->status == WILC_MAC_STATUS_DISCONNECTED) {
 		if (hif_drv->hif_state == HOST_IF_CONNECTED) {
 			host_int_handle_disconnect(vif);
 		} else if (hif_drv->usr_scan_req.scan_result) {
+			PRINT_WRN(vif->ndev, HOSTINF_DBG,
+				  "Received WILC_MAC_STATUS_DISCONNECTED. Abort the running Scan");
 			del_timer(&hif_drv->scan_timer);
 			handle_scan_done(vif, SCAN_EVENT_ABORTED);
 		}
@@ -765,16 +912,39 @@ int wilc_disconnect(struct wilc_vif *vif)
 	struct wilc_conn_info *conn_info;
 	int result;
 	u16 dummy_reason_code = 0;
+	struct wilc_vif *vif_tmp;
+	int srcu_idx;
+
+	srcu_idx = srcu_read_lock(&vif->wilc->srcu);
+	list_for_each_entry_rcu(vif_tmp, &vif->wilc->vif_list, list) {
+		struct host_if_drv *hif_drv_tmp;
+
+		if (vif_tmp == NULL || vif_tmp->hif_drv == NULL)
+			continue;
+
+		hif_drv_tmp = vif_tmp->hif_drv;
+
+		if (hif_drv_tmp->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "Abort scan from disconnect. state [%d]\n",
+				   hif_drv_tmp->hif_state);
+			del_timer(&hif_drv_tmp->scan_timer);
+			handle_scan_done(vif_tmp, SCAN_EVENT_ABORTED);
+		}
+	}
+	srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
 
 	wid.id = WID_DISCONNECT;
 	wid.type = WID_CHAR;
 	wid.val = (s8 *)&dummy_reason_code;
 	wid.size = sizeof(char);
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending disconnect request\n");
+
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result) {
-		netdev_err(vif->ndev, "Failed to send disconnect\n");
-		return result;
+		PRINT_ER(vif->ndev, "Failed to send disconnect\n");
+		return -ENOMEM;
 	}
 
 	scan_req = &hif_drv->usr_scan_req;
@@ -787,13 +957,21 @@ int wilc_disconnect(struct wilc_vif *vif)
 	}
 
 	if (conn_info->conn_result) {
-		if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP)
+		if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {
+			PRINT_INFO(vif->ndev, HOSTINF_DBG,
+				   "supplicant requested disconnection\n");
 			del_timer(&hif_drv->connect_timer);
+			conn_info->conn_result(EVENT_CONN_RESP,
+					       WILC_MAC_STATUS_DISCONNECTED,
+					       conn_info->arg);
 
-		conn_info->conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF, 0,
-				       conn_info->arg);
+		} else if (hif_drv->hif_state == HOST_IF_CONNECTED) {
+			conn_info->conn_result(EVENT_DISCONN_NOTIF,
+					       WILC_MAC_STATUS_DISCONNECTED,
+					       conn_info->arg);
+		}
 	} else {
-		netdev_err(vif->ndev, "%s: conn_result is NULL\n", __func__);
+		PRINT_ER(vif->ndev, "conn_result = NULL\n");
 	}
 
 	hif_drv->hif_state = HOST_IF_IDLE;
@@ -803,6 +981,7 @@ int wilc_disconnect(struct wilc_vif *vif)
 	conn_info->req_ies_len = 0;
 	kfree(conn_info->req_ies);
 	conn_info->req_ies = NULL;
+	conn_info->conn_result = NULL;
 
 	return 0;
 }
@@ -844,15 +1023,19 @@ int wilc_get_statistics(struct wilc_vif *vif, struct rf_info *stats)
 
 	result = wilc_send_config_pkt(vif, WILC_GET_CFG, wid_list, wid_cnt);
 	if (result) {
-		netdev_err(vif->ndev, "Failed to send scan parameters\n");
+		PRINT_ER(vif->ndev, "Failed to send scan parameters\n");
 		return result;
 	}
 
 	if (stats->link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH &&
-	    stats->link_speed != DEFAULT_LINK_SPEED)
+	    stats->link_speed != DEFAULT_LINK_SPEED) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Enable TCP filter\n");
 		wilc_enable_tcp_ack_filter(vif, true);
-	else if (stats->link_speed != DEFAULT_LINK_SPEED)
+	} else if (stats->link_speed != DEFAULT_LINK_SPEED) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Disable TCP filter %d\n",
+			   stats->link_speed);
 		wilc_enable_tcp_ack_filter(vif, false);
+	}
 
 	return result;
 }
@@ -864,15 +1047,16 @@ static void handle_get_statistics(struct work_struct *work)
 	struct rf_info *stats = (struct rf_info *)msg->body.data;
 
 	wilc_get_statistics(vif, stats);
-
 	kfree(msg);
 }
 
-static void wilc_hif_pack_sta_param(u8 *cur_byte, const u8 *mac,
+static void wilc_hif_pack_sta_param(struct wilc_vif *vif, u8 *cur_byte,
+				    const u8 *mac,
 				    struct station_parameters *params)
 {
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Packing STA params\n");
 	ether_addr_copy(cur_byte, mac);
-	cur_byte += ETH_ALEN;
+	cur_byte +=  ETH_ALEN;
 
 	put_unaligned_le16(params->aid, cur_byte);
 	cur_byte += 2;
@@ -885,7 +1069,7 @@ static void wilc_hif_pack_sta_param(u8 *cur_byte, const u8 *mac,
 
 	if (params->ht_capa) {
 		*cur_byte++ = true;
-		memcpy(cur_byte, &params->ht_capa,
+		memcpy(cur_byte, params->ht_capa,
 		       sizeof(struct ieee80211_ht_cap));
 	} else {
 		*cur_byte++ = false;
@@ -904,16 +1088,50 @@ static int handle_remain_on_chan(struct wilc_vif *vif,
 	u8 remain_on_chan_flag;
 	struct wid wid;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct wilc_vif *vif_tmp;
+	int srcu_idx;
 
-	if (hif_drv->usr_scan_req.scan_result)
-		return -EBUSY;
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver is null\n");
+		return -EFAULT;
+	}
 
-	if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP)
-		return -EBUSY;
+	srcu_idx = srcu_read_lock(&vif->wilc->srcu);
+	list_for_each_entry_rcu(vif_tmp, &vif->wilc->vif_list, list) {
+		struct host_if_drv *hif_drv_tmp;
+
+		if (vif_tmp == NULL || vif_tmp->hif_drv == NULL)
+			continue;
+
+		hif_drv_tmp = vif_tmp->hif_drv;
+
+		if (hif_drv_tmp->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "IFC busy scanning. WLAN_IFC state %d\n",
+				   hif_drv_tmp->hif_state);
+			srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
+			return -EBUSY;
+		} else if (hif_drv_tmp->hif_state != HOST_IF_IDLE &&
+			   hif_drv_tmp->hif_state != HOST_IF_CONNECTED) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "IFC busy connecting. WLAN_IFC %d\n",
+				   hif_drv_tmp->hif_state);
+			srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
+			return -EBUSY;
+		}
+	}
+	srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
 
-	if (vif->connecting)
+	if (vif->connecting) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Don't do scan in (CONNECTING) state\n");
 		return -EBUSY;
+	}
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting channel [%d] duration[%d] [%llu]\n",
+		   hif_remain_ch->ch, hif_remain_ch->duration,
+		   hif_remain_ch->cookie);
 	remain_on_chan_flag = true;
 	wid.id = WID_REMAIN_ON_CHAN;
 	wid.type = WID_STR;
@@ -927,35 +1145,40 @@ static int handle_remain_on_chan(struct wilc_vif *vif,
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	kfree(wid.val);
-	if (result)
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to set remain on channel\n");
 		return -EBUSY;
+	}
 
 	hif_drv->remain_on_ch.arg = hif_remain_ch->arg;
 	hif_drv->remain_on_ch.expired = hif_remain_ch->expired;
 	hif_drv->remain_on_ch.ch = hif_remain_ch->ch;
 	hif_drv->remain_on_ch.cookie = hif_remain_ch->cookie;
+	hif_drv->hif_state = HOST_IF_P2P_LISTEN;
+
 	hif_drv->remain_on_ch_timer_vif = vif;
 
-	return 0;
+	return result;
 }
 
-static int wilc_handle_roc_expired(struct wilc_vif *vif, u64 cookie)
+static int handle_roc_expired(struct wilc_vif *vif, u64 cookie)
 {
 	u8 remain_on_chan_flag;
 	struct wid wid;
 	int result;
 	struct host_if_drv *hif_drv = vif->hif_drv;
-	struct wilc_priv *priv = wdev_priv(vif->ndev->ieee80211_ptr);
+	u8 null_bssid[6] = {0};
 
-	if (priv->p2p_listen_state) {
+	if (hif_drv->hif_state == HOST_IF_P2P_LISTEN) {
 		remain_on_chan_flag = false;
 		wid.id = WID_REMAIN_ON_CHAN;
 		wid.type = WID_STR;
 		wid.size = 2;
-
 		wid.val = kmalloc(wid.size, GFP_KERNEL);
-		if (!wid.val)
+		if (!wid.val) {
+			PRINT_ER(vif->ndev, "Failed to allocate memory\n");
 			return -ENOMEM;
+		}
 
 		wid.val[0] = remain_on_chan_flag;
 		wid.val[1] = WILC_FALSE_FRMWR_CHANNEL;
@@ -963,40 +1186,57 @@ static int wilc_handle_roc_expired(struct wilc_vif *vif, u64 cookie)
 		result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 		kfree(wid.val);
 		if (result != 0) {
-			netdev_err(vif->ndev, "Failed to set remain channel\n");
-			return -EINVAL;
+			PRINT_ER(vif->ndev, "Failed to set remain channel\n");
+			return -ENOMEM;
 		}
 
-		if (hif_drv->remain_on_ch.expired) {
+		if (hif_drv->remain_on_ch.expired)
 			hif_drv->remain_on_ch.expired(hif_drv->remain_on_ch.arg,
 						      cookie);
-		}
+
+		if (memcmp(hif_drv->assoc_bssid, null_bssid, ETH_ALEN) == 0)
+			hif_drv->hif_state = HOST_IF_IDLE;
+		else
+			hif_drv->hif_state = HOST_IF_CONNECTED;
 	} else {
-		netdev_dbg(vif->ndev, "Not in listen state\n");
+		PRINT_D(vif->ndev, GENERIC_DBG,  "Not in listen state\n");
 	}
 
 	return 0;
 }
 
-static void wilc_handle_listen_state_expired(struct work_struct *work)
+static void handle_listen_state_expired(struct work_struct *work)
 {
 	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct wilc_remain_ch *hif_remain_ch = &msg->body.remain_on_ch;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "CANCEL REMAIN ON CHAN\n");
+
+	handle_roc_expired(vif, hif_remain_ch->cookie);
 
-	wilc_handle_roc_expired(msg->vif, msg->body.remain_on_ch.cookie);
 	kfree(msg);
 }
 
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 static void listen_timer_cb(struct timer_list *t)
+#else
+static void listen_timer_cb(unsigned long arg)
+#endif
 {
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 	struct host_if_drv *hif_drv = from_timer(hif_drv, t,
 						      remain_on_ch_timer);
+#else
+	struct host_if_drv *hif_drv = (struct host_if_drv *)arg;
+#endif
 	struct wilc_vif *vif = hif_drv->remain_on_ch_timer_vif;
 	int result;
 	struct host_if_msg *msg;
 
 	del_timer(&vif->hif_drv->remain_on_ch_timer);
 
-	msg = wilc_alloc_work(vif, wilc_handle_listen_state_expired, false);
+	msg = wilc_alloc_work(vif, handle_listen_state_expired, false);
 	if (IS_ERR(msg))
 		return;
 
@@ -1004,7 +1244,7 @@ static void listen_timer_cb(struct timer_list *t)
 
 	result = wilc_enqueue_work(msg);
 	if (result) {
-		netdev_err(vif->ndev, "%s: enqueue work failed\n", __func__);
+		PRINT_ER(vif->ndev, "wilc_mq_send fail\n");
 		kfree(msg);
 	}
 }
@@ -1018,6 +1258,8 @@ static void handle_set_mcast_filter(struct work_struct *work)
 	struct wid wid;
 	u8 *cur_byte;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setup Multicast Filter\n");
+
 	wid.id = WID_SETUP_MULTICAST_FILTER;
 	wid.type = WID_BIN;
 	wid.size = sizeof(struct wilc_set_multicast) + (set_mc->cnt * ETH_ALEN);
@@ -1037,7 +1279,7 @@ static void handle_set_mcast_filter(struct work_struct *work)
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to send setup multicast\n");
+		PRINT_ER(vif->ndev, "Failed to send setup multicast\n");
 
 error:
 	kfree(set_mc->mc_list);
@@ -1045,11 +1287,31 @@ static void handle_set_mcast_filter(struct work_struct *work)
 	kfree(msg);
 }
 
+void wilc_set_wowlan_trigger(struct wilc_vif *vif, u8 wowlan_trigger)
+{
+	int ret;
+	struct wid wid;
+
+	wid.id = WID_WOWLAN_TRIGGER;
+	wid.type = WID_CHAR;
+	wid.val = &wowlan_trigger;
+	wid.size = sizeof(s8);
+
+	ret = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
+	if (ret)
+		PRINT_ER(vif->ndev,
+			 "Failed to send wowlan trigger config packet\n");
+}
+
 static void handle_scan_timer(struct work_struct *work)
 {
 	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	int ret;
 
-	handle_scan_done(msg->vif, SCAN_EVENT_ABORTED);
+	PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "handling scan timer\n");
+	ret = handle_scan_done(msg->vif, SCAN_EVENT_ABORTED);
+	if (ret)
+		PRINT_ER(msg->vif->ndev, "Failed to handle scan done\n");
 	kfree(msg);
 }
 
@@ -1058,15 +1320,24 @@ static void handle_scan_complete(struct work_struct *work)
 	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
 
 	del_timer(&msg->vif->hif_drv->scan_timer);
+	PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "scan completed\n");
 
 	handle_scan_done(msg->vif, SCAN_EVENT_DONE);
 
 	kfree(msg);
 }
 
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 static void timer_scan_cb(struct timer_list *t)
+#else
+static void timer_scan_cb(unsigned long arg)
+#endif
 {
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 	struct host_if_drv *hif_drv = from_timer(hif_drv, t, scan_timer);
+#else
+	struct host_if_drv *hif_drv = (struct host_if_drv *)arg;
+#endif
 	struct wilc_vif *vif = hif_drv->scan_timer_vif;
 	struct host_if_msg *msg;
 	int result;
@@ -1080,10 +1351,17 @@ static void timer_scan_cb(struct timer_list *t)
 		kfree(msg);
 }
 
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 static void timer_connect_cb(struct timer_list *t)
+#else
+static void timer_connect_cb(unsigned long arg)
+#endif
 {
-	struct host_if_drv *hif_drv = from_timer(hif_drv, t,
-						      connect_timer);
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	struct host_if_drv *hif_drv = from_timer(hif_drv, t, connect_timer);
+#else
+	struct host_if_drv *hif_drv = (struct host_if_drv *)arg;
+#endif
 	struct wilc_vif *vif = hif_drv->connect_timer_vif;
 	struct host_if_msg *msg;
 	int result;
@@ -1097,6 +1375,40 @@ static void timer_connect_cb(struct timer_list *t)
 		kfree(msg);
 }
 
+signed int wilc_send_buffered_eap(struct wilc_vif *vif,
+				  void (*deliver_to_stack)(struct wilc_vif *,
+							   u8 *, u32, u32, u8),
+				  void (*eap_buf_param)(void *), u8 *buff,
+				  unsigned int size, unsigned int pkt_offset,
+				  void *user_arg)
+{
+	int result;
+	struct host_if_msg *msg;
+
+	if (!vif || !deliver_to_stack || !eap_buf_param)
+		return -EFAULT;
+
+	msg = wilc_alloc_work(vif, handle_send_buffered_eap, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+	msg->body.send_buff_eap.deliver_to_stack = deliver_to_stack;
+	msg->body.send_buff_eap.eap_buf_param = eap_buf_param;
+	msg->body.send_buff_eap.size = size;
+	msg->body.send_buff_eap.pkt_offset = pkt_offset;
+	msg->body.send_buff_eap.buff = kmalloc(size + pkt_offset,
+						  GFP_ATOMIC);
+	memcpy(msg->body.send_buff_eap.buff, buff, size + pkt_offset);
+	msg->body.send_buff_eap.user_arg = user_arg;
+
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg->body.send_buff_eap.buff);
+		kfree(msg);
+	}
+	return result;
+}
+
 int wilc_remove_wep_key(struct wilc_vif *vif, u8 index)
 {
 	struct wid wid;
@@ -1109,8 +1421,8 @@ int wilc_remove_wep_key(struct wilc_vif *vif, u8 index)
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev,
-			   "Failed to send remove wep key config packet\n");
+		PRINT_ER(vif->ndev,
+			 "Failed to send remove wep key config packet\n");
 	return result;
 }
 
@@ -1125,8 +1437,8 @@ int wilc_set_wep_default_keyid(struct wilc_vif *vif, u8 index)
 	wid.val = &index;
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev,
-			   "Failed to send wep default key config packet\n");
+		PRINT_ER(vif->ndev,
+			 "Failed to send wep default key config packet\n");
 
 	return result;
 }
@@ -1138,13 +1450,15 @@ int wilc_add_wep_key_bss_sta(struct wilc_vif *vif, const u8 *key, u8 len,
 	int result;
 	struct wilc_wep_key *wep_key;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling WEP key\n");
 	wid.id = WID_ADD_WEP_KEY;
 	wid.type = WID_STR;
 	wid.size = sizeof(*wep_key) + len;
 	wep_key = kzalloc(wid.size, GFP_KERNEL);
-	if (!wep_key)
+	if (!wep_key) {
+		PRINT_ER(vif->ndev, "No buffer to send Key\n");
 		return -ENOMEM;
-
+	}
 	wid.val = (u8 *)wep_key;
 
 	wep_key->index = index;
@@ -1167,6 +1481,8 @@ int wilc_add_wep_key_bss_ap(struct wilc_vif *vif, const u8 *key, u8 len,
 	int result;
 	struct wilc_wep_key *wep_key;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling WEP key index: %d\n",
+		   index);
 	wid_list[0].id = WID_11I_MODE;
 	wid_list[0].type = WID_CHAR;
 	wid_list[0].size = sizeof(char);
@@ -1181,8 +1497,10 @@ int wilc_add_wep_key_bss_ap(struct wilc_vif *vif, const u8 *key, u8 len,
 	wid_list[2].type = WID_STR;
 	wid_list[2].size = sizeof(*wep_key) + len;
 	wep_key = kzalloc(wid_list[2].size, GFP_KERNEL);
-	if (!wep_key)
+	if (!wep_key) {
+		PRINT_ER(vif->ndev, "No buffer to send Key\n");
 		return -ENOMEM;
+	}
 
 	wid_list[2].val = (u8 *)wep_key;
 
@@ -1192,8 +1510,8 @@ int wilc_add_wep_key_bss_ap(struct wilc_vif *vif, const u8 *key, u8 len,
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list,
 				      ARRAY_SIZE(wid_list));
 	if (result)
-		netdev_err(vif->ndev,
-			   "Failed to add wep ap key config packet\n");
+		PRINT_ER(vif->ndev,
+			 "Failed to add wep ap key config packet\n");
 
 	kfree(wep_key);
 	return result;
@@ -1204,7 +1522,7 @@ int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
 		 u8 mode, u8 cipher_mode, u8 index)
 {
 	int result = 0;
-	u8 t_key_len  = ptk_key_len + WILC_RX_MIC_KEY_LEN + WILC_TX_MIC_KEY_LEN;
+	u8 t_key_len = ptk_key_len + WILC_RX_MIC_KEY_LEN + WILC_TX_MIC_KEY_LEN;
 
 	if (mode == WILC_AP_MODE) {
 		struct wid wid_list[2];
@@ -1216,9 +1534,11 @@ int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
 		wid_list[0].val = (s8 *)&cipher_mode;
 
 		key_buf = kzalloc(sizeof(*key_buf) + t_key_len, GFP_KERNEL);
-		if (!key_buf)
+		if (!key_buf) {
+			PRINT_ER(vif->ndev,
+				 "NO buffer to keep Key buffer - AP\n");
 			return -ENOMEM;
-
+		}
 		ether_addr_copy(key_buf->mac_addr, mac_addr);
 		key_buf->index = index;
 		key_buf->key_len = t_key_len;
@@ -1244,8 +1564,11 @@ int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
 		struct wilc_sta_wpa_ptk *key_buf;
 
 		key_buf = kzalloc(sizeof(*key_buf) + t_key_len, GFP_KERNEL);
-		if (!key_buf)
+		if (!key_buf) {
+			PRINT_ER(vif->ndev,
+				 "No buffer to keep Key buffer - Station\n");
 			return -ENOMEM;
+		}
 
 		ether_addr_copy(key_buf->mac_addr, mac_addr);
 		key_buf->key_len = t_key_len;
@@ -1280,8 +1603,10 @@ int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
 	int t_key_len = gtk_key_len + WILC_RX_MIC_KEY_LEN + WILC_TX_MIC_KEY_LEN;
 
 	gtk_key = kzalloc(sizeof(*gtk_key) + t_key_len, GFP_KERNEL);
-	if (!gtk_key)
+	if (!gtk_key) {
+		PRINT_ER(vif->ndev, "No buffer to send GTK Key\n");
 		return -ENOMEM;
+	}
 
 	/* fill bssid value only in station mode */
 	if (mode == WILC_STATION_MODE &&
@@ -1316,6 +1641,7 @@ int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
 
 		result = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list,
 					      ARRAY_SIZE(wid_list));
+		kfree(gtk_key);
 	} else if (mode == WILC_STATION_MODE) {
 		struct wid wid;
 
@@ -1324,9 +1650,9 @@ int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
 		wid.size = sizeof(*gtk_key) + t_key_len;
 		wid.val = (u8 *)gtk_key;
 		result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
+		kfree(gtk_key);
 	}
 
-	kfree(gtk_key);
 	return result;
 }
 
@@ -1359,6 +1685,23 @@ int wilc_get_mac_address(struct wilc_vif *vif, u8 *mac_addr)
 	return result;
 }
 
+int wilc_set_mac_address(struct wilc_vif *vif, u8 *mac_addr)
+{
+	struct wid wid;
+	int result;
+
+	wid.id = WID_MAC_ADDR;
+	wid.type = WID_STR;
+	wid.size = ETH_ALEN;
+	wid.val = mac_addr;
+
+	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to set mac address\n");
+
+	return result;
+}
+
 int wilc_set_join_req(struct wilc_vif *vif, u8 *bssid, const u8 *ies,
 		      size_t ies_len)
 {
@@ -1377,9 +1720,14 @@ int wilc_set_join_req(struct wilc_vif *vif, u8 *bssid, const u8 *ies,
 	}
 
 	result = wilc_send_connect_wid(vif);
-	if (result)
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to send connect wid\n");
 		goto free_ies;
+	}
 
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+	hif_drv->connect_timer.data = (unsigned long)hif_drv;
+#endif
 	hif_drv->connect_timer_vif = vif;
 	mod_timer(&hif_drv->connect_timer,
 		  jiffies + msecs_to_jiffies(WILC_HIF_CONNECT_TIMEOUT_MS));
@@ -1404,7 +1752,7 @@ int wilc_set_mac_chnl_num(struct wilc_vif *vif, u8 channel)
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to set channel\n");
+		PRINT_ER(vif->ndev, "Failed to set channel\n");
 
 	return result;
 }
@@ -1426,7 +1774,7 @@ int wilc_set_operation_mode(struct wilc_vif *vif, int index, u8 mode,
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to set driver handler\n");
+		PRINT_ER(vif->ndev, "Failed to set driver handler\n");
 
 	return result;
 }
@@ -1440,14 +1788,16 @@ s32 wilc_get_inactive_time(struct wilc_vif *vif, const u8 *mac, u32 *out_val)
 	wid.type = WID_STR;
 	wid.size = ETH_ALEN;
 	wid.val = kzalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
+	if (!wid.val) {
+		PRINT_ER(vif->ndev, "Failed to allocate buffer\n");
 		return -ENOMEM;
+	}
 
 	ether_addr_copy(wid.val, mac);
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	kfree(wid.val);
 	if (result) {
-		netdev_err(vif->ndev, "Failed to set inactive mac\n");
+		PRINT_ER(vif->ndev, "Failed to set inactive mac\n");
 		return result;
 	}
 
@@ -1457,7 +1807,10 @@ s32 wilc_get_inactive_time(struct wilc_vif *vif, const u8 *mac, u32 *out_val)
 	wid.size = sizeof(u32);
 	result = wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to get inactive time\n");
+		PRINT_ER(vif->ndev, "Failed to get inactive time\n");
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Getting inactive time : %d\n",
+		   *out_val);
 
 	return result;
 }
@@ -1468,7 +1821,7 @@ int wilc_get_rssi(struct wilc_vif *vif, s8 *rssi_level)
 	int result;
 
 	if (!rssi_level) {
-		netdev_err(vif->ndev, "%s: RSSI level is NULL\n", __func__);
+		PRINT_ER(vif->ndev, "RSS pointer value is null\n");
 		return -EFAULT;
 	}
 
@@ -1488,6 +1841,7 @@ static int wilc_get_stats_async(struct wilc_vif *vif, struct rf_info *stats)
 	int result;
 	struct host_if_msg *msg;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, " getting async statistics\n");
 	msg = wilc_alloc_work(vif, handle_get_statistics, false);
 	if (IS_ERR(msg))
 		return PTR_ERR(msg);
@@ -1496,7 +1850,7 @@ static int wilc_get_stats_async(struct wilc_vif *vif, struct rf_info *stats)
 
 	result = wilc_enqueue_work(msg);
 	if (result) {
-		netdev_err(vif->ndev, "%s: enqueue work failed\n", __func__);
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
 		kfree(msg);
 		return result;
 	}
@@ -1541,17 +1895,25 @@ int wilc_hif_set_cfg(struct wilc_vif *vif, struct cfg_param_attr *param)
 	return wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list, i);
 }
 
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 static void get_periodic_rssi(struct timer_list *t)
+#else
+static void get_periodic_rssi(unsigned long arg)
+#endif
 {
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 	struct wilc_vif *vif = from_timer(vif, t, periodic_rssi);
+#else
+	struct wilc_vif *vif = (struct wilc_vif *)arg;
+#endif
 
 	if (!vif->hif_drv) {
-		netdev_err(vif->ndev, "%s: hif driver is NULL", __func__);
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return;
 	}
 
 	if (vif->hif_drv->hif_state == HOST_IF_CONNECTED)
-		wilc_get_stats_async(vif, &vif->periodic_stat);
+		wilc_get_stats_async(vif, &vif->periodic_stats);
 
 	mod_timer(&vif->periodic_rssi, jiffies + msecs_to_jiffies(5000));
 }
@@ -1560,32 +1922,33 @@ int wilc_init(struct net_device *dev, struct host_if_drv **hif_drv_handler)
 {
 	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
 
-	hif_drv  = kzalloc(sizeof(*hif_drv), GFP_KERNEL);
-	if (!hif_drv)
+	hif_drv = kzalloc(sizeof(*hif_drv), GFP_KERNEL);
+	if (!hif_drv) {
+		PRINT_ER(dev, "hif driver is NULL\n");
 		return -ENOMEM;
-
+	}
 	*hif_drv_handler = hif_drv;
-
 	vif->hif_drv = hif_drv;
 
-	if (wilc->clients_count == 0)
-		mutex_init(&wilc->deinit_lock);
-
-	timer_setup(&vif->periodic_rssi, get_periodic_rssi, 0);
-	mod_timer(&vif->periodic_rssi, jiffies + msecs_to_jiffies(5000));
-
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 	timer_setup(&hif_drv->scan_timer, timer_scan_cb, 0);
 	timer_setup(&hif_drv->connect_timer, timer_connect_cb, 0);
 	timer_setup(&hif_drv->remain_on_ch_timer, listen_timer_cb, 0);
+	timer_setup(&vif->periodic_rssi, get_periodic_rssi, 0);
+#else
+	setup_timer(&hif_drv->scan_timer, timer_scan_cb, 0);
+	setup_timer(&hif_drv->connect_timer, timer_connect_cb, 0);
+	setup_timer(&hif_drv->remain_on_ch_timer, listen_timer_cb, 0);
+	setup_timer(&vif->periodic_rssi, get_periodic_rssi,
+			    (unsigned long)vif);
+#endif
+	mod_timer(&vif->periodic_rssi, jiffies + msecs_to_jiffies(5000));
 
 	hif_drv->hif_state = HOST_IF_IDLE;
 
 	hif_drv->p2p_timeout = 0;
 
-	wilc->clients_count++;
-
 	return 0;
 }
 
@@ -1595,7 +1958,7 @@ int wilc_deinit(struct wilc_vif *vif)
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
 	if (!hif_drv) {
-		netdev_err(vif->ndev, "%s: hif driver is NULL", __func__);
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return -EFAULT;
 	}
 
@@ -1616,7 +1979,7 @@ int wilc_deinit(struct wilc_vif *vif)
 
 	kfree(hif_drv);
 	vif->hif_drv = NULL;
-	vif->wilc->clients_count--;
+
 	mutex_unlock(&vif->wilc->deinit_lock);
 	return result;
 }
@@ -1628,21 +1991,23 @@ void wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length)
 	int id;
 	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif;
+	int srcu_idx;
 
 	id = get_unaligned_le32(&buffer[length - 4]);
+	srcu_idx = srcu_read_lock(&wilc->srcu);
 	vif = wilc_get_vif_from_idx(wilc, id);
 	if (!vif)
-		return;
-	hif_drv = vif->hif_drv;
+		goto out;
 
+	hif_drv = vif->hif_drv;
 	if (!hif_drv) {
-		netdev_err(vif->ndev, "driver not init[%p]\n", hif_drv);
-		return;
+		PRINT_ER(vif->ndev, "driver not init[%p]\n", hif_drv);
+		goto out;
 	}
 
 	msg = wilc_alloc_work(vif, handle_rcvd_ntwrk_info, false);
 	if (IS_ERR(msg))
-		return;
+		goto out;
 
 	msg->body.net_info.frame_len = get_unaligned_le16(&buffer[6]) - 1;
 	msg->body.net_info.rssi = buffer[8];
@@ -1651,15 +2016,17 @@ void wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length)
 					  GFP_KERNEL);
 	if (!msg->body.net_info.mgmt) {
 		kfree(msg);
-		return;
+		goto out;
 	}
 
 	result = wilc_enqueue_work(msg);
 	if (result) {
-		netdev_err(vif->ndev, "%s: enqueue work failed\n", __func__);
+		PRINT_ER(vif->ndev, "message parameters (%d)\n", result);
 		kfree(msg->body.net_info.mgmt);
 		kfree(msg);
 	}
+out:
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
 }
 
 void wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length)
@@ -1669,43 +2036,47 @@ void wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length)
 	int id;
 	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif;
+	int srcu_idx;
 
 	mutex_lock(&wilc->deinit_lock);
 
 	id = get_unaligned_le32(&buffer[length - 4]);
+	srcu_idx = srcu_read_lock(&wilc->srcu);
 	vif = wilc_get_vif_from_idx(wilc, id);
-	if (!vif) {
-		mutex_unlock(&wilc->deinit_lock);
-		return;
-	}
+	if (!vif)
+		goto out;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "General asynchronous info packet received\n");
 
 	hif_drv = vif->hif_drv;
 
 	if (!hif_drv) {
-		mutex_unlock(&wilc->deinit_lock);
-		return;
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
+		goto out;
 	}
 
 	if (!hif_drv->conn_info.conn_result) {
-		netdev_err(vif->ndev, "%s: conn_result is NULL\n", __func__);
-		mutex_unlock(&wilc->deinit_lock);
-		return;
+		PRINT_ER(vif->ndev, "there is no current Connect Request\n");
+		goto out;
 	}
 
 	msg = wilc_alloc_work(vif, handle_rcvd_gnrl_async_info, false);
-	if (IS_ERR(msg)) {
-		mutex_unlock(&wilc->deinit_lock);
-		return;
-	}
+	if (IS_ERR(msg))
+		goto out;
 
 	msg->body.mac_info.status = buffer[7];
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Received MAC status= %d Reason= %d Info = %d\n",
+		   buffer[7], buffer[8], buffer[9]);
 	result = wilc_enqueue_work(msg);
 	if (result) {
-		netdev_err(vif->ndev, "%s: enqueue work failed\n", __func__);
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
 		kfree(msg);
 	}
-
+out:
 	mutex_unlock(&wilc->deinit_lock);
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
 }
 
 void wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length)
@@ -1714,40 +2085,47 @@ void wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length)
 	int id;
 	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif;
+	int srcu_idx;
 
 	id = get_unaligned_le32(&buffer[length - 4]);
+	srcu_idx = srcu_read_lock(&wilc->srcu);
 	vif = wilc_get_vif_from_idx(wilc, id);
 	if (!vif)
-		return;
-	hif_drv = vif->hif_drv;
+		goto out;
 
-	if (!hif_drv)
-		return;
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Scan notification received\n");
+
+	hif_drv = vif->hif_drv;
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
+		goto out;
+	}
 
 	if (hif_drv->usr_scan_req.scan_result) {
 		struct host_if_msg *msg;
 
 		msg = wilc_alloc_work(vif, handle_scan_complete, false);
 		if (IS_ERR(msg))
-			return;
+			goto out;
 
 		result = wilc_enqueue_work(msg);
 		if (result) {
-			netdev_err(vif->ndev, "%s: enqueue work failed\n",
-				   __func__);
+			PRINT_ER(vif->ndev, "enqueue work failed\n");
 			kfree(msg);
 		}
 	}
+out:
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
 }
 
 int wilc_remain_on_channel(struct wilc_vif *vif, u64 cookie,
 			   u32 duration, u16 chan,
-			   void (*expired)(void *, u64),
-			   void *user_arg)
+			   void (*expired)(void *, u64), void *user_arg)
 {
 	struct wilc_remain_ch roc;
 	int result;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "called\n");
 	roc.ch = chan;
 	roc.expired = expired;
 	roc.arg = user_arg;
@@ -1755,22 +2133,26 @@ int wilc_remain_on_channel(struct wilc_vif *vif, u64 cookie,
 	roc.cookie = cookie;
 	result = handle_remain_on_chan(vif, &roc);
 	if (result)
-		netdev_err(vif->ndev, "%s: failed to set remain on channel\n",
-			   __func__);
+		PRINT_ER(vif->ndev, "failed to set remain on channel\n");
 
 	return result;
 }
 
 int wilc_listen_state_expired(struct wilc_vif *vif, u64 cookie)
 {
-	if (!vif->hif_drv) {
-		netdev_err(vif->ndev, "%s: hif driver is NULL", __func__);
+	int result;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
 		return -EFAULT;
 	}
 
-	del_timer(&vif->hif_drv->remain_on_ch_timer);
+	del_timer(&hif_drv->remain_on_ch_timer);
+
+	result = handle_roc_expired(vif, cookie);
 
-	return wilc_handle_roc_expired(vif, cookie);
+	return result;
 }
 
 void wilc_frame_register(struct wilc_vif *vif, u16 frame_type, bool reg)
@@ -1785,24 +2167,29 @@ void wilc_frame_register(struct wilc_vif *vif, u16 frame_type, bool reg)
 	wid.val = (u8 *)&reg_frame;
 
 	memset(&reg_frame, 0x0, sizeof(reg_frame));
-	reg_frame.reg = reg;
+
+	if (reg)
+		reg_frame.reg = 1;
 
 	switch (frame_type) {
 	case IEEE80211_STYPE_ACTION:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "ACTION\n");
 		reg_frame.reg_id = WILC_FW_ACTION_FRM_IDX;
 		break;
 
 	case IEEE80211_STYPE_PROBE_REQ:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "PROBE REQ\n");
 		reg_frame.reg_id = WILC_FW_PROBE_REQ_IDX;
 		break;
 
 	default:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Not valid frame type\n");
 		break;
 	}
 	reg_frame.frame_type = cpu_to_le16(frame_type);
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to frame register\n");
+		PRINT_ER(vif->ndev, "Failed to frame register\n");
 }
 
 int wilc_add_beacon(struct wilc_vif *vif, u32 interval, u32 dtim_period,
@@ -1812,12 +2199,17 @@ int wilc_add_beacon(struct wilc_vif *vif, u32 interval, u32 dtim_period,
 	int result;
 	u8 *cur_byte;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting adding beacon\n");
+
 	wid.id = WID_ADD_BEACON;
 	wid.type = WID_BIN;
 	wid.size = params->head_len + params->tail_len + 16;
 	wid.val = kzalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
+	if (!wid.val) {
+		PRINT_ER(vif->ndev, "Failed to allocate buffer\n");
 		return -ENOMEM;
+	}
 
 	cur_byte = wid.val;
 	put_unaligned_le32(interval, cur_byte);
@@ -1839,7 +2231,7 @@ int wilc_add_beacon(struct wilc_vif *vif, u32 interval, u32 dtim_period,
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to send add beacon\n");
+		PRINT_ER(vif->ndev, "Failed to send add beacon\n");
 
 	kfree(wid.val);
 
@@ -1852,14 +2244,16 @@ int wilc_del_beacon(struct wilc_vif *vif)
 	struct wid wid;
 	u8 del_beacon = 0;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deleting beacon message queue params\n");
+
 	wid.id = WID_DEL_BEACON;
 	wid.type = WID_CHAR;
 	wid.size = sizeof(char);
 	wid.val = &del_beacon;
-
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to send delete beacon\n");
+		PRINT_ER(vif->ndev, "Failed to send delete beacon\n");
 
 	return result;
 }
@@ -1871,6 +2265,9 @@ int wilc_add_station(struct wilc_vif *vif, const u8 *mac,
 	int result;
 	u8 *cur_byte;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting adding station message queue params\n");
+
 	wid.id = WID_ADD_STA;
 	wid.type = WID_BIN;
 	wid.size = WILC_ADD_STA_LENGTH + params->supported_rates_len;
@@ -1879,11 +2276,11 @@ int wilc_add_station(struct wilc_vif *vif, const u8 *mac,
 		return -ENOMEM;
 
 	cur_byte = wid.val;
-	wilc_hif_pack_sta_param(cur_byte, mac, params);
+	wilc_hif_pack_sta_param(vif, cur_byte, mac, params);
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result != 0)
-		netdev_err(vif->ndev, "Failed to send add station\n");
+		PRINT_ER(vif->ndev, "Failed to send add station\n");
 
 	kfree(wid.val);
 
@@ -1895,12 +2292,17 @@ int wilc_del_station(struct wilc_vif *vif, const u8 *mac_addr)
 	struct wid wid;
 	int result;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deleting station message queue params\n");
+
 	wid.id = WID_REMOVE_STA;
 	wid.type = WID_BIN;
 	wid.size = ETH_ALEN;
 	wid.val = kzalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
+	if (!wid.val) {
+		PRINT_ER(vif->ndev, "Failed to allocate buffer\n");
 		return -ENOMEM;
+	}
 
 	if (!mac_addr)
 		eth_broadcast_addr(wid.val);
@@ -1909,7 +2311,7 @@ int wilc_del_station(struct wilc_vif *vif, const u8 *mac_addr)
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to del station\n");
+		PRINT_ER(vif->ndev, "Failed to del station\n");
 
 	kfree(wid.val);
 
@@ -1924,17 +2326,24 @@ int wilc_del_allstation(struct wilc_vif *vif, u8 mac_addr[][ETH_ALEN])
 	u8 assoc_sta = 0;
 	struct wilc_del_all_sta del_sta;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deauthenticating station message queue params\n");
 	memset(&del_sta, 0x0, sizeof(del_sta));
 	for (i = 0; i < WILC_MAX_NUM_STA; i++) {
 		if (!is_zero_ether_addr(mac_addr[i])) {
+			PRINT_INFO(vif->ndev,
+				   CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+				   mac_addr[i][0], mac_addr[i][1],
+				   mac_addr[i][2], mac_addr[i][3],
+				   mac_addr[i][4], mac_addr[i][5]);
 			assoc_sta++;
 			ether_addr_copy(del_sta.mac[i], mac_addr[i]);
 		}
 	}
-
-	if (!assoc_sta)
+	if (!assoc_sta) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "NO ASSOCIATED STAS\n");
 		return 0;
-
+	}
 	del_sta.assoc_sta = assoc_sta;
 
 	wid.id = WID_DEL_ALL_STA;
@@ -1944,7 +2353,7 @@ int wilc_del_allstation(struct wilc_vif *vif, u8 mac_addr[][ETH_ALEN])
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to send delete all station\n");
+		PRINT_ER(vif->ndev, "Failed to send delete all station\n");
 
 	return result;
 }
@@ -1956,6 +2365,9 @@ int wilc_edit_station(struct wilc_vif *vif, const u8 *mac,
 	int result;
 	u8 *cur_byte;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting editing station message queue params\n");
+
 	wid.id = WID_EDIT_STA;
 	wid.type = WID_BIN;
 	wid.size = WILC_ADD_STA_LENGTH + params->supported_rates_len;
@@ -1964,11 +2376,11 @@ int wilc_edit_station(struct wilc_vif *vif, const u8 *mac,
 		return -ENOMEM;
 
 	cur_byte = wid.val;
-	wilc_hif_pack_sta_param(cur_byte, mac, params);
+	wilc_hif_pack_sta_param(vif, cur_byte, mac, params);
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to send edit station\n");
+		PRINT_ER(vif->ndev, "Failed to send edit station\n");
 
 	kfree(wid.val);
 	return result;
@@ -1980,6 +2392,8 @@ int wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout)
 	int result;
 	s8 power_mode;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "\n\n>> Setting PS to %d <<\n\n",
+		   enabled);
 	if (enabled)
 		power_mode = WILC_FW_MIN_FAST_PS;
 	else
@@ -1990,7 +2404,7 @@ int wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout)
 	wid.size = sizeof(char);
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to send power management\n");
+		PRINT_ER(vif->ndev, "Failed to send power management\n");
 
 	return result;
 }
@@ -2001,6 +2415,8 @@ int wilc_setup_multicast_filter(struct wilc_vif *vif, u32 enabled, u32 count,
 	int result;
 	struct host_if_msg *msg;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting Multicast Filter params\n");
 	msg = wilc_alloc_work(vif, handle_set_mcast_filter, false);
 	if (IS_ERR(msg))
 		return PTR_ERR(msg);
@@ -2011,7 +2427,7 @@ int wilc_setup_multicast_filter(struct wilc_vif *vif, u32 enabled, u32 count,
 
 	result = wilc_enqueue_work(msg);
 	if (result) {
-		netdev_err(vif->ndev, "%s: enqueue work failed\n", __func__);
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
 		kfree(msg);
 	}
 	return result;
@@ -2040,3 +2456,78 @@ int wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power)
 
 	return wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);
 }
+
+static bool is_valid_gpio(struct wilc_vif *vif, u8 gpio)
+{
+	switch (vif->wilc->chip) {
+	case WILC_1000:
+		if (gpio == 0 || gpio == 1 || gpio == 4 || gpio == 6)
+			return true;
+		else
+			return false;
+	case WILC_3000:
+		if (gpio == 0 || gpio == 3 || gpio == 4 ||
+		    (gpio >= 17 && gpio <= 20))
+			return true;
+		else
+			return false;
+	default:
+		return false;
+	}
+}
+
+int wilc_set_antenna(struct wilc_vif *vif, u8 mode)
+{
+	struct wid wid;
+	int ret;
+	struct sysfs_attr_group *attr_syfs_p = &vif->wilc->attr_sysfs;
+	struct host_if_set_ant set_ant;
+
+	set_ant.mode = mode;
+
+	if (attr_syfs_p->ant_swtch_mode == ANT_SWTCH_INVALID_GPIO_CTRL) {
+		PRINT_ER(vif->ndev, "Ant switch GPIO mode is invalid.\n");
+		PRINT_ER(vif->ndev, "Set it using /sys/wilc/ant_swtch_mode\n");
+		return WILC_FAIL;
+	}
+
+	if (is_valid_gpio(vif, attr_syfs_p->antenna1)) {
+		set_ant.antenna1 = attr_syfs_p->antenna1;
+	} else {
+		PRINT_ER(vif->ndev, "Invalid GPIO %d\n", attr_syfs_p->antenna1);
+		return WILC_FAIL;
+	}
+
+	if (attr_syfs_p->ant_swtch_mode == ANT_SWTCH_DUAL_GPIO_CTRL) {
+		if ((attr_syfs_p->antenna2 != attr_syfs_p->antenna1) &&
+		    is_valid_gpio(vif, attr_syfs_p->antenna2)) {
+			set_ant.antenna2 = attr_syfs_p->antenna2;
+		} else {
+			PRINT_ER(vif->ndev, "Invalid GPIO %d\n",
+				 attr_syfs_p->antenna2);
+			return WILC_FAIL;
+		}
+	}
+
+	set_ant.gpio_mode = attr_syfs_p->ant_swtch_mode;
+
+	wid.id = WID_ANTENNA_SELECTION;
+	wid.type = WID_BIN;
+	wid.val = (u8 *)&set_ant;
+	wid.size = sizeof(struct host_if_set_ant);
+	if (attr_syfs_p->ant_swtch_mode == ANT_SWTCH_SNGL_GPIO_CTRL)
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "set antenna %d on GPIO %d\n", set_ant.mode,
+			   set_ant.antenna1);
+	else if (attr_syfs_p->ant_swtch_mode == ANT_SWTCH_DUAL_GPIO_CTRL)
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "set antenna %d on GPIOs %d and %d\n",
+			   set_ant.mode, set_ant.antenna1,
+			   set_ant.antenna2);
+
+	ret = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set antenna mode\n");
+
+	return ret;
+}
diff --git a/drivers/staging/wilc1000/wilc_hif.h b/drivers/staging/wilc1000/hif.h
similarity index 80%
rename from drivers/staging/wilc1000/wilc_hif.h
rename to drivers/staging/wilc1000/hif.h
index ac5fe57f8..052ddfe4a 100644
--- a/drivers/staging/wilc1000/wilc_hif.h
+++ b/drivers/staging/wilc1000/hif.h
@@ -1,30 +1,28 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
  * All rights reserved.
  */
 
-#ifndef HOST_INT_H
-#define HOST_INT_H
+#ifndef WILC_HIF_H
+#define WILC_HIF_H
 #include <linux/ieee80211.h>
-#include "wilc_wlan_if.h"
+#include "wlan_if.h"
 
 enum {
 	WILC_IDLE_MODE = 0x0,
 	WILC_AP_MODE = 0x1,
 	WILC_STATION_MODE = 0x2,
 	WILC_GO_MODE = 0x3,
-	WILC_CLIENT_MODE = 0x4
+	WILC_CLIENT_MODE = 0x4,
+	WILC_MONITOR_MODE = 0x5
 };
 
-#define WILC_MAX_NUM_STA			9
-#define WILC_MAX_NUM_SCANNED_CH			14
 #define WILC_MAX_NUM_PROBED_SSID		10
 
 #define WILC_TX_MIC_KEY_LEN			8
 #define WILC_RX_MIC_KEY_LEN			8
 
-#define WILC_MAX_NUM_PMKIDS			16
 #define WILC_ADD_STA_LENGTH			40
 #define WILC_NUM_CONCURRENT_IFC			2
 
@@ -34,12 +32,7 @@ enum {
 };
 
 #define WILC_MAX_ASSOC_RESP_FRAME_SIZE   256
-
-struct assoc_resp {
-	__le16 capab_info;
-	__le16 status_code;
-	__le16 aid;
-} __packed;
+extern uint32_t cfg_packet_timeout;
 
 struct rf_info {
 	u8 link_speed;
@@ -59,16 +52,6 @@ enum host_if_state {
 	HOST_IF_FORCE_32BIT		= 0xFFFFFFFF
 };
 
-struct wilc_pmkid {
-	u8 bssid[ETH_ALEN];
-	u8 pmkid[WLAN_PMKID_LEN];
-} __packed;
-
-struct wilc_pmkid_attr {
-	u8 numpmkid;
-	struct wilc_pmkid pmkidlist[WILC_MAX_NUM_PMKIDS];
-} __packed;
-
 struct cfg_param_attr {
 	u32 flag;
 	u16 short_retry_limit;
@@ -92,14 +75,15 @@ enum scan_event {
 };
 
 enum conn_event {
-	CONN_DISCONN_EVENT_CONN_RESP		= 0,
-	CONN_DISCONN_EVENT_DISCONN_NOTIF	= 1,
-	CONN_DISCONN_EVENT_FORCE_32BIT		= 0xFFFFFFFF
+	EVENT_CONN_RESP		= 0,
+	EVENT_DISCONN_NOTIF	= 1,
+	EVENT_FORCE_32BIT		= 0xFFFFFFFF
 };
 
 enum {
 	WILC_HIF_SDIO = 0,
-	WILC_HIF_SPI = BIT(0)
+	WILC_HIF_SPI = BIT(0),
+	WILC_HIF_SDIO_GPIO_IRQ = BIT(1)
 };
 
 enum {
@@ -115,6 +99,8 @@ struct wilc_rcvd_net_info {
 	struct ieee80211_mgmt *mgmt;
 };
 
+typedef void (*wilc_remain_on_chan_ready)(void *);
+
 struct wilc_user_scan_req {
 	void (*scan_result)(enum scan_event evt,
 			    struct wilc_rcvd_net_info *info, void *priv);
@@ -132,7 +118,7 @@ struct wilc_conn_info {
 	u8 *resp_ies;
 	u16 resp_ies_len;
 	u16 status;
-	void (*conn_result)(enum conn_event evt, u8 status, void *priv_data);
+	void (*conn_result)(enum conn_event evt, u8 status, void *priv);
 	void *arg;
 	void *param;
 };
@@ -142,10 +128,9 @@ struct wilc_remain_ch {
 	u32 duration;
 	void (*expired)(void *priv, u64 cookie);
 	void *arg;
-	u32 cookie;
+	u64 cookie;
 };
 
-struct wilc;
 struct host_if_drv {
 	struct wilc_user_scan_req usr_scan_req;
 	struct wilc_conn_info conn_info;
@@ -155,6 +140,10 @@ struct host_if_drv {
 	enum host_if_state hif_state;
 
 	u8 assoc_bssid[ETH_ALEN];
+	struct completion comp_test_key_block;
+	struct completion comp_test_disconn_block;
+	struct completion comp_get_rssi;
+	struct completion comp_inactive_time;
 
 	struct timer_list scan_timer;
 	struct wilc_vif *scan_timer_vif;
@@ -170,6 +159,13 @@ struct host_if_drv {
 };
 
 struct wilc_vif;
+
+signed int wilc_send_buffered_eap(struct wilc_vif *vif,
+				  void (*deliver_to_stack)(struct wilc_vif *,
+							   u8 *, u32, u32, u8),
+				  void (*eap_buf_param)(void *), u8 *buff,
+				  unsigned int size, unsigned int pkt_offset,
+				  void *user_arg);
 int wilc_remove_wep_key(struct wilc_vif *vif, u8 index);
 int wilc_set_wep_default_keyid(struct wilc_vif *vif, u8 index);
 int wilc_add_wep_key_bss_sta(struct wilc_vif *vif, const u8 *key, u8 len,
@@ -187,6 +183,7 @@ int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
 		    u8 cipher_mode);
 int wilc_set_pmkid_info(struct wilc_vif *vif, struct wilc_pmkid_attr *pmkid);
 int wilc_get_mac_address(struct wilc_vif *vif, u8 *mac_addr);
+int wilc_set_mac_address(struct wilc_vif *vif, u8 *mac_addr);
 int wilc_set_join_req(struct wilc_vif *vif, u8 *bssid, const u8 *ies,
 		      size_t ies_len);
 int wilc_disconnect(struct wilc_vif *vif);
@@ -215,8 +212,7 @@ int wilc_setup_multicast_filter(struct wilc_vif *vif, u32 enabled, u32 count,
 				u8 *mc_list);
 int wilc_remain_on_channel(struct wilc_vif *vif, u64 cookie,
 			   u32 duration, u16 chan,
-			   void (*expired)(void *, u64),
-			   void *user_arg);
+			   void (*expired)(void *, u64), void *user_arg);
 int wilc_listen_state_expired(struct wilc_vif *vif, u64 cookie);
 void wilc_frame_register(struct wilc_vif *vif, u16 frame_type, bool reg);
 int wilc_set_operation_mode(struct wilc_vif *vif, int index, u8 mode,
@@ -225,9 +221,21 @@ int wilc_get_statistics(struct wilc_vif *vif, struct rf_info *stats);
 int wilc_get_vif_idx(struct wilc_vif *vif);
 int wilc_set_tx_power(struct wilc_vif *vif, u8 tx_power);
 int wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power);
+/* 0 select antenna 1 , 2 select antenna mode , 2 allow the firmware to choose
+ * the best antenna
+ */
+int wilc_set_antenna(struct wilc_vif *vif, u8 mode);
+
+void wilc_set_wowlan_trigger(struct wilc_vif *vif, u8 wowlan_trigger);
+
+extern u8 wilc_initialized;
+s32 handle_scan_done(struct wilc_vif *vif, enum scan_event evt);
 void wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length);
 void wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length);
 void wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length);
 void *wilc_parse_join_bss_param(struct cfg80211_bss *bss,
 				struct cfg80211_crypto_settings *crypto);
+void handle_connect_cancel(struct wilc_vif *vif);
+int wilc_of_parse_power_pins(struct wilc *wilc);
+void wilc_wlan_power(struct wilc *wilc, bool on);
 #endif
diff --git a/drivers/staging/wilc1000/microchip,wilc1000,sdio.txt b/drivers/staging/wilc1000/microchip,wilc1000,sdio.txt
deleted file mode 100644
index da5235950..000000000
--- a/drivers/staging/wilc1000/microchip,wilc1000,sdio.txt
+++ /dev/null
@@ -1,38 +0,0 @@
-* Microchip WILC wireless SDIO device
-
-The wilc1000 chips can be connected via SDIO. The node is used to specifiy
-child node to the SDIO controller that connects the device to the system.
-
-Required properties:
-- compatible	:	Should be "microchip,wilc1000-spi"
-- irq-gpios	:	Connect to a host IRQ
-- reg		:	Slot ID used in the controller
-
-Optional:
-- bus-width	:	Number of data lines wired up the slot. Default 1 bit.
-- rtc_clk	:	Clock connected on the rtc clock line. Must be assigned
-			a frequency with assigned-clocks property, and must be
-			connected to a clock provider.
-
-Examples:
-mmc1: mmc@fc000000 {
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_mmc1_clk_cmd_dat0 &pinctrl_mmc1_dat1_3>;
-		non-removable;
-		vmmc-supply = <&vcc_mmc1_reg>;
-		vqmmc-supply = <&vcc_3v3_reg>;
-		status = "okay";
-
-		wilc_sdio@0 {
-			compatible = "microchip,wilc1000-sdio";
-			irq-gpios = <&pioC 27 0>;
-			clocks = <&pck1>;
-			clock-names = "rtc_clk";
-			assigned-clocks = <&pck1>;
-			assigned-clock-rates = <32768>;
-			status = "okay";
-			reg = <0>;
-			bus-width = <4>;
-		}
-	};
-}
diff --git a/drivers/staging/wilc1000/microchip,wilc1000,spi.txt b/drivers/staging/wilc1000/microchip,wilc1000,spi.txt
deleted file mode 100644
index 34236932d..000000000
--- a/drivers/staging/wilc1000/microchip,wilc1000,spi.txt
+++ /dev/null
@@ -1,34 +0,0 @@
-* Microchip WILC wireless SPI device
-
-The wilc1000 chips can be connected via SPI. This document describes
-the binding for the SPI connected module.
-
-Required properties:
-- compatible		: Should be "microchip,wilc1000-spi"
-- spi-max-frequency	: Maximum SPI clocking speed of device in Hz
-- reg			: Chip select address of device
-- irq-gpios		: Connect to a host IRQ
-
-Optional:
-- rtc_clk	:	Clock connected on the rtc clock line. Must be assigned
-			a frequency with assigned-clocks property, and must be
-			connected to a clock provider.
-
-Examples:
-
-spi1: spi@fc018000 {
-		cs-gpios = <&pioB 21 0>;
-		status = "okay";
-
-		wilc_spi@0 {
-			compatible = "microchip,wilc1000-spi";
-			spi-max-frequency = <48000000>;
-			reg = <0>;
-			irq-gpios = <&pioC 27 0>;
-			clocks = <&pck1>;
-			clock-names = "rtc_clk";
-			assigned-clocks = <&pck1>;
-			assigned-clock-rates = <32768>;
-			status = "okay";
-		};
-};
diff --git a/drivers/staging/wilc1000/microchip,wilc1000.yaml b/drivers/staging/wilc1000/microchip,wilc1000.yaml
new file mode 100644
index 000000000..2c320eb2a
--- /dev/null
+++ b/drivers/staging/wilc1000/microchip,wilc1000.yaml
@@ -0,0 +1,71 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/net/wireless/microchip,wilc1000.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip WILC wireless devicetree bindings
+
+maintainers:
+  - Adham Abozaeid <adham.abozaeid@microchip.com>
+  - Ajay Singh <ajay.kathat@microchip.com>
+
+description:
+  The wilc1000 chips can be connected via SPI or SDIO. This document
+  describes the binding to connect wilc devices.
+
+properties:
+  compatible:
+    const: microchip,wilc1000
+
+  spi-max-frequency: true
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    description: phandle to the clock connected on rtc clock line.
+    maxItems: 1
+
+  clock-names:
+    const: rtc
+
+required:
+  - compatible
+  - interrupts
+
+examples:
+  - |
+    spi {
+      #address-cells = <1>;
+      #size-cells = <0>;
+      wifi@0 {
+        compatible = "microchip,wilc1000";
+        spi-max-frequency = <48000000>;
+        reg = <0>;
+        interrupt-parent = <&pioC>;
+        interrupts = <27 0>;
+        clocks = <&pck1>;
+        clock-names = "rtc";
+      };
+    };
+
+  - |
+    mmc {
+      #address-cells = <1>;
+      #size-cells = <0>;
+      pinctrl-names = "default";
+      pinctrl-0 = <&pinctrl_mmc1_clk_cmd_dat0 &pinctrl_mmc1_dat1_3>;
+      non-removable;
+      vmmc-supply = <&vcc_mmc1_reg>;
+      vqmmc-supply = <&vcc_3v3_reg>;
+      bus-width = <4>;
+      wifi@0 {
+        compatible = "microchip,wilc1000";
+        reg = <0>;
+        interrupt-parent = <&pioC>;
+        interrupts = <27 0>;
+        clocks = <&pck1>;
+        clock-names = "rtc";
+      };
+    };
diff --git a/drivers/staging/wilc1000/wilc_mon.c b/drivers/staging/wilc1000/mon.c
similarity index 52%
rename from drivers/staging/wilc1000/wilc_mon.c
rename to drivers/staging/wilc1000/mon.c
index 017e8e913..9655edc88 100644
--- a/drivers/staging/wilc1000/wilc_mon.c
+++ b/drivers/staging/wilc1000/mon.c
@@ -4,14 +4,17 @@
  * All rights reserved.
  */
 
-#include "wilc_wfi_cfgoperations.h"
+#include <linux/etherdevice.h>
 
-struct wilc_wfi_radiotap_hdr {
+#include "netdev.h"
+#include "cfg80211.h"
+
+struct wfi_rtap_hdr {
 	struct ieee80211_radiotap_header hdr;
 	u8 rate;
 } __packed;
 
-struct wilc_wfi_radiotap_cb_hdr {
+struct wfi_rtap_cb_hdr {
 	struct ieee80211_radiotap_header hdr;
 	u8 rate;
 	u8 dump;
@@ -21,18 +24,65 @@ struct wilc_wfi_radiotap_cb_hdr {
 #define TX_RADIOTAP_PRESENT ((1 << IEEE80211_RADIOTAP_RATE) |	\
 			     (1 << IEEE80211_RADIOTAP_TX_FLAGS))
 
+void wilc_wfi_handle_monitor_rx(struct wilc *wilc, u8 *buff, u32 size)
+{
+	struct wilc_vif *vif = NULL;
+	struct sk_buff *skb = NULL;
+	struct wfi_rtap_hdr *hdr;
+
+	vif = wilc_get_vif_from_type(wilc, WILC_MONITOR_MODE);
+	if (!vif) {
+		PRINT_D(vif->ndev, HOSTAPD_DBG, "Monitor interface not up\n");
+		return;
+	}
+
+	skb = dev_alloc_skb(size + sizeof(*hdr));
+	if (!skb) {
+		PRINT_D(vif->ndev, HOSTAPD_DBG,
+			"Monitor if: No memory to allocate skb");
+		return;
+	}
+#if KERNEL_VERSION(4, 13, 0) <= LINUX_VERSION_CODE
+	skb_put_data(skb, buff, size);
+	hdr = skb_push(skb, sizeof(*hdr));
+#else
+	memcpy(skb_put(skb, size), buff, size);
+	hdr = (struct wfi_rtap_hdr *)skb_push(skb, sizeof(*hdr));
+#endif
+	memset(hdr, 0, sizeof(*hdr));
+	hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
+	hdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));
+	PRINT_D(vif->ndev, HOSTAPD_DBG,
+		"Radiotap len %d\n", hdr->hdr.it_len);
+	hdr->hdr.it_present = cpu_to_le32
+			(1 << IEEE80211_RADIOTAP_RATE); /* | */
+	PRINT_D(vif->ndev, HOSTAPD_DBG, "Presentflags %d\n",
+		hdr->hdr.it_present);
+	hdr->rate = 5; /* txrate->bitrate / 5; */
+	skb->dev = vif->ndev;
+	skb_reset_mac_header(skb);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(ETH_P_802_2);
+	memset(skb->cb, 0, sizeof(skb->cb));
+	netif_rx(skb);
+}
+
 void wilc_wfi_monitor_rx(struct net_device *mon_dev, u8 *buff, u32 size)
 {
 	u32 header, pkt_offset;
 	struct sk_buff *skb = NULL;
-	struct wilc_wfi_radiotap_hdr *hdr;
-	struct wilc_wfi_radiotap_cb_hdr *cb_hdr;
+	struct wfi_rtap_hdr *hdr;
+	struct wfi_rtap_cb_hdr *cb_hdr;
 
 	if (!mon_dev)
 		return;
 
-	if (!netif_running(mon_dev))
+	if (!netif_running(mon_dev)) {
+		PRINT_D(mon_dev, HOSTAPD_DBG,
+			"Monitor interface already RUNNING\n");
 		return;
+	}
 
 	/* Get WILC header */
 	header = get_unaligned_le32(buff - HOST_HDR_OFFSET);
@@ -40,18 +90,26 @@ void wilc_wfi_monitor_rx(struct net_device *mon_dev, u8 *buff, u32 size)
 	 * The packet offset field contain info about what type of management
 	 * the frame we are dealing with and ack status
 	 */
-	pkt_offset = GET_PKT_OFFSET(header);
+	pkt_offset = FIELD_GET(WILC_PKT_HDR_OFFSET_FIELD, header);
 
 	if (pkt_offset & IS_MANAGMEMENT_CALLBACK) {
 		/* hostapd callback mgmt frame */
 
 		skb = dev_alloc_skb(size + sizeof(*cb_hdr));
-		if (!skb)
+		if (!skb) {
+			PRINT_D(mon_dev, HOSTAPD_DBG,
+				"Monitor if : No memory to allocate skb");
 			return;
-
+		}
+	#if KERNEL_VERSION(4, 13, 0) <= LINUX_VERSION_CODE
 		skb_put_data(skb, buff, size);
 
 		cb_hdr = skb_push(skb, sizeof(*cb_hdr));
+	#else
+		memcpy(skb_put(skb, size), buff, size);
+		cb_hdr = (struct wfi_rtap_cb_hdr *)skb_push(skb,
+							    sizeof(*cb_hdr));
+	#endif
 		memset(cb_hdr, 0, sizeof(*cb_hdr));
 
 		cb_hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
@@ -72,16 +130,28 @@ void wilc_wfi_monitor_rx(struct net_device *mon_dev, u8 *buff, u32 size)
 	} else {
 		skb = dev_alloc_skb(size + sizeof(*hdr));
 
-		if (!skb)
+		if (!skb) {
+			PRINT_D(mon_dev, HOSTAPD_DBG,
+				"Monitor if : No memory to allocate skb");
 			return;
-
+		}
+	#if KERNEL_VERSION(4, 13, 0) <= LINUX_VERSION_CODE
 		skb_put_data(skb, buff, size);
 		hdr = skb_push(skb, sizeof(*hdr));
-		memset(hdr, 0, sizeof(struct wilc_wfi_radiotap_hdr));
+	#else
+		memcpy(skb_put(skb, size), buff, size);
+		hdr = (struct wfi_rtap_hdr *)skb_push(skb,
+							       sizeof(*hdr));
+	#endif
+		memset(hdr, 0, sizeof(*hdr));
 		hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
 		hdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));
+		PRINT_D(mon_dev, HOSTAPD_DBG,
+			"Radiotap len %d\n", hdr->hdr.it_len);
 		hdr->hdr.it_present = cpu_to_le32
-				(1 << IEEE80211_RADIOTAP_RATE);
+				(1 << IEEE80211_RADIOTAP_RATE); /* | */
+		PRINT_D(mon_dev, HOSTAPD_DBG, "Presentflags %d\n",
+			hdr->hdr.it_present);
 		hdr->rate = 5;
 	}
 
@@ -103,6 +173,16 @@ struct tx_complete_mon_data {
 static void mgmt_tx_complete(void *priv, int status)
 {
 	struct tx_complete_mon_data *pv_data = priv;
+	u8 *buf =  pv_data->buff;
+
+	if (status == 1) {
+		if (buf[0] == 0x10 || buf[0] == 0xb0)
+			pr_info("Packet sent Size = %d Add = %p.\n",
+				pv_data->size, pv_data->buff);
+	} else {
+		pr_info("Couldn't send packet Size = %d Add = %p.\n",
+			pv_data->size, pv_data->buff);
+	}
 	/*
 	 * in case of fully hosting mode, the freeing will be done
 	 * in response to the cfg packet
@@ -116,13 +196,18 @@ static int mon_mgmt_tx(struct net_device *dev, const u8 *buf, size_t len)
 {
 	struct tx_complete_mon_data *mgmt_tx = NULL;
 
-	if (!dev)
+	if (!dev) {
+		PRINT_ER(dev, "ERROR: dev == NULL\n");
 		return -EFAULT;
+	}
 
 	netif_stop_queue(dev);
 	mgmt_tx = kmalloc(sizeof(*mgmt_tx), GFP_ATOMIC);
-	if (!mgmt_tx)
+	if (!mgmt_tx) {
+		PRINT_ER(dev,
+			 "Failed to allocate memory for mgmt_tx structure\n");
 		return -ENOMEM;
+	}
 
 	mgmt_tx->buff = kmemdup(buf, len, GFP_ATOMIC);
 	if (!mgmt_tx->buff) {
@@ -132,7 +217,7 @@ static int mon_mgmt_tx(struct net_device *dev, const u8 *buf, size_t len)
 
 	mgmt_tx->size = len;
 
-	wilc_wlan_txq_add_mgmt_pkt(dev, mgmt_tx, mgmt_tx->buff, mgmt_tx->size,
+	txq_add_mgmt_pkt(dev, mgmt_tx, mgmt_tx->buff, mgmt_tx->size,
 				   mgmt_tx_complete);
 
 	netif_wake_queue(dev);
@@ -144,53 +229,28 @@ static netdev_tx_t wilc_wfi_mon_xmit(struct sk_buff *skb,
 {
 	u32 rtap_len, ret = 0;
 	struct wilc_wfi_mon_priv  *mon_priv;
-	struct sk_buff *skb2;
-	struct wilc_wfi_radiotap_cb_hdr *cb_hdr;
 	u8 srcadd[ETH_ALEN];
 	u8 bssid[ETH_ALEN];
 
 	mon_priv = netdev_priv(dev);
-	if (!mon_priv)
+	if (!mon_priv) {
+		PRINT_ER(dev, "Monitor interface private structure is NULL\n");
 		return -EFAULT;
-
+	}
 	rtap_len = ieee80211_get_radiotap_len(skb->data);
-	if (skb->len < rtap_len)
+	if (skb->len < rtap_len) {
+		PRINT_ER(dev, "Error in radiotap header\n");
 		return -1;
+	}
 
 	skb_pull(skb, rtap_len);
 
-	if (skb->data[0] == 0xc0 && is_broadcast_ether_addr(&skb->data[4])) {
-		skb2 = dev_alloc_skb(skb->len + sizeof(*cb_hdr));
-		if (!skb2)
-			return -ENOMEM;
-
-		skb_put_data(skb2, skb->data, skb->len);
-
-		cb_hdr = skb_push(skb2, sizeof(*cb_hdr));
-		memset(cb_hdr, 0, sizeof(struct wilc_wfi_radiotap_cb_hdr));
-
-		cb_hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
-
-		cb_hdr->hdr.it_len = cpu_to_le16(sizeof(*cb_hdr));
-
-		cb_hdr->hdr.it_present = cpu_to_le32(TX_RADIOTAP_PRESENT);
-
-		cb_hdr->rate = 5;
-		cb_hdr->tx_flags = 0x0004;
-
-		skb2->dev = dev;
-		skb_reset_mac_header(skb2);
-		skb2->ip_summed = CHECKSUM_UNNECESSARY;
-		skb2->pkt_type = PACKET_OTHERHOST;
-		skb2->protocol = htons(ETH_P_802_2);
-		memset(skb2->cb, 0, sizeof(skb2->cb));
-
-		netif_rx(skb2);
-
-		return 0;
-	}
 	skb->dev = mon_priv->real_ndev;
 
+	PRINT_D(dev, HOSTAPD_DBG, "Skipping the radiotap header\n");
+	PRINT_D(dev, HOSTAPD_DBG, "SKB netdevice name = %s\n", skb->dev->name);
+	PRINT_D(dev, HOSTAPD_DBG, "MONITOR real dev name = %s\n",
+		mon_priv->real_ndev->name);
 	ether_addr_copy(srcadd, &skb->data[10]);
 	ether_addr_copy(bssid, &skb->data[16]);
 	/*
@@ -200,7 +260,7 @@ static netdev_tx_t wilc_wfi_mon_xmit(struct sk_buff *skb,
 	if (!(memcmp(srcadd, bssid, 6))) {
 		ret = mon_mgmt_tx(mon_priv->real_ndev, skb->data, skb->len);
 		if (ret)
-			netdev_err(dev, "fail to mgmt tx\n");
+			PRINT_ER(dev, "fail to mgmt tx\n");
 		dev_kfree_skb(skb);
 	} else {
 		ret = wilc_mac_xmit(skb, mon_priv->real_ndev);
@@ -220,22 +280,25 @@ struct net_device *wilc_wfi_init_mon_interface(struct wilc *wl,
 {
 	struct wilc_wfi_mon_priv *priv;
 
-	/*If monitor interface is already initialized, return it*/
+	/* If monitor interface is already initialized, return it */
 	if (wl->monitor_dev)
 		return wl->monitor_dev;
 
 	wl->monitor_dev = alloc_etherdev(sizeof(struct wilc_wfi_mon_priv));
-	if (!wl->monitor_dev)
+	if (!wl->monitor_dev) {
+		PRINT_ER(real_dev, "failed to allocate memory\n");
 		return NULL;
-
+	}
 	wl->monitor_dev->type = ARPHRD_IEEE80211_RADIOTAP;
-	strncpy(wl->monitor_dev->name, name, IFNAMSIZ);
-	wl->monitor_dev->name[IFNAMSIZ - 1] = 0;
+	strlcpy(wl->monitor_dev->name, name, IFNAMSIZ);
 	wl->monitor_dev->netdev_ops = &wilc_wfi_netdev_ops;
+#if KERNEL_VERSION(4, 11, 9) <= LINUX_VERSION_CODE
 	wl->monitor_dev->needs_free_netdev = true;
-
+#else
+	wl->monitor_dev->destructor = free_netdev;
+#endif
 	if (register_netdevice(wl->monitor_dev)) {
-		netdev_err(real_dev, "register_netdevice failed\n");
+		PRINT_ER(real_dev, "register_netdevice failed\n");
 		free_netdev(wl->monitor_dev);
 		return NULL;
 	}
@@ -251,9 +314,14 @@ void wilc_wfi_deinit_mon_interface(struct wilc *wl, bool rtnl_locked)
 	if (!wl->monitor_dev)
 		return;
 
+	PRINT_INFO(wl->monitor_dev, HOSTAPD_DBG,
+		   "In Deinit monitor interface\n");
+	PRINT_INFO(wl->monitor_dev, HOSTAPD_DBG, "Unregister monitor netdev\n");
 	if (rtnl_locked)
 		unregister_netdevice(wl->monitor_dev);
 	else
 		unregister_netdev(wl->monitor_dev);
+	PRINT_INFO(wl->monitor_dev, HOSTAPD_DBG,
+		   "Deinit monitor interface done\n");
 	wl->monitor_dev = NULL;
 }
diff --git a/drivers/staging/wilc1000/netdev.c b/drivers/staging/wilc1000/netdev.c
new file mode 100644
index 000000000..3e7aff7af
--- /dev/null
+++ b/drivers/staging/wilc1000/netdev.c
@@ -0,0 +1,1351 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/irq.h>
+#include <linux/kthread.h>
+#include <linux/firmware.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/interrupt.h>
+#include <net/ip.h>
+#include <linux/module.h>
+
+#include "netdev.h"
+#include "cfg80211.h"
+
+#define WILC_MULTICAST_TABLE_SIZE	8
+
+static int wilc_mac_open(struct net_device *ndev);
+static int wilc_mac_close(struct net_device *ndev);
+
+static int debug_running;
+static int recovery_on;
+int wait_for_recovery;
+static int debug_thread(void *arg)
+{
+	struct wilc *wl = arg;
+	struct wilc_vif *vif;
+	signed long timeout;
+	struct host_if_drv *hif_drv;
+	int i = 0;
+
+	complete(&wl->debug_thread_started);
+
+	while (1) {
+		int srcu_idx;
+		int ret;
+
+		if (!wl->initialized && !kthread_should_stop()) {
+			msleep(1000);
+			continue;
+		} else if (!wl->initialized) {
+			break;
+		}
+		ret = wait_for_completion_interruptible_timeout(
+			&wl->debug_thread_started, msecs_to_jiffies(6000));
+		if (ret > 0) {
+			while (!kthread_should_stop())
+				schedule();
+			pr_info("Exit debug thread\n");
+			return 0;
+		}
+		if (!debug_running || ret == -ERESTARTSYS)
+			continue;
+
+		pr_debug("%s *** Debug Thread Running ***cnt[%d]\n", __func__,
+			 cfg_packet_timeout);
+
+		if (cfg_packet_timeout < 5)
+			continue;
+
+		pr_info("%s <Recover>\n", __func__);
+		cfg_packet_timeout = 0;
+		timeout = 10;
+		recovery_on = 1;
+		wait_for_recovery = 1;
+
+		srcu_idx = srcu_read_lock(&wl->srcu);
+		list_for_each_entry_rcu(vif, &wl->vif_list, list) {
+			/* close the interface only if it was open */
+			if (vif->mac_opened) {
+				wilc_mac_close(vif->ndev);
+				vif->restart = 1;
+			}
+		}
+		//TODO://Need to find way to call them in reverse
+		i = 0;
+		list_for_each_entry_rcu(vif, &wl->vif_list, list) {
+			struct wilc_conn_info *info;
+
+			/* Only open the interface manually closed earlier */
+			if (!vif->restart)
+				continue;
+			i++;
+			hif_drv = vif->priv.hif_drv;
+			while (wilc_mac_open(vif->ndev) && --timeout)
+				msleep(100);
+
+			if (timeout == 0)
+				PRINT_WRN(vif->ndev, GENERIC_DBG,
+					  "Couldn't restart ifc %d\n", i);
+
+			if (hif_drv->hif_state == HOST_IF_CONNECTED) {
+				info = &hif_drv->conn_info;
+				PRINT_INFO(vif->ndev, GENERIC_DBG,
+					   "notify the user with the Disconnection\n");
+				if (hif_drv->usr_scan_req.scan_result) {
+					PRINT_INFO(vif->ndev, GENERIC_DBG,
+						   "Abort the running OBSS Scan\n");
+					del_timer(&hif_drv->scan_timer);
+					handle_scan_done(vif,
+							 SCAN_EVENT_ABORTED);
+				}
+				if (info->conn_result) {
+					info->conn_result(EVENT_DISCONN_NOTIF,
+							  0, info->arg);
+				} else {
+					PRINT_ER(vif->ndev,
+						 "Connect result NULL\n");
+				}
+				eth_zero_addr(hif_drv->assoc_bssid);
+				info->req_ies_len = 0;
+				kfree(info->req_ies);
+				info->req_ies = NULL;
+				hif_drv->hif_state = HOST_IF_IDLE;
+			}
+			vif->restart = 0;
+		}
+		srcu_read_unlock(&wl->srcu, srcu_idx);
+		recovery_on = 0;
+	}
+	return 0;
+}
+
+static void wilc_disable_irq(struct wilc *wilc, int wait)
+{
+	if (wait) {
+		pr_info("%s Disabling IRQ ...\n", __func__);
+		disable_irq(wilc->dev_irq_num);
+	} else {
+		pr_info("%s Disabling IRQ ...\n", __func__);
+		disable_irq_nosync(wilc->dev_irq_num);
+	}
+}
+
+static irqreturn_t host_wakeup_isr(int irq, void *user_data)
+{
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t isr_uh_routine(int irq, void *user_data)
+{
+	struct wilc *wilc = (struct wilc *)user_data;
+
+	if (wilc->close) {
+		pr_err("%s: Can't handle UH interrupt\n", __func__);
+		return IRQ_HANDLED;
+	}
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t isr_bh_routine(int irq, void *userdata)
+{
+	struct wilc *wilc = (struct wilc *)userdata;
+
+	if (wilc->close) {
+		pr_err("%s: Can't handle BH interrupt\n", __func__);
+		return IRQ_HANDLED;
+	}
+
+	wilc_handle_isr(wilc);
+
+	return IRQ_HANDLED;
+}
+
+static int init_irq(struct net_device *dev)
+{
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wl = vif->wilc;
+
+	if (wl->dev_irq_num <= 0)
+		return 0;
+
+	if (wl->io_type == WILC_HIF_SPI ||
+		wl->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		if (request_threaded_irq(wl->dev_irq_num, isr_uh_routine,
+					 isr_bh_routine, IRQF_TRIGGER_FALLING |
+							IRQF_NO_SUSPEND,
+					 "WILC_IRQ", wl) < 0) {
+			PRINT_ER(dev, "Failed to request IRQ [%d]\n",
+				 wl->dev_irq_num);
+			return -EINVAL;
+		}
+	} else {
+		if (request_irq(wl->dev_irq_num, host_wakeup_isr,
+					     IRQF_TRIGGER_FALLING |
+					     IRQF_NO_SUSPEND,
+					     "WILC_IRQ", wl) < 0) {
+			PRINT_ER(dev, "Failed to request IRQ [%d]\n",
+				 wl->dev_irq_num);
+			return -EINVAL;
+		}
+	}
+
+	PRINT_INFO(dev, GENERIC_DBG, "IRQ request succeeded IRQ-NUM= %d\n",
+		   wl->dev_irq_num);
+	enable_irq_wake(wl->dev_irq_num);
+	return 0;
+}
+
+static void deinit_irq(struct net_device *dev)
+{
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+
+	/* Deinitialize IRQ */
+	if (wilc->dev_irq_num)
+		free_irq(wilc->dev_irq_num, wilc);
+}
+
+void wilc_mac_indicate(struct wilc *wilc)
+{
+	s8 status;
+
+	cfg_get_val(wilc, WID_STATUS, &status, 1);
+	if (wilc->mac_status == WILC_MAC_STATUS_INIT) {
+		wilc->mac_status = status;
+		complete(&wilc->sync_event);
+	} else {
+		wilc->mac_status = status;
+	}
+}
+
+void wilc_frmw_to_host(struct wilc_vif *vif, u8 *buff, u32 size,
+		       u32 pkt_offset, u8 status)
+{
+	unsigned int frame_len = 0;
+	int stats;
+	unsigned char *buff_to_send = NULL;
+	struct sk_buff *skb;
+	struct wilc_priv *priv;
+	u8 null_bssid[ETH_ALEN] = {0};
+
+	buff += pkt_offset;
+	priv = &vif->priv;
+
+	if (size == 0) {
+		PRINT_ER(vif->ndev,
+			 "Discard sending packet with len = %d\n", size);
+		return;
+	}
+
+	frame_len = size;
+	buff_to_send = buff;
+
+	if (status == PKT_STATUS_NEW && buff_to_send[12] == 0x88 &&
+	   buff_to_send[13] == 0x8e &&
+	   (vif->iftype == WILC_STATION_MODE ||
+	    vif->iftype == WILC_CLIENT_MODE) &&
+	   ether_addr_equal_unaligned(priv->associated_bss, null_bssid)) {
+		if (!priv->buffered_eap) {
+			priv->buffered_eap = kmalloc(sizeof(struct
+							    wilc_buffered_eap),
+						     GFP_ATOMIC);
+			if (priv->buffered_eap) {
+				priv->buffered_eap->buff = NULL;
+				priv->buffered_eap->size = 0;
+				priv->buffered_eap->pkt_offset = 0;
+			} else {
+				PRINT_ER(vif->ndev,
+					 "failed to alloc buffered_eap\n");
+				return;
+			}
+		} else {
+			kfree(priv->buffered_eap->buff);
+		}
+		priv->buffered_eap->buff = kmalloc(size + pkt_offset,
+						   GFP_ATOMIC);
+		priv->buffered_eap->size = size;
+		priv->buffered_eap->pkt_offset = pkt_offset;
+		memcpy(priv->buffered_eap->buff, buff -
+		       pkt_offset, size + pkt_offset);
+	#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+		priv->eap_buff_timer.data = (unsigned long) priv;
+	#endif
+		mod_timer(&priv->eap_buff_timer, (jiffies +
+			  msecs_to_jiffies(10)));
+		return;
+	}
+	skb = dev_alloc_skb(frame_len);
+	if (!skb) {
+		PRINT_ER(vif->ndev, "Low memory - packet droped\n");
+		return;
+	}
+
+	skb->dev = vif->ndev;
+#if KERNEL_VERSION(4, 13, 0) <= LINUX_VERSION_CODE
+	skb_put_data(skb, buff_to_send, frame_len);
+#else
+	memcpy(skb_put(skb, frame_len), buff_to_send, frame_len);
+#endif
+
+	skb->protocol = eth_type_trans(skb, vif->ndev);
+	vif->netstats.rx_packets++;
+	vif->netstats.rx_bytes += frame_len;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	stats = netif_rx(skb);
+	PRINT_D(vif->ndev, RX_DBG, "netif_rx ret value: %d\n", stats);
+}
+
+static void free_eap_buff_params(void *vp)
+{
+	struct wilc_priv *priv;
+
+	priv = (struct wilc_priv *)vp;
+
+	if (priv->buffered_eap) {
+		kfree(priv->buffered_eap->buff);
+		priv->buffered_eap->buff = NULL;
+
+		kfree(priv->buffered_eap);
+		priv->buffered_eap = NULL;
+	}
+}
+
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+void eap_buff_timeout(struct timer_list *t)
+#else
+void eap_buff_timeout(unsigned long user)
+#endif
+{
+	u8 null_bssid[ETH_ALEN] = {0};
+	u8 *assoc_bss;
+	static u8 timeout = 5;
+	int status = -1;
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	struct wilc_priv *priv = from_timer(priv, t, eap_buff_timer);
+#else
+	struct wilc_priv *priv = (struct wilc_priv *)user;
+#endif
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+
+	assoc_bss = priv->associated_bss;
+	if (!(memcmp(assoc_bss, null_bssid, ETH_ALEN)) && (timeout-- > 0)) {
+		mod_timer(&priv->eap_buff_timer,
+			  (jiffies + msecs_to_jiffies(10)));
+		return;
+	}
+	del_timer(&priv->eap_buff_timer);
+	timeout = 5;
+
+	status = wilc_send_buffered_eap(vif, wilc_frmw_to_host,
+					free_eap_buff_params,
+					priv->buffered_eap->buff,
+					priv->buffered_eap->size,
+					priv->buffered_eap->pkt_offset,
+					(void *)priv);
+	if (status)
+		PRINT_ER(vif->ndev, "Failed so send buffered eap\n");
+}
+
+void wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode)
+{
+	struct wilc_vif *vif = netdev_priv(wilc_netdev);
+	struct wilc *wilc = vif->wilc;
+	int srcu_idx;
+
+	srcu_idx = srcu_read_lock(&wilc->srcu);
+	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
+		if (wilc_netdev == vif->ndev) {
+			if (bssid)
+				ether_addr_copy(vif->bssid, bssid);
+			else
+				eth_zero_addr(vif->bssid);
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "set bssid [%pM]\n", vif->bssid);
+			vif->iftype = mode;
+		}
+	}
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
+}
+
+#define TX_BACKOFF_WEIGHT_INCR_STEP (1)
+#define TX_BACKOFF_WEIGHT_DECR_STEP (1)
+#define TX_BACKOFF_WEIGHT_MAX (0)
+#define TX_BACKOFF_WEIGHT_MIN (0)
+#define TX_BCKOFF_WGHT_MS (1)
+
+static int wilc_txq_task(void *vp)
+{
+	int ret;
+	u32 txq_count;
+	int backoff_weight = TX_BACKOFF_WEIGHT_MIN;
+	signed long timeout;
+	struct wilc *wl = vp;
+
+	complete(&wl->txq_thread_started);
+	while (1) {
+		struct wilc_vif *vif = wilc_get_wl_to_vif(wl);
+		struct net_device *ndev = vif->ndev;
+
+		PRINT_INFO(ndev, TX_DBG, "txq_task Taking a nap\n");
+		if (wait_for_completion_interruptible(&wl->txq_event))
+			continue;
+		PRINT_INFO(ndev, TX_DBG, "txq_task Who waked me up\n");
+		if (wl->close) {
+			complete(&wl->txq_thread_started);
+
+			while (!kthread_should_stop())
+				schedule();
+			PRINT_INFO(ndev, TX_DBG, "TX thread stopped\n");
+			break;
+		}
+		PRINT_INFO(ndev, TX_DBG, "handle the tx packet\n");
+		do {
+			ret = wilc_wlan_handle_txq(wl, &txq_count);
+			if (txq_count < FLOW_CTRL_LOW_THRESHLD) {
+				struct wilc_vif *ifc;
+				int srcu_idx;
+
+				srcu_idx = srcu_read_lock(&wl->srcu);
+				PRINT_INFO(ndev, TX_DBG, "Waking up queue\n");
+				list_for_each_entry_rcu(ifc, &wl->vif_list,
+							list) {
+					if (ifc->mac_opened &&
+					    netif_queue_stopped(ifc->ndev))
+						netif_wake_queue(ifc->ndev);
+				}
+				srcu_read_unlock(&wl->srcu, srcu_idx);
+
+			}
+
+			if (ret == WILC_VMM_ENTRY_FULL_RETRY) {
+				timeout = msecs_to_jiffies(TX_BCKOFF_WGHT_MS <<
+							   backoff_weight);
+				do {
+			/* Back off from sending packets for some time.
+			 * schedule_timeout will allow RX task to run and free
+			 * buffers. Setting state to TASK_INTERRUPTIBLE will
+			 * put the thread back to CPU running queue when it's
+			 * signaled even if 'timeout' isn't elapsed. This gives
+			 * faster chance for reserved SK buffers to be freed
+			 */
+					set_current_state(TASK_INTERRUPTIBLE);
+					timeout = schedule_timeout(timeout);
+					} while (/*timeout*/0);
+				backoff_weight += TX_BACKOFF_WEIGHT_INCR_STEP;
+				if (backoff_weight > TX_BACKOFF_WEIGHT_MAX)
+					backoff_weight = TX_BACKOFF_WEIGHT_MAX;
+			} else if (backoff_weight > TX_BACKOFF_WEIGHT_MIN) {
+				backoff_weight -= TX_BACKOFF_WEIGHT_DECR_STEP;
+				if (backoff_weight < TX_BACKOFF_WEIGHT_MIN)
+					backoff_weight = TX_BACKOFF_WEIGHT_MIN;
+			}
+		} while (ret == WILC_VMM_ENTRY_FULL_RETRY && !wl->close);
+	}
+	return 0;
+}
+
+static int wilc_wlan_get_firmware(struct net_device *dev)
+{
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+	const struct firmware *wilc_firmware;
+	char *firmware;
+
+	if (wilc->chip == WILC_3000) {
+		PRINT_INFO(dev, INIT_DBG, "Detect chip WILC3000\n");
+		firmware = FW_WILC3000_WIFI;
+	} else if (wilc->chip == WILC_1000) {
+		PRINT_INFO(dev, INIT_DBG, "Detect chip WILC1000\n");
+		firmware = FW_WILC1000_WIFi;
+	} else {
+		return -EINVAL;
+	}
+
+	PRINT_INFO(dev, INIT_DBG, "loading firmware %s\n", firmware);
+
+	if (!(&vif->ndev->dev)) {
+		PRINT_ER(dev, "Dev  is NULL\n");
+		return -EINVAL;
+	}
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "WLAN firmware: %s\n", firmware);
+	if (request_firmware(&wilc_firmware, firmware, wilc->dev) != 0) {
+		PRINT_ER(dev, "%s - firmware not available\n", firmware);
+		return -EINVAL;
+	}
+	wilc->firmware = wilc_firmware;
+
+	return 0;
+}
+
+static int wilc_start_firmware(struct net_device *dev)
+{
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+	int ret = 0;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Starting Firmware ...\n");
+
+	ret = wilc_wlan_start(wilc);
+	if (ret < 0) {
+		PRINT_ER(dev, "Failed to start Firmware\n");
+		return ret;
+	}
+	PRINT_INFO(vif->ndev, INIT_DBG, "Waiting for FW to get ready ...\n");
+
+	if (!wait_for_completion_timeout(&wilc->sync_event,
+					 msecs_to_jiffies(500))) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Firmware start timed out\n");
+		return -ETIME;
+	}
+	PRINT_INFO(vif->ndev, INIT_DBG, "Firmware successfully started\n");
+
+	return 0;
+}
+
+static int wilc_firmware_download(struct net_device *dev)
+{
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+	int ret = 0;
+
+	if (!wilc->firmware) {
+		PRINT_ER(dev, "Firmware buffer is NULL\n");
+		ret = -ENOBUFS;
+	}
+	PRINT_INFO(vif->ndev, INIT_DBG, "Downloading Firmware ...\n");
+	ret = wilc_wlan_firmware_download(wilc, wilc->firmware->data,
+					  wilc->firmware->size);
+	if (ret < 0)
+		goto fail;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Download Succeeded\n");
+
+fail:
+	release_firmware(wilc->firmware);
+	wilc->firmware = NULL;
+
+	return ret;
+}
+
+static int wilc_init_fw_config(struct net_device *dev, struct wilc_vif *vif)
+{
+	struct wilc_priv *priv = &vif->priv;
+	struct host_if_drv *hif_drv;
+	u8 b;
+	u16 hw;
+	u32 w;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Start configuring Firmware\n");
+	hif_drv = (struct host_if_drv *)priv->hif_drv;
+	PRINT_D(vif->ndev, INIT_DBG, "Host = %p\n", hif_drv);
+
+	w = vif->iftype;
+	cpu_to_le32s(&w);
+	if (!cfg_set(vif, 1, WID_SET_OPERATION_MODE, (u8 *)&w, 4, 0, 0))
+		goto fail;
+
+	b = WILC_FW_BSS_TYPE_INFRA;
+	if (!cfg_set(vif, 0, WID_BSS_TYPE, &b, 1, 0, 0))
+		goto fail;
+
+	b = WILC_FW_TX_RATE_AUTO;
+	if (!cfg_set(vif, 0, WID_CURRENT_TX_RATE, &b, 1, 0, 0))
+		goto fail;
+
+	b = WILC_FW_OPER_MODE_G_MIXED_11B_2;
+	if (!cfg_set(vif, 0, WID_11G_OPERATING_MODE, &b, 1, 0,
+			       0))
+		goto fail;
+
+	b = WILC_FW_PREAMBLE_AUTO;
+	if (!cfg_set(vif, 0, WID_PREAMBLE, &b, 1, 0, 0))
+		goto fail;
+
+	b = WILC_FW_11N_PROT_AUTO;
+	if (!cfg_set(vif, 0, WID_11N_PROT_MECH, &b, 1, 0, 0))
+		goto fail;
+
+	b = WILC_FW_ACTIVE_SCAN;
+	if (!cfg_set(vif, 0, WID_SCAN_TYPE, &b, 1, 0, 0))
+		goto fail;
+
+	b = WILC_FW_SITE_SURVEY_OFF;
+	if (!cfg_set(vif, 0, WID_SITE_SURVEY, &b, 1, 0, 0))
+		goto fail;
+
+	hw = 0xffff;
+	cpu_to_le16s(&hw);
+	if (!cfg_set(vif, 0, WID_RTS_THRESHOLD, (u8 *)&hw, 2, 0, 0))
+		goto fail;
+
+	hw = 2346;
+	cpu_to_le16s(&hw);
+	if (!cfg_set(vif, 0, WID_FRAG_THRESHOLD, (u8 *)&hw, 2, 0, 0))
+		goto fail;
+
+	b = 0;
+	if (!cfg_set(vif, 0, WID_BCAST_SSID, &b, 1, 0, 0))
+		goto fail;
+
+	b = 1;
+	if (!cfg_set(vif, 0, WID_QOS_ENABLE, &b, 1, 0, 0))
+		goto fail;
+
+	b = WILC_FW_NO_POWERSAVE;
+	if (!cfg_set(vif, 0, WID_POWER_MANAGEMENT, &b, 1, 0, 0))
+		goto fail;
+
+	b = WILC_FW_SEC_NO;
+	if (!cfg_set(vif, 0, WID_11I_MODE, &b, 1, 0, 0))
+		goto fail;
+
+	b = WILC_FW_AUTH_OPEN_SYSTEM;
+	if (!cfg_set(vif, 0, WID_AUTH_TYPE, &b, 1, 0, 0))
+		goto fail;
+
+	b = 3;
+	if (!cfg_set(vif, 0, WID_LISTEN_INTERVAL, &b, 1, 0, 0))
+		goto fail;
+
+	b = 3;
+	if (!cfg_set(vif, 0, WID_DTIM_PERIOD, &b, 1, 0, 0))
+		goto fail;
+
+	b = WILC_FW_ACK_POLICY_NORMAL;
+	if (!cfg_set(vif, 0, WID_ACK_POLICY, &b, 1, 0, 0))
+		goto fail;
+
+	b = 0;
+	if (!cfg_set(vif, 0, WID_USER_CONTROL_ON_TX_POWER, &b, 1,
+			       0, 0))
+		goto fail;
+
+	b = 48;
+	if (!cfg_set(vif, 0, WID_TX_POWER_LEVEL_11A, &b, 1, 0,
+			       0))
+		goto fail;
+
+	b = 28;
+	if (!cfg_set(vif, 0, WID_TX_POWER_LEVEL_11B, &b, 1, 0,
+			       0))
+		goto fail;
+
+	hw = 100;
+	cpu_to_le16s(&hw);
+	if (!cfg_set(vif, 0, WID_BEACON_INTERVAL, (u8 *)&hw, 2, 0, 0))
+		goto fail;
+
+	b = WILC_FW_REKEY_POLICY_DISABLE;
+	if (!cfg_set(vif, 0, WID_REKEY_POLICY, &b, 1, 0, 0))
+		goto fail;
+
+	w = 84600;
+	cpu_to_le32s(&w);
+	if (!cfg_set(vif, 0, WID_REKEY_PERIOD, (u8 *)&w, 4, 0, 0))
+		goto fail;
+
+	w = 500;
+	cpu_to_le32s(&w);
+	if (!cfg_set(vif, 0, WID_REKEY_PACKET_COUNT, (u8 *)&w, 4, 0,
+			       0))
+		goto fail;
+
+	b = 1;
+	if (!cfg_set(vif, 0, WID_SHORT_SLOT_ALLOWED, &b, 1, 0,
+			       0))
+		goto fail;
+
+	b = WILC_FW_ERP_PROT_SELF_CTS;
+	if (!cfg_set(vif, 0, WID_11N_ERP_PROT_TYPE, &b, 1, 0, 0))
+		goto fail;
+
+	b = 1;
+	if (!cfg_set(vif, 0, WID_11N_ENABLE, &b, 1, 0, 0))
+		goto fail;
+
+	b = WILC_FW_11N_OP_MODE_HT_MIXED;
+	if (!cfg_set(vif, 0, WID_11N_OPERATING_MODE, &b, 1, 0,
+			       0))
+		goto fail;
+
+	b = 1;
+	if (!cfg_set(vif, 0, WID_11N_TXOP_PROT_DISABLE, &b, 1, 0,
+			       0))
+		goto fail;
+
+	b = WILC_FW_OBBS_NONHT_DETECT_PROTECT_REPORT;
+	if (!cfg_set(vif, 0, WID_11N_OBSS_NONHT_DETECTION, &b, 1,
+			       0, 0))
+		goto fail;
+
+	b = WILC_FW_HT_PROT_RTS_CTS_NONHT;
+	if (!cfg_set(vif, 0, WID_11N_HT_PROT_TYPE, &b, 1, 0, 0))
+		goto fail;
+
+	b = 0;
+	if (!cfg_set(vif, 0, WID_11N_RIFS_PROT_ENABLE, &b, 1, 0,
+			       0))
+		goto fail;
+
+	b = 7;
+	if (!cfg_set(vif, 0, WID_11N_CURRENT_TX_MCS, &b, 1, 0,
+			       0))
+		goto fail;
+
+	b = 1;
+	if (!cfg_set(vif, 0, WID_11N_IMMEDIATE_BA_ENABLED, &b, 1,
+			       1, 0))
+		goto fail;
+
+	return 0;
+
+fail:
+	return -EINVAL;
+}
+
+static void wlan_deinitialize_threads(struct net_device *dev)
+{
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wl = vif->wilc;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
+	if (!recovery_on) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinit debug Thread\n");
+		debug_running = false;
+		if (&wl->debug_thread_started)
+			complete(&wl->debug_thread_started);
+		if (wl->debug_thread) {
+			kthread_stop(wl->debug_thread);
+			wl->debug_thread = NULL;
+		}
+	}
+
+	wl->close = 1;
+	PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
+
+	complete(&wl->txq_event);
+
+	if (wl->txq_thread) {
+		kthread_stop(wl->txq_thread);
+		wl->txq_thread = NULL;
+	}
+}
+
+static void wilc_wlan_deinitialize(struct net_device *dev)
+{
+	int ret;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wl = vif->wilc;
+
+	if (wl->initialized) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing wilc  ...\n");
+
+		if (!wl) {
+			PRINT_ER(dev, "wl is NULL\n");
+			return;
+		}
+
+		PRINT_D(vif->ndev, INIT_DBG, "destroy aging timer\n");
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Disabling IRQ\n");
+		if (wl->io_type == WILC_HIF_SPI ||
+			wl->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+			wilc_disable_irq(wl, 1);
+		} else {
+			if (wl->hif_func->disable_interrupt) {
+				mutex_lock(&wl->hif_cs);
+				wl->hif_func->disable_interrupt(wl);
+				mutex_unlock(&wl->hif_cs);
+			}
+		}
+		complete(&wl->txq_event);
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
+		wlan_deinitialize_threads(dev);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing IRQ\n");
+		deinit_irq(dev);
+
+		ret = wilc_wlan_stop(wl, vif);
+		if (ret != 0)
+			PRINT_ER(dev, "failed in wlan_stop\n");
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing WILC Wlan\n");
+		wilc_wlan_cleanup(dev);
+
+		wl->initialized = false;
+
+		PRINT_INFO(dev, INIT_DBG, "wilc deinitialization Done\n");
+	} else {
+		PRINT_INFO(dev, INIT_DBG, "wilc is not initialized\n");
+	}
+}
+
+static int wlan_initialize_threads(struct net_device *dev)
+{
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Initializing Threads ...\n");
+	PRINT_INFO(vif->ndev, INIT_DBG, "Creating kthread for transmission\n");
+	wilc->txq_thread = kthread_run(wilc_txq_task, (void *)wilc,
+				       "K_TXQ_TASK");
+	if (IS_ERR(wilc->txq_thread)) {
+		PRINT_ER(dev, "couldn't create TXQ thread\n");
+		wilc->close = 1;
+		return PTR_ERR(wilc->txq_thread);
+	}
+	wait_for_completion(&wilc->txq_thread_started);
+
+	if (!debug_running) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Creating kthread for Debugging\n");
+		wilc->debug_thread = kthread_run(debug_thread, (void *)wilc,
+						 "WILC_DEBUG");
+		if (IS_ERR(wilc->debug_thread)) {
+			PRINT_ER(dev, "couldn't create debug thread\n");
+			wilc->close = 1;
+			kthread_stop(wilc->txq_thread);
+			return PTR_ERR(wilc->debug_thread);
+		}
+		debug_running = true;
+		wait_for_completion(&wilc->debug_thread_started);
+	}
+
+	return 0;
+}
+
+static int wilc_wlan_initialize(struct net_device *dev, struct wilc_vif *vif)
+{
+	int ret = 0;
+	struct wilc *wl = vif->wilc;
+
+	if (!wl->initialized) {
+		wl->mac_status = WILC_MAC_STATUS_INIT;
+		wl->close = 0;
+		wl->initialized = 0;
+
+		ret = wilc_wlan_init(dev);
+		if (ret) {
+			PRINT_ER(dev, "Initializing WILC_Wlan FAILED\n");
+			return ret;
+		}
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "WILC Initialization done\n");
+
+		ret = wlan_initialize_threads(dev);
+		if (ret) {
+			PRINT_ER(dev, "Initializing Threads FAILED\n");
+			goto fail_wilc_wlan;
+		}
+
+		ret = init_irq(dev);
+		if (ret)
+			goto fail_threads;
+
+		if (wl->io_type == WILC_HIF_SDIO &&
+		    wl->hif_func->enable_interrupt(wl)) {
+			PRINT_ER(dev, "couldn't initialize IRQ\n");
+			ret = -EIO;
+			goto fail_irq_init;
+		}
+
+		ret = wilc_wlan_get_firmware(dev);
+		if (ret) {
+			PRINT_ER(dev, "Can't get firmware\n");
+			goto fail_irq_enable;
+		}
+
+		ret = wilc_firmware_download(dev);
+		if (ret) {
+			PRINT_ER(dev, "Failed to download firmware\n");
+			goto fail_irq_enable;
+		}
+
+		ret = wilc_start_firmware(dev);
+		if (ret) {
+			PRINT_ER(dev, "Failed to start firmware\n");
+			goto fail_irq_enable;
+		}
+
+		if (cfg_get(vif, 1, WID_FIRMWARE_VERSION, 1, 0)) {
+			int size;
+			char firmware_ver[50];
+
+			size = cfg_get_val(wl, WID_FIRMWARE_VERSION,
+						     firmware_ver,
+						     sizeof(firmware_ver));
+			firmware_ver[size] = '\0';
+			PRINT_INFO(dev, INIT_DBG, "WILC Firmware Ver = %s\n",
+				   firmware_ver);
+		}
+
+		ret = wilc_init_fw_config(dev, vif);
+		if (ret < 0) {
+			PRINT_ER(dev, "Failed to configure firmware\n");
+			ret = -EIO;
+			goto fail_fw_start;
+		}
+
+		wl->initialized = true;
+		return 0;
+
+fail_fw_start:
+		wilc_wlan_stop(wl, vif);
+
+fail_irq_enable:
+		if (wl->io_type == WILC_HIF_SDIO)
+			wl->hif_func->disable_interrupt(wl);
+fail_irq_init:
+		deinit_irq(dev);
+
+fail_threads:
+		wlan_deinitialize_threads(dev);
+fail_wilc_wlan:
+		wilc_wlan_cleanup(dev);
+		PRINT_ER(dev, "WLAN initialization FAILED\n");
+	} else {
+		PRINT_WRN(vif->ndev, INIT_DBG, "wilc already initialized\n");
+	}
+	return ret;
+}
+
+static int mac_init_fn(struct net_device *ndev)
+{
+	netif_start_queue(ndev);
+	netif_stop_queue(ndev);
+
+	return 0;
+}
+
+static int wilc_mac_open(struct net_device *ndev)
+{
+	struct wilc_vif *vif = netdev_priv(ndev);
+	struct wilc *wl = vif->wilc;
+	unsigned char mac_add[ETH_ALEN] = {0};
+	int ret = 0;
+
+	if (!wl || !wl->dev) {
+		PRINT_ER(ndev, "device not ready\n");
+		return -ENODEV;
+	}
+
+	PRINT_INFO(ndev, INIT_DBG, "MAC OPEN[%p] %s\n", ndev, ndev->name);
+
+	if (wl->open_ifcs == 0)
+		wilc_bt_power_up(wl, DEV_WIFI);
+
+	if (!recovery_on) {
+		ret = wilc_init_host_int(ndev);
+		if (ret < 0) {
+			PRINT_ER(ndev, "Failed to initialize host interface\n");
+			return ret;
+		}
+	}
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "*** re-init ***\n");
+	ret = wilc_wlan_initialize(ndev, vif);
+	if (ret) {
+		PRINT_ER(ndev, "Failed to initialize wilc\n");
+		if (!recovery_on)
+			wilc_deinit_host_int(ndev);
+		return ret;
+	}
+
+	wait_for_recovery = 0;
+	wilc_set_operation_mode(vif, wilc_get_vif_idx(vif),
+				 vif->iftype, vif->idx);
+	wilc_get_mac_address(vif, mac_add);
+	PRINT_INFO(vif->ndev, INIT_DBG, "Mac address: %pM\n", mac_add);
+
+	if (!is_valid_ether_addr(mac_add)) {
+		PRINT_ER(ndev, "Wrong MAC address\n");
+		wilc_deinit_host_int(ndev);
+		wilc_wlan_deinitialize(ndev);
+		return -EINVAL;
+	}
+	ether_addr_copy(ndev->dev_addr, mac_add);
+
+	wilc_mgmt_frame_register(vif->ndev->ieee80211_ptr->wiphy,
+				 vif->ndev->ieee80211_ptr,
+				 vif->frame_reg[0].type,
+				 vif->frame_reg[0].reg);
+	wilc_mgmt_frame_register(vif->ndev->ieee80211_ptr->wiphy,
+				 vif->ndev->ieee80211_ptr,
+				 vif->frame_reg[1].type,
+				 vif->frame_reg[1].reg);
+	netif_wake_queue(ndev);
+	wl->open_ifcs++;
+	vif->mac_opened = 1;
+	return 0;
+}
+
+static struct net_device_stats *mac_stats(struct net_device *dev)
+{
+	struct wilc_vif *vif = netdev_priv(dev);
+
+	return &vif->netstats;
+}
+
+static int wilc_set_mac_addr(struct net_device *dev, void *p)
+{
+	int result;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct sockaddr *addr = (struct sockaddr *)p;
+	struct wilc *wilc = vif->wilc;
+	unsigned char mac_addr[6] = {0};
+	struct wilc_vif *tmp_vif;
+	int srcu_idx;
+
+	if (!is_valid_ether_addr(addr->sa_data)) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Invalid MAC address\n");
+		return -EINVAL;
+	}
+
+	srcu_idx = srcu_read_lock(&wilc->srcu);
+	list_for_each_entry_rcu(tmp_vif, &wilc->vif_list, list) {
+		wilc_get_mac_address(tmp_vif, mac_addr);
+		if (ether_addr_equal(addr->sa_data, mac_addr)) {
+			if (vif != tmp_vif) {
+				PRINT_INFO(vif->ndev, INIT_DBG,
+					   "MAC address is alredy in use\n");
+				srcu_read_unlock(&wilc->srcu, srcu_idx);
+				return -EINVAL;
+			}
+			srcu_read_unlock(&wilc->srcu, srcu_idx);
+			return 0;
+		}
+	}
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
+
+	/* configure new MAC address */
+	result = wilc_set_mac_address(vif, (u8 *)addr->sa_data);
+	ether_addr_copy(vif->bssid, addr->sa_data);
+	ether_addr_copy(vif->ndev->dev_addr, vif->bssid);
+
+	return result;
+}
+
+static void wilc_set_multicast_list(struct net_device *dev)
+{
+	struct netdev_hw_addr *ha;
+	struct wilc_vif *vif = netdev_priv(dev);
+	int i;
+	u8 *mc_list;
+	u8 *cur_mc;
+
+	PRINT_INFO(vif->ndev, INIT_DBG,
+		   "Setting mcast List with count = %d.\n", dev->mc.count);
+	if (dev->flags & IFF_PROMISC) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Set promiscuous mode ON retrive all pkts\n");
+		return;
+	}
+
+	if (dev->flags & IFF_ALLMULTI ||
+	    dev->mc.count > WILC_MULTICAST_TABLE_SIZE) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Disable mcast filter retrive multicast pkts\n");
+		wilc_setup_multicast_filter(vif, 0, 0, NULL);
+		return;
+	}
+
+	if (dev->mc.count == 0) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Enable mcast filter retrive directed pkts only\n");
+		wilc_setup_multicast_filter(vif, 1, 0, NULL);
+		return;
+	}
+
+	mc_list = kmalloc_array(dev->mc.count, ETH_ALEN, GFP_ATOMIC);
+	if (!mc_list)
+		return;
+
+	cur_mc = mc_list;
+	i = 0;
+	netdev_for_each_mc_addr(ha, dev) {
+		memcpy(cur_mc, ha->addr, ETH_ALEN);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Entry[%d]: %pM\n", i, cur_mc);
+		i++;
+		cur_mc += ETH_ALEN;
+	}
+
+	if (wilc_setup_multicast_filter(vif, 1, dev->mc.count, mc_list))
+		kfree(mc_list);
+}
+
+static void wilc_tx_complete(void *priv, int status)
+{
+	struct tx_complete_data *pv_data = priv;
+
+	if (status == 1)
+		PRINT_INFO(pv_data->vif->ndev, TX_DBG,
+			  "Packet sentSize= %d Add= %p SKB= %p\n",
+			  pv_data->size, pv_data->buff, pv_data->skb);
+	else
+		PRINT_INFO(pv_data->vif->ndev, TX_DBG,
+			   "Couldn't send pkt Size= %d Add= %p SKB= %p\n",
+			   pv_data->size, pv_data->buff, pv_data->skb);
+	dev_kfree_skb(pv_data->skb);
+	kfree(pv_data);
+}
+
+netdev_tx_t wilc_mac_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct wilc_vif *vif = netdev_priv(ndev);
+	struct wilc *wilc = vif->wilc;
+	struct tx_complete_data *tx_data = NULL;
+	int queue_count;
+
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "Sending packet just received from TCP/IP\n");
+	if (skb->dev != ndev) {
+		PRINT_ER(ndev, "Packet not destined to this device\n");
+		return NETDEV_TX_OK;
+	}
+
+	tx_data = kmalloc(sizeof(*tx_data), GFP_ATOMIC);
+	if (!tx_data) {
+		PRINT_ER(ndev, "Failed to alloc memory for tx_data struct\n");
+		dev_kfree_skb(skb);
+		netif_wake_queue(ndev);
+		return NETDEV_TX_OK;
+	}
+
+	tx_data->buff = skb->data;
+	tx_data->size = skb->len;
+	tx_data->skb  = skb;
+
+	PRINT_D(vif->ndev, TX_DBG, "Sending pkt Size= %d Add= %p SKB= %p\n",
+		tx_data->size, tx_data->buff, tx_data->skb);
+	PRINT_D(vif->ndev, TX_DBG, "Adding tx pkt to TX Queue\n");
+	vif->netstats.tx_packets++;
+	vif->netstats.tx_bytes += tx_data->size;
+	tx_data->vif = vif;
+	queue_count = txq_add_net_pkt(ndev, (void *)tx_data,
+				      tx_data->buff, tx_data->size,
+				      wilc_tx_complete);
+
+	if (queue_count > FLOW_CTRL_UP_THRESHLD) {
+		struct wilc_vif *vif;
+		int srcu_idx;
+
+		srcu_idx = srcu_read_lock(&wilc->srcu);
+		list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
+			if (vif->mac_opened)
+				netif_stop_queue(vif->ndev);
+		}
+		srcu_read_unlock(&wilc->srcu, srcu_idx);
+	}
+
+	return NETDEV_TX_OK;
+}
+
+static int wilc_mac_close(struct net_device *ndev)
+{
+	struct wilc_vif *vif = netdev_priv(ndev);
+	struct wilc *wl = vif->wilc;
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Mac close\n");
+
+	if (wl->open_ifcs > 0) {
+		wl->open_ifcs--;
+	} else {
+		PRINT_ER(ndev, "MAC close called with no opened interfaces\n");
+		return 0;
+	}
+
+	if (vif->ndev) {
+		netif_stop_queue(vif->ndev);
+
+	handle_connect_cancel(vif);
+
+	if (!recovery_on)
+		wilc_deinit_host_int(vif->ndev);
+	}
+
+	if (wl->open_ifcs == 0) {
+		PRINT_INFO(ndev, GENERIC_DBG, "Deinitializing wilc\n");
+		wl->close = 1;
+
+		wilc_wlan_deinitialize(ndev);
+	}
+
+	vif->mac_opened = 0;
+
+	return 0;
+}
+
+void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size)
+{
+	struct wilc_vif *vif;
+	int srcu_idx;
+
+	srcu_idx = srcu_read_lock(&wilc->srcu);
+	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
+		u16 tp = le16_to_cpup((__le16 *)buff);
+		struct wilc_priv *priv;
+
+		priv = &vif->priv;
+		if (((tp == vif->frame_reg[0].type && vif->frame_reg[0].reg) ||
+		    (tp == vif->frame_reg[1].type && vif->frame_reg[1].reg)) &&
+			    vif->p2p_listen_state)
+			wilc_wfi_p2p_rx(vif, buff, size);
+
+		if (vif->monitor_flag)
+			wilc_wfi_monitor_rx(wilc->monitor_dev, buff, size);
+	}
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
+}
+
+static const struct net_device_ops wilc_netdev_ops = {
+	.ndo_init = mac_init_fn,
+	.ndo_open = wilc_mac_open,
+	.ndo_stop = wilc_mac_close,
+	.ndo_set_mac_address = wilc_set_mac_addr,
+	.ndo_start_xmit = wilc_mac_xmit,
+	.ndo_get_stats = mac_stats,
+	.ndo_set_rx_mode  = wilc_set_multicast_list,
+};
+
+void wilc_netdev_cleanup(struct wilc *wilc)
+{
+	struct wilc_vif *vif;
+	int srcu_idx, ifc_cnt = 0;
+
+	if (!wilc)
+		return;
+
+	if (wilc->firmware) {
+		release_firmware(wilc->firmware);
+		wilc->firmware = NULL;
+	}
+
+	srcu_idx = srcu_read_lock(&wilc->srcu);
+	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
+		/* clear the mode */
+		wilc_set_operation_mode(vif, 0, 0, 0);
+		if (vif->ndev) {
+			PRINT_INFO(vif->ndev, INIT_DBG,
+				   "Unregistering netdev %p\n",
+				   vif->ndev);
+			unregister_netdev(vif->ndev);
+		}
+	}
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
+
+	wilc_wfi_deinit_mon_interface(wilc, false);
+
+	flush_workqueue(wilc->hif_workqueue);
+	destroy_workqueue(wilc->hif_workqueue);
+	wilc->hif_workqueue = NULL;
+	/* update the list */
+	while (ifc_cnt < WILC_NUM_CONCURRENT_IFC) {
+		mutex_lock(&wilc->vif_mutex);
+		if (wilc->vif_num <= 0) {
+			mutex_unlock(&wilc->vif_mutex);
+			break;
+		}
+		vif = wilc_get_wl_to_vif(wilc);
+		if (!IS_ERR(vif))
+			list_del_rcu(&vif->list);
+		wilc->vif_num--;
+		mutex_unlock(&wilc->vif_mutex);
+		synchronize_srcu(&wilc->srcu);
+		ifc_cnt++;
+	}
+	cfg_deinit(wilc);
+#ifdef WILC_DEBUGFS
+	wilc_debugfs_remove();
+#endif
+	wilc_sysfs_exit();
+	wlan_deinit_locks(wilc);
+	kfree(wilc->bus_data);
+	wiphy_unregister(wilc->wiphy);
+	pr_info("Freeing wiphy\n");
+	wiphy_free(wilc->wiphy);
+	pr_info("Module_exit Done.\n");
+}
+
+static u8 wilc_get_available_idx(struct wilc *wl)
+{
+	int idx = 0;
+	struct wilc_vif *vif;
+	int srcu_idx;
+
+	srcu_idx = srcu_read_lock(&wl->srcu);
+	list_for_each_entry_rcu(vif, &wl->vif_list, list) {
+		if (vif->idx == 0)
+			idx = 1;
+		else
+			idx = 0;
+	}
+	srcu_read_unlock(&wl->srcu, srcu_idx);
+	return idx;
+}
+
+struct wilc_vif *wilc_netdev_ifc_init(struct wilc *wl, const char *name,
+				      int iftype, enum nl80211_iftype type,
+				      bool rtnl_locked)
+{
+	struct net_device *ndev;
+	struct wilc_vif *vif;
+	int ret;
+
+	ndev = alloc_etherdev(sizeof(struct wilc_vif));
+	if (!ndev)
+		return ERR_PTR(-ENOMEM);
+
+	vif = netdev_priv(ndev);
+
+	ndev->ieee80211_ptr = &vif->priv.wdev;
+
+	vif->wilc = wl;
+	vif->ndev = ndev;
+	ndev->ml_priv = vif;
+	strcpy(ndev->name, name);
+	ndev->netdev_ops = &wilc_netdev_ops;
+
+	SET_NETDEV_DEV(ndev, wiphy_dev(wl->wiphy));
+
+	vif->ndev->ml_priv = vif;
+	vif->priv.wdev.wiphy = wl->wiphy;
+	vif->priv.wdev.netdev = ndev;
+	vif->priv.wdev.iftype = type;
+	vif->priv.dev = ndev;
+
+	vif->priv.dev = ndev;
+	if (rtnl_locked)
+		ret = register_netdevice(ndev);
+	else
+		ret = register_netdev(ndev);
+
+	if (ret) {
+		pr_err("Device couldn't be registered - %s\n", ndev->name);
+		free_netdev(ndev);
+		return ERR_PTR(-EFAULT);
+	}
+#if KERNEL_VERSION(4, 11, 9) <= LINUX_VERSION_CODE
+	ndev->needs_free_netdev = true;
+#else
+	ndev->destructor = free_netdev;
+#endif
+	vif->iftype = iftype;
+	vif->idx = wilc_get_available_idx(wl);
+	vif->mac_opened = 0;
+	mutex_lock(&wl->vif_mutex);
+	wl->vif_num += 1;
+	list_add_tail_rcu(&vif->list, &wl->vif_list);
+	mutex_unlock(&wl->vif_mutex);
+	synchronize_srcu(&wl->srcu);
+
+	return vif;
+}
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/wilc1000/netdev.h b/drivers/staging/wilc1000/netdev.h
new file mode 100644
index 000000000..e550ba9c1
--- /dev/null
+++ b/drivers/staging/wilc1000/netdev.h
@@ -0,0 +1,476 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#ifndef WILC_NETDEV_H
+#define WILC_NETDEV_H
+
+#include <linux/tcp.h>
+#include <linux/ieee80211.h>
+#include <net/cfg80211.h>
+#include <net/ieee80211_radiotap.h>
+#include <linux/if_arp.h>
+#include <linux/version.h>
+
+#include "hif.h"
+#include "wlan.h"
+#include "wlan_cfg.h"
+
+extern int wait_for_recovery;
+
+#if KERNEL_VERSION(3, 14, 0) > LINUX_VERSION_CODE
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	*(u32 *)dst = *(const u32 *)src;
+	*(u16 *)(dst + 4) = *(const u16 *)(src + 4);
+#else
+	u16 *a = (u16 *)dst;
+	const u16 *b = (const u16 *)src;
+
+	a[0] = b[0];
+	a[1] = b[1];
+	a[2] = b[2];
+#endif
+}
+
+static inline bool ether_addr_equal_unaligned(const u8 *addr1, const u8 *addr2)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	return ether_addr_equal(addr1, addr2);
+#else
+	return memcmp(addr1, addr2, ETH_ALEN) == 0;
+#endif
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0) */
+
+#if KERNEL_VERSION(3, 12, 0) > LINUX_VERSION_CODE
+#define PTR_ERR_OR_ZERO(ptr) PTR_RET(ptr)
+#endif
+
+#if KERNEL_VERSION(3, 13, 0) > LINUX_VERSION_CODE
+/*
+ * Create a contiguous bitmask starting at bit position @l and ending at
+ * position @h. For example
+ * GENMASK_ULL(39, 21) gives us the 64bit vector 0x000000ffffe00000.
+ */
+#define GENMASK(h, l) \
+	(((~UL(0)) - (UL(1) << (l)) + 1) & \
+	 (~UL(0) >> (BITS_PER_LONG - 1 - (h))))
+#endif
+
+#if KERNEL_VERSION(4, 9, 0) > LINUX_VERSION_CODE
+#ifdef __CHECKER__
+#define __BUILD_BUG_ON_NOT_POWER_OF_2(n) (0)
+#else
+/* Force a compilation error if a constant expression is not a power of 2 */
+#define __BUILD_BUG_ON_NOT_POWER_OF_2(n)	\
+	BUILD_BUG_ON(((n) & ((n) - 1)) != 0)
+#endif
+
+/*
+ * Bitfield access macros
+ *
+ * FIELD_{GET,PREP} macros take as first parameter shifted mask
+ * from which they extract the base mask and shift amount.
+ * Mask must be a compilation time constant.
+ *
+ * Example:
+ *
+ *  #define REG_FIELD_A  GENMASK(6, 0)
+ *  #define REG_FIELD_B  BIT(7)
+ *  #define REG_FIELD_C  GENMASK(15, 8)
+ *  #define REG_FIELD_D  GENMASK(31, 16)
+ *
+ * Get:
+ *  a = FIELD_GET(REG_FIELD_A, reg);
+ *  b = FIELD_GET(REG_FIELD_B, reg);
+ *
+ * Set:
+ *  reg = FIELD_PREP(REG_FIELD_A, 1) |
+ *	  FIELD_PREP(REG_FIELD_B, 0) |
+ *	  FIELD_PREP(REG_FIELD_C, c) |
+ *	  FIELD_PREP(REG_FIELD_D, 0x40);
+ *
+ * Modify:
+ *  reg &= ~REG_FIELD_C;
+ *  reg |= FIELD_PREP(REG_FIELD_C, c);
+ */
+
+#define __bf_shf(x) (__builtin_ffsll(x) - 1)
+
+#define __BF_FIELD_CHECK(_mask, _reg, _val, _pfx)			\
+	({								\
+		BUILD_BUG_ON_MSG(!__builtin_constant_p(_mask),		\
+				 _pfx "mask is not constant");		\
+		BUILD_BUG_ON_MSG(!(_mask), _pfx "mask is zero");	\
+		BUILD_BUG_ON_MSG(__builtin_constant_p(_val) ?		\
+				 ~((_mask) >> __bf_shf(_mask)) & (_val) : 0, \
+				 _pfx "value too large for the field"); \
+		BUILD_BUG_ON_MSG((_mask) > (typeof(_reg))~0ull,		\
+				 _pfx "type of reg too small for mask"); \
+		__BUILD_BUG_ON_NOT_POWER_OF_2((_mask) +			\
+					      (1ULL << __bf_shf(_mask))); \
+	})
+/**
+ * FIELD_GET() - extract a bitfield element
+ * @_mask: shifted mask defining the field's length and position
+ * @_reg:  32bit value of entire bitfield
+ *
+ * FIELD_GET() extracts the field specified by @_mask from the
+ * bitfield passed in as @_reg by masking and shifting it down.
+ */
+#define FIELD_GET(_mask, _reg)						\
+	({								\
+		__BF_FIELD_CHECK(_mask, _reg, 0U, "FIELD_GET: ");	\
+		(typeof(_mask))(((_reg) & (_mask)) >> __bf_shf(_mask));	\
+	})
+
+/**
+ * FIELD_PREP() - prepare a bitfield element
+ * @_mask: shifted mask defining the field's length and position
+ * @_val:  value to put in the field
+ *
+ * FIELD_PREP() masks and shifts up the value.  The result should
+ * be combined with other fields of the bitfield using logical OR.
+ */
+#define FIELD_PREP(_mask, _val)						\
+	({								\
+		__BF_FIELD_CHECK(_mask, 0ULL, _val, "FIELD_PREP: ");	\
+		((typeof(_mask))(_val) << __bf_shf(_mask)) & (_mask);	\
+	})
+#endif
+
+#define FLOW_CTRL_LOW_THRESHLD		128
+#define FLOW_CTRL_UP_THRESHLD		256
+
+#define PMKID_FOUND				1
+#define NUM_STA_ASSOCIATED			8
+
+#define NUM_REG_FRAME				2
+
+#define TCP_ACK_FILTER_LINK_SPEED_THRESH	54
+#define DEFAULT_LINK_SPEED			72
+
+#define ANT_SWTCH_INVALID_GPIO_CTRL		0
+#define ANT_SWTCH_SNGL_GPIO_CTRL		1
+#define ANT_SWTCH_DUAL_GPIO_CTRL		2
+
+struct wilc_wfi_stats {
+	unsigned long rx_packets;
+	unsigned long tx_packets;
+	unsigned long rx_bytes;
+	unsigned long tx_bytes;
+	u64 rx_time;
+	u64 tx_time;
+};
+
+struct wilc_wfi_key {
+	u8 *key;
+	u8 *seq;
+	int key_len;
+	int seq_len;
+	u32 cipher;
+};
+
+struct wilc_wfi_wep_key {
+	u8 *key;
+	u8 key_len;
+	u8 key_idx;
+};
+
+struct sta_info {
+	u8 sta_associated_bss[WILC_MAX_NUM_STA][ETH_ALEN];
+};
+
+/* Parameters needed for host interface for remaining on channel */
+struct wilc_wfi_p2p_listen_params {
+	struct ieee80211_channel *listen_ch;
+	u32 listen_duration;
+	u64 listen_cookie;
+};
+
+/* Struct to buffer eapol 1/4 frame */
+struct wilc_buffered_eap {
+	unsigned int size;
+	unsigned int pkt_offset;
+	u8 *buff;
+};
+
+struct wilc_p2p_var {
+	u8 local_random;
+	u8 recv_random;
+	bool is_wilc_ie;
+};
+
+static const u32 wilc_cipher_suites[] = {
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+	WLAN_CIPHER_SUITE_CCMP,
+	WLAN_CIPHER_SUITE_AES_CMAC
+};
+
+#if KERNEL_VERSION(4, 7, 0) > LINUX_VERSION_CODE
+#define CHAN2G(_channel, _freq, _flags) {       \
+	.band             = IEEE80211_BAND_2GHZ, \
+	.center_freq      = (_freq),             \
+	.hw_value         = (_channel),          \
+	.flags            = (_flags),            \
+	.max_antenna_gain = 0,                   \
+	.max_power        = 30,                  \
+}
+#else
+#define CHAN2G(_channel, _freq, _flags) {       \
+	.band             = NL80211_BAND_2GHZ, \
+	.center_freq      = (_freq),             \
+	.hw_value         = (_channel),          \
+	.flags            = (_flags),            \
+	.max_antenna_gain = 0,                   \
+	.max_power        = 30,                  \
+}
+#endif
+
+static const struct ieee80211_channel wilc_2ghz_channels[] = {
+	CHAN2G(1,  2412, 0),
+	CHAN2G(2,  2417, 0),
+	CHAN2G(3,  2422, 0),
+	CHAN2G(4,  2427, 0),
+	CHAN2G(5,  2432, 0),
+	CHAN2G(6,  2437, 0),
+	CHAN2G(7,  2442, 0),
+	CHAN2G(8,  2447, 0),
+	CHAN2G(9,  2452, 0),
+	CHAN2G(10, 2457, 0),
+	CHAN2G(11, 2462, 0),
+	CHAN2G(12, 2467, 0),
+	CHAN2G(13, 2472, 0),
+	CHAN2G(14, 2484, 0)
+};
+
+#define RATETAB_ENT(_rate, _hw_value, _flags) {        \
+	.bitrate  = (_rate),                    \
+	.hw_value = (_hw_value),                \
+	.flags    = (_flags),                   \
+}
+
+static struct ieee80211_rate wilc_bitrates[] = {
+	RATETAB_ENT(10,  0,  0),
+	RATETAB_ENT(20,  1,  0),
+	RATETAB_ENT(55,  2,  0),
+	RATETAB_ENT(110, 3,  0),
+	RATETAB_ENT(60,  9,  0),
+	RATETAB_ENT(90,  6,  0),
+	RATETAB_ENT(120, 7,  0),
+	RATETAB_ENT(180, 8,  0),
+	RATETAB_ENT(240, 9,  0),
+	RATETAB_ENT(360, 10, 0),
+	RATETAB_ENT(480, 11, 0),
+	RATETAB_ENT(540, 12, 0)
+};
+
+struct wilc_priv {
+	struct wireless_dev wdev;
+	struct cfg80211_scan_request *scan_req;
+	struct wilc_wfi_p2p_listen_params remain_on_ch_params;
+	u64 tx_cookie;
+	bool cfg_scanning;
+	u8 associated_bss[ETH_ALEN];
+	struct sta_info assoc_stainfo;
+	struct sk_buff *skb;
+	struct net_device *dev;	//TODO:need to remove it
+	struct host_if_drv *hif_drv;
+	struct wilc_pmkid_attr pmkid_list;
+	u8 wep_key[4][WLAN_KEY_LEN_WEP104];
+	u8 wep_key_len[4];
+
+	/* The real interface that the monitor is on */
+	struct net_device *real_ndev;
+	struct wilc_wfi_key *wilc_gtk[WILC_MAX_NUM_STA];
+	struct wilc_wfi_key *wilc_ptk[WILC_MAX_NUM_STA];
+	u8 wilc_groupkey;
+
+	struct mutex scan_req_lock;
+
+	struct wilc_buffered_eap *buffered_eap;
+
+	struct timer_list eap_buff_timer;
+	int scanned_cnt;
+	struct wilc_p2p_var p2p;
+	u64 inc_roc_cookie;
+};
+
+struct frame_reg {
+	u16 type;
+	bool reg;
+};
+
+#define MAX_TCP_SESSION                25
+#define MAX_PENDING_ACKS               256
+
+struct ack_session_info {
+	u32 seq_num;
+	u32 bigger_ack_num;
+	u16 src_port;
+	u16 dst_port;
+	u16 status;
+};
+
+struct pending_acks {
+	u32 ack_num;
+	u32 session_index;
+	struct txq_entry_t  *txqe;
+};
+
+struct tcp_ack_filter {
+	struct ack_session_info ack_session_info[2 * MAX_TCP_SESSION];
+	struct pending_acks pending_acks[MAX_PENDING_ACKS];
+	u32 pending_base;
+	u32 tcp_session;
+	u32 pending_acks_idx;
+	bool enabled;
+};
+
+#define WILC_P2P_ROLE_GO	1
+#define WILC_P2P_ROLE_CLIENT	0
+
+struct sysfs_attr_group {
+	bool p2p_mode;
+	u8 ant_swtch_mode;
+	u8 antenna1;
+	u8 antenna2;
+};
+
+struct wilc_vif {
+	u8 idx;
+	u8 iftype;
+	int monitor_flag;
+	int mac_opened;
+	struct frame_reg frame_reg[NUM_REG_FRAME];
+	struct net_device_stats netstats;
+	struct wilc *wilc;
+	u8 bssid[ETH_ALEN];
+	struct host_if_drv *hif_drv;
+	struct net_device *ndev;
+
+	struct rf_info periodic_stats;
+	struct timer_list periodic_rssi;
+	struct tcp_ack_filter ack_filter;
+	bool connecting;
+	struct wilc_priv priv;
+	struct list_head list;
+	u8 restart;
+	bool p2p_listen_state;
+	struct cfg80211_bss *bss;
+};
+
+struct wilc_power_gpios {
+	int reset;
+	int chip_en;
+};
+
+struct wilc_power {
+	struct wilc_power_gpios gpios;
+	u8 status[DEV_MAX];
+};
+
+struct wilc {
+	struct wiphy *wiphy;
+	const struct wilc_hif_func *hif_func;
+	int io_type;
+	s8 mac_status;
+	struct clk *rtc_clk;
+	bool initialized;
+	int dev_irq_num;
+	int close;
+	u8 vif_num;
+	struct list_head vif_list;
+	struct srcu_struct srcu;
+
+	/* protect vif list queue */
+	struct mutex vif_mutex;
+	u8 open_ifcs;
+
+	/* protect head of transmit queue */
+	struct mutex txq_add_to_head_cs;
+
+	/* protect txq_entry_t transmit queue */
+	spinlock_t txq_spinlock;
+
+	/* protect rxq_entry_t receiver queue */
+	struct mutex rxq_cs;
+
+	/* lock to protect hif access */
+	struct mutex hif_cs;
+
+	struct completion cfg_event;
+	struct completion sync_event;
+	struct completion txq_event;
+	struct completion txq_thread_started;
+	struct completion debug_thread_started;
+	struct task_struct *txq_thread;
+	struct task_struct *debug_thread;
+
+	int quit;
+
+	/* lock to protect issue of wid command to fw */
+	struct mutex cfg_cmd_lock;
+	struct wilc_cfg_frame cfg_frame;
+	u32 cfg_frame_offset;
+	u8 cfg_seq_no;
+
+	u8 *rx_buffer;
+	u32 rx_buffer_offset;
+	u8 *tx_buffer;
+
+	struct txq_handle txq[NQUEUES];
+	int txq_entries;
+
+	struct rxq_entry_t rxq_head;
+
+	const struct firmware *firmware;
+
+	struct device *dev;
+	struct device *dt_dev;
+
+	enum wilc_chip_type chip;
+
+	struct wilc_power power;
+	uint8_t keep_awake[DEV_MAX];
+	struct mutex cs;
+	struct workqueue_struct *hif_workqueue;
+
+	struct wilc_cfg cfg;
+	void *bus_data;
+	struct net_device *monitor_dev;
+
+	/* deinit lock */
+	struct mutex deinit_lock;
+	u8 sta_ch;
+	u8 op_ch;
+	struct sysfs_attr_group attr_sysfs;
+	struct ieee80211_channel channels[ARRAY_SIZE(wilc_2ghz_channels)];
+	struct ieee80211_rate bitrates[ARRAY_SIZE(wilc_bitrates)];
+	struct ieee80211_supported_band band;
+	u32 cipher_suites[ARRAY_SIZE(wilc_cipher_suites)];
+};
+
+struct wilc_wfi_mon_priv {
+	struct net_device *real_ndev;
+};
+
+void wilc_frmw_to_host(struct wilc_vif *vif, u8 *buff, u32 size,
+		       u32 pkt_offset, u8 status);
+void wilc_mac_indicate(struct wilc *wilc);
+void wilc_netdev_cleanup(struct wilc *wilc);
+void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size);
+void wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode);
+struct wilc_vif *
+wilc_netdev_ifc_init(struct wilc *wl, const char *name, int iftype,
+		     enum nl80211_iftype type, bool rtnl_locked);
+int wilc_bt_power_up(struct wilc *wilc, int source);
+int wilc_bt_power_down(struct wilc *wilc, int source);
+
+#endif
diff --git a/drivers/staging/wilc1000/power.c b/drivers/staging/wilc1000/power.c
new file mode 100644
index 000000000..1b788e081
--- /dev/null
+++ b/drivers/staging/wilc1000/power.c
@@ -0,0 +1,103 @@
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/version.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+
+#include "netdev.h"
+
+/**
+ * wilc_of_parse_power_pins() - parse power sequence pins; to keep backward
+ *		compatibility with old device trees that doesn't provide
+ *		power sequence pins we check for default pins on proper boards
+ *
+ * @wilc:	wilc data structure
+ *
+ * Returns:	 0 on success, negative error number on failures.
+ */
+int wilc_of_parse_power_pins(struct wilc *wilc)
+{
+	static const struct wilc_power_gpios default_gpios[] = {
+		{ .reset = GPIO_NUM_RESET,	.chip_en = GPIO_NUM_CHIP_EN, },
+	};
+
+	static const struct of_device_id wilc_default_pins_ids[] = {
+		{
+			.compatible = "atmel,sama5d4-xplained",
+			.data = &default_gpios[0],
+		},
+		{ /* Sentinel. */ }
+	};
+
+	struct device_node *of = wilc->dt_dev->of_node;
+	struct wilc_power *power = &wilc->power;
+	const struct wilc_power_gpios *gpios;
+	const struct of_device_id *of_id;
+	struct device_node *np;
+	int ret = 0;
+
+	/*
+	 * The maching here is to keep backward compatibility with old DT that
+	 * doesn't provide reset-gpios and chip_en.
+	 */
+	np = of_find_matching_node_and_match(NULL, wilc_default_pins_ids,
+					     &of_id);
+	if (np)
+		gpios = of_id->data;
+
+	power->gpios.reset = of_get_named_gpio_flags(of, "reset-gpios", 0,
+						     NULL);
+	if (!gpio_is_valid(power->gpios.reset) && np)
+		power->gpios.reset = gpios->reset;
+	else
+		goto put_node;
+
+	power->gpios.chip_en = of_get_named_gpio_flags(of, "chip_en-gpios", 0,
+						       NULL);
+	if (!gpio_is_valid(power->gpios.chip_en) && np)
+		power->gpios.chip_en = gpios->chip_en;
+	else
+		goto put_node;
+
+	ret = devm_gpio_request(wilc->dev, power->gpios.chip_en, "CHIP_EN");
+	if (ret)
+		goto put_node;
+
+	ret = devm_gpio_request(wilc->dev, power->gpios.reset, "RESET");
+	if (ret)
+		goto put_node;
+
+	return 0;
+
+put_node:
+	of_node_put(np);
+	return ret;
+}
+
+/**
+ * wilc_wlan_power() - handle power on/off commands
+ *
+ * @wilc:	wilc data structure
+ * @on:		requested power status
+ *
+ * Returns:	none
+ */
+void wilc_wlan_power(struct wilc *wilc, bool on)
+{
+	if (!gpio_is_valid(wilc->power.gpios.chip_en) ||
+	    !gpio_is_valid(wilc->power.gpios.reset)) {
+		/* In case SDIO power sequence driver is used to power this
+		 * device then the powering sequence is handled by the bus
+		 * via pm_runtime_* functions. */
+		return;
+	}
+
+	if (on) {
+		gpio_direction_output(wilc->power.gpios.chip_en, 1);
+		mdelay(5);
+		gpio_direction_output(wilc->power.gpios.reset, 1);
+	} else {
+		gpio_direction_output(wilc->power.gpios.chip_en, 0);
+		gpio_direction_output(wilc->power.gpios.reset, 0);
+	}
+}
diff --git a/drivers/staging/wilc1000/wilc_sdio.c b/drivers/staging/wilc1000/sdio.c
similarity index 62%
rename from drivers/staging/wilc1000/wilc_sdio.c
rename to drivers/staging/wilc1000/sdio.c
index c787c5da8..90be674a7 100644
--- a/drivers/staging/wilc1000/wilc_sdio.c
+++ b/drivers/staging/wilc1000/sdio.c
@@ -7,11 +7,31 @@
 #include <linux/clk.h>
 #include <linux/mmc/sdio_func.h>
 #include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/mmc/sdio.h>
+#include <linux/of_irq.h>
+
+#include "netdev.h"
+#include "wlan.h"
+#include "cfg80211.h"
+
+enum sdio_host_lock {
+	WILC_SDIO_HOST_NO_TAKEN = 0,
+	WILC_SDIO_HOST_IRQ_TAKEN = 1,
+	WILC_SDIO_HOST_DIS_TAKEN = 2,
+};
+
+static enum sdio_host_lock	sdio_intr_lock = WILC_SDIO_HOST_NO_TAKEN;
+static wait_queue_head_t sdio_intr_waitqueue;
 
-#include "wilc_wfi_netdevice.h"
-#include "wilc_wfi_cfgoperations.h"
+static bool enable_oob_interrupt;
+module_param(enable_oob_interrupt, bool, 0644);
+MODULE_PARM_DESC(enable_oob_interrupt,
+		 "enables sdio out-of-band interrupt support");
 
-#define SDIO_MODALIAS "wilc1000_sdio"
+#define SDIO_MODALIAS "wilc_sdio"
 
 #define SDIO_VENDOR_ID_WILC 0x0296
 #define SDIO_DEVICE_ID_WILC 0x5347
@@ -26,10 +46,8 @@ static const struct sdio_device_id wilc_sdio_ids[] = {
 struct wilc_sdio {
 	bool irq_gpio;
 	u32 block_size;
-	int nint;
-/* Max num interrupts allowed in registers 0xf7, 0xf8 */
-#define MAX_NUN_INT_THRPT_ENH2 (5)
-	int has_thrpt_enh3;
+	bool is_init;
+	struct wilc *wl;
 };
 
 struct sdio_cmd52 {
@@ -55,9 +73,14 @@ static const struct wilc_hif_func wilc_hif_sdio;
 
 static void wilc_sdio_interrupt(struct sdio_func *func)
 {
+	if (sdio_intr_lock == WILC_SDIO_HOST_DIS_TAKEN)
+		return;
+	sdio_intr_lock = WILC_SDIO_HOST_IRQ_TAKEN;
 	sdio_release_host(func);
 	wilc_handle_isr(sdio_get_drvdata(func));
 	sdio_claim_host(func);
+	sdio_intr_lock = WILC_SDIO_HOST_NO_TAKEN;
+	wake_up_interruptible(&sdio_intr_waitqueue);
 }
 
 static int wilc_sdio_cmd52(struct wilc *wilc, struct sdio_cmd52 *cmd)
@@ -123,57 +146,93 @@ static int wilc_sdio_probe(struct sdio_func *func,
 			   const struct sdio_device_id *id)
 {
 	struct wilc *wilc;
-	int ret;
-	struct gpio_desc *gpio = NULL;
+	int ret, io_type;
+	static bool init_power;
 	struct wilc_sdio *sdio_priv;
+	struct device_node *np;
+	int irq_num;
 
 	sdio_priv = kzalloc(sizeof(*sdio_priv), GFP_KERNEL);
 	if (!sdio_priv)
 		return -ENOMEM;
 
-	if (IS_ENABLED(CONFIG_WILC1000_HW_OOB_INTR)) {
-		gpio = gpiod_get(&func->dev, "irq", GPIOD_IN);
-		if (IS_ERR(gpio)) {
-			/* get the GPIO descriptor from hardcode GPIO number */
-			gpio = gpio_to_desc(GPIO_NUM);
-			if (!gpio)
-				dev_err(&func->dev, "failed to get irq gpio\n");
-		}
-	}
-
-	ret = wilc_cfg80211_init(&wilc, &func->dev, WILC_HIF_SDIO,
-				 &wilc_hif_sdio);
+	if (enable_oob_interrupt)
+		io_type = WILC_HIF_SDIO_GPIO_IRQ;
+	else
+		io_type = WILC_HIF_SDIO;
+	dev_dbg(&func->dev, "Initializing netdev\n");
+	ret = wilc_cfg80211_init(&wilc, &func->dev, io_type, &wilc_hif_sdio);
 	if (ret) {
-		kfree(sdio_priv);
-		return ret;
+		dev_err(&func->dev, "Couldn't initialize netdev\n");
+		goto free;
 	}
 	sdio_set_drvdata(func, wilc);
 	wilc->bus_data = sdio_priv;
 	wilc->dev = &func->dev;
-	wilc->gpio_irq = gpio;
-
-	wilc->rtc_clk = devm_clk_get(&func->card->dev, "rtc_clk");
-	if (PTR_ERR_OR_ZERO(wilc->rtc_clk) == -EPROBE_DEFER)
-		return -EPROBE_DEFER;
-	else if (!IS_ERR(wilc->rtc_clk))
+	wilc->dt_dev = &func->card->dev;
+	sdio_priv->wl = wilc;
+
+	irq_num = of_irq_get(func->card->dev.of_node, 0);
+	if (irq_num > 0)
+		wilc->dev_irq_num = irq_num;
+
+	wilc->rtc_clk = devm_clk_get(&func->card->dev, "rtc");
+	if (PTR_ERR_OR_ZERO(wilc->rtc_clk) == -EPROBE_DEFER) {
+		ret = -EPROBE_DEFER;
+		goto dispose_irq;
+	} else if (!IS_ERR(wilc->rtc_clk)) {
 		clk_prepare_enable(wilc->rtc_clk);
+	}
+
+	/*
+	 * Some WILC SDIO setups needs a SD power sequence driver to be able
+	 * to power the WILC devices before reaching this function. For those
+	 * devices the power sequence driver already provides reset-gpios
+	 * and chip_en-gpios.
+	 */
+	np = of_parse_phandle(func->card->host->parent->of_node, "mmc-pwrseq",
+			      0);
+	if (np && of_device_is_available(np)) {
+		init_power = 1;
+		of_node_put(np);
+	} else {
+		ret = wilc_of_parse_power_pins(wilc);
+		if (ret)
+			goto disable_rtc_clk;
+	}
+
+
+	if (!init_power) {
+		wilc_wlan_power(wilc, false);
+		init_power = 1;
+		wilc_wlan_power(wilc, true);
+	}
+
+	wilc_bt_init(wilc);
 
 	dev_info(&func->dev, "Driver Initializing success\n");
 	return 0;
+
+disable_rtc_clk:
+	if (!IS_ERR(wilc->rtc_clk))
+		clk_disable_unprepare(wilc->rtc_clk);
+dispose_irq:
+	irq_dispose_mapping(wilc->dev_irq_num);
+	wilc_netdev_cleanup(wilc);
+free:
+	kfree(sdio_priv);
+	return ret;
 }
 
 static void wilc_sdio_remove(struct sdio_func *func)
 {
 	struct wilc *wilc = sdio_get_drvdata(func);
 
-	/* free the GPIO in module remove */
-	if (wilc->gpio_irq)
-		gpiod_put(wilc->gpio_irq);
-
 	if (!IS_ERR(wilc->rtc_clk))
 		clk_disable_unprepare(wilc->rtc_clk);
 
 	wilc_netdev_cleanup(wilc);
+	wilc_bt_deinit();
 }
 
 static int wilc_sdio_reset(struct wilc *wilc)
@@ -182,17 +241,24 @@ static int wilc_sdio_reset(struct wilc *wilc)
 	int ret;
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 
+	dev_info(&func->dev, "De Init SDIO\n");
+
 	cmd.read_write = 1;
 	cmd.function = 0;
 	cmd.raw = 0;
-	cmd.address = 0x6;
-	cmd.data = 0x8;
+	cmd.address = SDIO_CCCR_ABORT;
+	cmd.data = WILC_SDIO_CCCR_ABORT_RESET;
 	ret = wilc_sdio_cmd52(wilc, &cmd);
-	if (ret) {
-		dev_err(&func->dev, "Fail cmd 52, reset cmd ...\n");
-		return ret;
-	}
-	return 0;
+	if (ret)
+		dev_err(&func->dev, "Fail cmd 52, reset cmd\n");
+	return ret;
+}
+
+static bool wilc_sdio_is_init(struct wilc *wilc)
+{
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
+
+	return sdio_priv->is_init;
 }
 
 static int wilc_sdio_suspend(struct device *dev)
@@ -201,23 +267,20 @@ static int wilc_sdio_suspend(struct device *dev)
 	struct wilc *wilc = sdio_get_drvdata(func);
 	int ret;
 
-	dev_info(dev, "sdio suspend\n");
-	chip_wakeup(wilc);
+	dev_info(&func->dev, "sdio suspend\n");
+	mutex_lock(&wilc->hif_cs);
 
-	if (!IS_ERR(wilc->rtc_clk))
-		clk_disable_unprepare(wilc->rtc_clk);
+	chip_wakeup(wilc, 0);
 
-	if (wilc->suspend_event) {
-		host_sleep_notify(wilc);
-		chip_allow_sleep(wilc);
-	}
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_sleep_notify(wilc, 0);
+	chip_allow_sleep(wilc, 0);
+
+	mutex_lock(&wilc->hif_cs);
 
 	ret = wilc_sdio_reset(wilc);
-	if (ret) {
-		dev_err(&func->dev, "Fail reset sdio\n");
-		return ret;
-	}
-	sdio_claim_host(func);
 
 	return 0;
 }
@@ -227,6 +290,8 @@ static int wilc_sdio_enable_interrupt(struct wilc *dev)
 	struct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);
 	int ret = 0;
 
+	sdio_intr_lock  = WILC_SDIO_HOST_NO_TAKEN;
+
 	sdio_claim_host(func);
 	ret = sdio_claim_irq(func, wilc_sdio_interrupt);
 	sdio_release_host(func);
@@ -243,11 +308,19 @@ static void wilc_sdio_disable_interrupt(struct wilc *dev)
 	struct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);
 	int ret;
 
+	dev_info(&func->dev, "%s\n", __func__);
+
+	if (sdio_intr_lock  == WILC_SDIO_HOST_IRQ_TAKEN)
+		wait_event_interruptible(sdio_intr_waitqueue,
+				   sdio_intr_lock == WILC_SDIO_HOST_NO_TAKEN);
+	sdio_intr_lock  = WILC_SDIO_HOST_DIS_TAKEN;
+
 	sdio_claim_host(func);
 	ret = sdio_release_irq(func);
 	if (ret < 0)
 		dev_err(&func->dev, "can't release sdio_irq, err(%d)\n", ret);
 	sdio_release_host(func);
+	sdio_intr_lock  = WILC_SDIO_HOST_NO_TAKEN;
 }
 
 /********************************************
@@ -268,36 +341,35 @@ static int wilc_sdio_set_func0_csa_address(struct wilc *wilc, u32 adr)
 	cmd.read_write = 1;
 	cmd.function = 0;
 	cmd.raw = 0;
-	cmd.address = 0x10c;
+	cmd.address = WILC_SDIO_FBR_CSA_REG;
 	cmd.data = (u8)adr;
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x10c data...\n");
-		goto fail;
+		return ret;
 	}
 
-	cmd.address = 0x10d;
+	cmd.address = WILC_SDIO_FBR_CSA_REG + 1;
 	cmd.data = (u8)(adr >> 8);
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x10d data...\n");
-		goto fail;
+		return ret;
 	}
 
-	cmd.address = 0x10e;
+	cmd.address = WILC_SDIO_FBR_CSA_REG + 2;
 	cmd.data = (u8)(adr >> 16);
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x10e data...\n");
-		goto fail;
+		return ret;
 	}
 
-	return 1;
-fail:
 	return 0;
 }
 
-static int wilc_sdio_set_func0_block_size(struct wilc *wilc, u32 block_size)
+static int wilc_sdio_set_block_size(struct wilc *wilc, u8 func_num,
+				    u32 block_size)
 {
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	struct sdio_cmd52 cmd;
@@ -306,59 +378,24 @@ static int wilc_sdio_set_func0_block_size(struct wilc *wilc, u32 block_size)
 	cmd.read_write = 1;
 	cmd.function = 0;
 	cmd.raw = 0;
-	cmd.address = 0x10;
+	cmd.address = SDIO_FBR_BASE(func_num) + SDIO_CCCR_BLKSIZE;
 	cmd.data = (u8)block_size;
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
-		dev_err(&func->dev, "Failed cmd52, set 0x10 data...\n");
-		goto fail;
-	}
-
-	cmd.address = 0x11;
-	cmd.data = (u8)(block_size >> 8);
-	ret = wilc_sdio_cmd52(wilc, &cmd);
-	if (ret) {
-		dev_err(&func->dev, "Failed cmd52, set 0x11 data...\n");
-		goto fail;
+		dev_err(&func->dev, "Failed cmd52, set %04x data...\n",
+			cmd.address);
+		return ret;
 	}
 
-	return 1;
-fail:
-	return 0;
-}
-
-/********************************************
- *
- *      Function 1
- *
- ********************************************/
-
-static int wilc_sdio_set_func1_block_size(struct wilc *wilc, u32 block_size)
-{
-	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
-	struct sdio_cmd52 cmd;
-	int ret;
-
-	cmd.read_write = 1;
-	cmd.function = 0;
-	cmd.raw = 0;
-	cmd.address = 0x110;
-	cmd.data = (u8)block_size;
-	ret = wilc_sdio_cmd52(wilc, &cmd);
-	if (ret) {
-		dev_err(&func->dev, "Failed cmd52, set 0x110 data...\n");
-		goto fail;
-	}
-	cmd.address = 0x111;
+	cmd.address = SDIO_FBR_BASE(func_num) + SDIO_CCCR_BLKSIZE +  1;
 	cmd.data = (u8)(block_size >> 8);
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
-		dev_err(&func->dev, "Failed cmd52, set 0x111 data...\n");
-		goto fail;
+		dev_err(&func->dev, "Failed cmd52, set %04x data...\n",
+			cmd.address);
+		return ret;
 	}
 
-	return 1;
-fail:
 	return 0;
 }
 
@@ -375,7 +412,7 @@ static int wilc_sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 
 	cpu_to_le32s(&data);
 
-	if (addr >= 0xf0 && addr <= 0xff) {
+	if (addr >= 0xf0 && addr <= 0xff) { /* only vendor specific registers */
 		struct sdio_cmd52 cmd;
 
 		cmd.read_write = 1;
@@ -386,8 +423,8 @@ static int wilc_sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 		ret = wilc_sdio_cmd52(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
-				"Failed cmd 52, read reg (%08x) ...\n", addr);
-			goto fail;
+				"Failed cmd 52, write reg %08x ...\n", addr);
+			return ret;
 		}
 	} else {
 		struct sdio_cmd53 cmd;
@@ -395,12 +432,13 @@ static int wilc_sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 		/**
 		 *      set the AHB address
 		 **/
-		if (!wilc_sdio_set_func0_csa_address(wilc, addr))
-			goto fail;
+		ret = wilc_sdio_set_func0_csa_address(wilc, addr);
+		if (ret)
+			return ret;
 
 		cmd.read_write = 1;
 		cmd.function = 0;
-		cmd.address = 0x10f;
+		cmd.address = WILC_SDIO_FBR_DATA_REG;
 		cmd.block_mode = 0;
 		cmd.increment = 1;
 		cmd.count = 4;
@@ -410,14 +448,10 @@ static int wilc_sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53, write reg (%08x)...\n", addr);
-			goto fail;
+			return ret;
 		}
 	}
 
-	return 1;
-
-fail:
-
 	return 0;
 }
 
@@ -431,28 +465,12 @@ static int wilc_sdio_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 
 	cmd.read_write = 1;
 	if (addr > 0) {
-		/**
-		 *      has to be word aligned...
-		 **/
-		if (size & 0x3) {
-			size += 4;
-			size &= ~0x3;
-		}
-
 		/**
 		 *      func 0 access
 		 **/
 		cmd.function = 0;
-		cmd.address = 0x10f;
+		cmd.address = WILC_SDIO_FBR_DATA_REG;
 	} else {
-		/**
-		 *      has to be word aligned...
-		 **/
-		if (size & 0x3) {
-			size += 4;
-			size &= ~0x3;
-		}
-
 		/**
 		 *      func 1 access
 		 **/
@@ -460,6 +478,7 @@ static int wilc_sdio_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 		cmd.address = 0;
 	}
 
+	size = ALIGN(size, 4);
 	nblk = size / block_size;
 	nleft = size % block_size;
 
@@ -470,14 +489,15 @@ static int wilc_sdio_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 		cmd.buffer = buf;
 		cmd.block_size = block_size;
 		if (addr > 0) {
-			if (!wilc_sdio_set_func0_csa_address(wilc, addr))
-				goto fail;
+			ret = wilc_sdio_set_func0_csa_address(wilc, addr);
+			if (ret)
+				return ret;
 		}
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53 [%x], block send...\n", addr);
-			goto fail;
+			return ret;
 		}
 		if (addr > 0)
 			addr += nblk * block_size;
@@ -493,21 +513,18 @@ static int wilc_sdio_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 		cmd.block_size = block_size;
 
 		if (addr > 0) {
-			if (!wilc_sdio_set_func0_csa_address(wilc, addr))
-				goto fail;
+			ret = wilc_sdio_set_func0_csa_address(wilc, addr);
+			if (ret)
+				return ret;
 		}
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53 [%x], bytes send...\n", addr);
-			goto fail;
+			return ret;
 		}
 	}
 
-	return 1;
-
-fail:
-
 	return 0;
 }
 
@@ -517,7 +534,7 @@ static int wilc_sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	int ret;
 
-	if (addr >= 0xf0 && addr <= 0xff) {
+	if (addr >= 0xf0 && addr <= 0xff) { /* only vendor specific registers */
 		struct sdio_cmd52 cmd;
 
 		cmd.read_write = 0;
@@ -528,18 +545,19 @@ static int wilc_sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd 52, read reg (%08x) ...\n", addr);
-			goto fail;
+			return ret;
 		}
 		*data = cmd.data;
 	} else {
 		struct sdio_cmd53 cmd;
 
-		if (!wilc_sdio_set_func0_csa_address(wilc, addr))
-			goto fail;
+		ret = wilc_sdio_set_func0_csa_address(wilc, addr);
+		if (ret)
+			return ret;
 
 		cmd.read_write = 0;
 		cmd.function = 0;
-		cmd.address = 0x10f;
+		cmd.address = WILC_SDIO_FBR_DATA_REG;
 		cmd.block_mode = 0;
 		cmd.increment = 1;
 		cmd.count = 4;
@@ -550,16 +568,11 @@ static int wilc_sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53, read reg (%08x)...\n", addr);
-			goto fail;
+			return ret;
 		}
 	}
 
 	le32_to_cpus(data);
-
-	return 1;
-
-fail:
-
 	return 0;
 }
 
@@ -573,35 +586,20 @@ static int wilc_sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 
 	cmd.read_write = 0;
 	if (addr > 0) {
-		/**
-		 *      has to be word aligned...
-		 **/
-		if (size & 0x3) {
-			size += 4;
-			size &= ~0x3;
-		}
-
 		/**
 		 *      func 0 access
 		 **/
 		cmd.function = 0;
-		cmd.address = 0x10f;
+		cmd.address = WILC_SDIO_FBR_DATA_REG;
 	} else {
-		/**
-		 *      has to be word aligned...
-		 **/
-		if (size & 0x3) {
-			size += 4;
-			size &= ~0x3;
-		}
-
 		/**
 		 *      func 1 access
 		 **/
 		cmd.function = 1;
-		cmd.address = 0;
+		cmd.address = WILC_SDIO_F1_DATA_REG;
 	}
 
+	size = ALIGN(size, 4);
 	nblk = size / block_size;
 	nleft = size % block_size;
 
@@ -612,14 +610,15 @@ static int wilc_sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 		cmd.buffer = buf;
 		cmd.block_size = block_size;
 		if (addr > 0) {
-			if (!wilc_sdio_set_func0_csa_address(wilc, addr))
-				goto fail;
+			ret = wilc_sdio_set_func0_csa_address(wilc, addr);
+			if (ret)
+				return ret;
 		}
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53 [%x], block read...\n", addr);
-			goto fail;
+			return ret;
 		}
 		if (addr > 0)
 			addr += nblk * block_size;
@@ -635,21 +634,18 @@ static int wilc_sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 		cmd.block_size = block_size;
 
 		if (addr > 0) {
-			if (!wilc_sdio_set_func0_csa_address(wilc, addr))
-				goto fail;
+			ret = wilc_sdio_set_func0_csa_address(wilc, addr);
+			if (ret)
+				return ret;
 		}
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53 [%x], bytes read...\n", addr);
-			goto fail;
+			return ret;
 		}
 	}
 
-	return 1;
-
-fail:
-
 	return 0;
 }
 
@@ -661,7 +657,15 @@ static int wilc_sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 
 static int wilc_sdio_deinit(struct wilc *wilc)
 {
-	return 1;
+	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
+
+	sdio_priv->is_init = false;
+
+	pm_runtime_put_sync_autosuspend(mmc_dev(func->card->host));
+	wilc_wlan_power(wilc, false);
+
+	return 0;
 }
 
 static int wilc_sdio_init(struct wilc *wilc, bool resume)
@@ -672,8 +676,18 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 	int loop, ret;
 	u32 chipid;
 
-	if (!resume)
-		sdio_priv->irq_gpio = wilc->dev_irq_num;
+	dev_info(&func->dev, "SDIO speed: %d\n",
+		func->card->host->ios.clock);
+
+	/* Patch for sdio interrupt latency issue */
+	ret = pm_runtime_get_sync(mmc_dev(func->card->host));
+	if (ret < 0) {
+		pm_runtime_put_noidle(mmc_dev(func->card->host));
+		return ret;
+	}
+
+	init_waitqueue_head(&sdio_intr_waitqueue);
+	sdio_priv->irq_gpio = (wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ);
 
 	/**
 	 *      function 0 csa enable
@@ -681,20 +695,21 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 	cmd.read_write = 1;
 	cmd.function = 0;
 	cmd.raw = 1;
-	cmd.address = 0x100;
-	cmd.data = 0x80;
+	cmd.address = SDIO_FBR_BASE(1);
+	cmd.data = SDIO_FBR_ENABLE_CSA;
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Fail cmd 52, enable csa...\n");
-		goto fail;
+		goto pm_runtime_put;
 	}
 
 	/**
 	 *      function 0 block size
 	 **/
-	if (!wilc_sdio_set_func0_block_size(wilc, WILC_SDIO_BLOCK_SIZE)) {
+	ret = wilc_sdio_set_block_size(wilc, 0, WILC_SDIO_BLOCK_SIZE);
+	if (ret) {
 		dev_err(&func->dev, "Fail cmd 52, set func 0 block size...\n");
-		goto fail;
+		goto pm_runtime_put;
 	}
 	sdio_priv->block_size = WILC_SDIO_BLOCK_SIZE;
 
@@ -704,13 +719,13 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 	cmd.read_write = 1;
 	cmd.function = 0;
 	cmd.raw = 1;
-	cmd.address = 0x2;
-	cmd.data = 0x2;
+	cmd.address = SDIO_CCCR_IOEx;
+	cmd.data = WILC_SDIO_CCCR_IO_EN_FUNC1;
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev,
 			"Fail cmd 52, set IOE register...\n");
-		goto fail;
+		goto pm_runtime_put;
 	}
 
 	/**
@@ -719,7 +734,7 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 	cmd.read_write = 0;
 	cmd.function = 0;
 	cmd.raw = 0;
-	cmd.address = 0x3;
+	cmd.address = SDIO_CCCR_IORx;
 	loop = 3;
 	do {
 		cmd.data = 0;
@@ -727,23 +742,24 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 		if (ret) {
 			dev_err(&func->dev,
 				"Fail cmd 52, get IOR register...\n");
-			goto fail;
+			goto pm_runtime_put;
 		}
-		if (cmd.data == 0x2)
+		if (cmd.data == WILC_SDIO_CCCR_IO_EN_FUNC1)
 			break;
 	} while (loop--);
 
 	if (loop <= 0) {
 		dev_err(&func->dev, "Fail func 1 is not ready...\n");
-		goto fail;
+		goto pm_runtime_put;
 	}
 
 	/**
 	 *      func 1 is ready, set func 1 block size
 	 **/
-	if (!wilc_sdio_set_func1_block_size(wilc, WILC_SDIO_BLOCK_SIZE)) {
+	ret = wilc_sdio_set_block_size(wilc, 1, WILC_SDIO_BLOCK_SIZE);
+	if (ret) {
 		dev_err(&func->dev, "Fail set func 1 block size...\n");
-		goto fail;
+		goto pm_runtime_put;
 	}
 
 	/**
@@ -752,36 +768,37 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 	cmd.read_write = 1;
 	cmd.function = 0;
 	cmd.raw = 1;
-	cmd.address = 0x4;
-	cmd.data = 0x3;
+	cmd.address = SDIO_CCCR_IENx;
+	cmd.data = WILC_SDIO_CCCR_IEN_MASTER | WILC_SDIO_CCCR_IEN_FUNC1;
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Fail cmd 52, set IEN register...\n");
-		goto fail;
+		goto pm_runtime_put;
 	}
 
 	/**
 	 *      make sure can read back chip id correctly
 	 **/
 	if (!resume) {
-		if (!wilc_sdio_read_reg(wilc, 0x1000, &chipid)) {
-			dev_err(&func->dev, "Fail cmd read chip id...\n");
-			goto fail;
+		chipid = wilc_get_chipid(wilc, true);
+		if (is_wilc3000(chipid)) {
+			wilc->chip = WILC_3000;
+		} else if (is_wilc1000(chipid)) {
+			wilc->chip = WILC_1000;
+		} else {
+			dev_err(&func->dev, "Unsupported chipid: %x\n", chipid);
+			goto pm_runtime_put;
 		}
-		dev_err(&func->dev, "chipid (%08x)\n", chipid);
-		if ((chipid & 0xfff) > 0x2a0)
-			sdio_priv->has_thrpt_enh3 = 1;
-		else
-			sdio_priv->has_thrpt_enh3 = 0;
-		dev_info(&func->dev, "has_thrpt_enh3 = %d...\n",
-			 sdio_priv->has_thrpt_enh3);
+		dev_info(&func->dev, "chipid %08x\n", chipid);
 	}
 
-	return 1;
-
-fail:
+	sdio_priv->is_init = true;
 
 	return 0;
+
+pm_runtime_put:
+	pm_runtime_put_sync_autosuspend(mmc_dev(func->card->host));
+	return ret;
 }
 
 static int wilc_sdio_read_size(struct wilc *wilc, u32 *size)
@@ -795,18 +812,18 @@ static int wilc_sdio_read_size(struct wilc *wilc, u32 *size)
 	cmd.read_write = 0;
 	cmd.function = 0;
 	cmd.raw = 0;
-	cmd.address = 0xf2;
+	cmd.address = WILC_SDIO_INTERRUPT_DATA_SZ_REG;
 	cmd.data = 0;
 	wilc_sdio_cmd52(wilc, &cmd);
 	tmp = cmd.data;
 
-	cmd.address = 0xf3;
+	cmd.address = WILC_SDIO_INTERRUPT_DATA_SZ_REG + 1;
 	cmd.data = 0;
 	wilc_sdio_cmd52(wilc, &cmd);
 	tmp |= (cmd.data << 8);
 
 	*size = tmp;
-	return 1;
+	return 0;
 }
 
 static int wilc_sdio_read_int(struct wilc *wilc, u32 *int_status)
@@ -815,57 +832,47 @@ static int wilc_sdio_read_int(struct wilc *wilc, u32 *int_status)
 	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	u32 tmp;
 	struct sdio_cmd52 cmd;
+	u32 irq_flags;
 
-	wilc_sdio_read_size(wilc, &tmp);
+	if (sdio_priv->irq_gpio) {
+		wilc_sdio_read_size(wilc, &tmp);
 
-	/**
-	 *      Read IRQ flags
-	 **/
-	if (!sdio_priv->irq_gpio) {
-		int i;
+		cmd.read_write = 0;
+		cmd.function = 0;
+		cmd.raw = 0;
+		cmd.data = 0;
+		if (wilc->chip == WILC_1000) {
+			cmd.address = WILC1000_SDIO_IRQ_FLAG_REG;
+			wilc_sdio_cmd52(wilc, &cmd);
+			irq_flags = cmd.data & 0x1f;
+		} else {
+			cmd.address = WILC3000_SDIO_IRQ_FLAG_REG;
+			wilc_sdio_cmd52(wilc, &cmd);
+			irq_flags = cmd.data & 0x0f;
+		}
+		tmp |= FIELD_PREP(IRG_FLAGS_MASK, cmd.data);
 
+		*int_status = tmp;
+	} else {
+		wilc_sdio_read_size(wilc, &tmp);
 		cmd.read_write = 0;
 		cmd.function = 1;
-		cmd.address = 0x04;
+		cmd.address = WILC_SDIO_EXT_IRQ_FLAG_REG;
 		cmd.data = 0;
 		wilc_sdio_cmd52(wilc, &cmd);
 
-		if (cmd.data & BIT(0))
-			tmp |= INT_0;
-		if (cmd.data & BIT(2))
-			tmp |= INT_1;
-		if (cmd.data & BIT(3))
-			tmp |= INT_2;
-		if (cmd.data & BIT(4))
-			tmp |= INT_3;
-		if (cmd.data & BIT(5))
-			tmp |= INT_4;
-		if (cmd.data & BIT(6))
-			tmp |= INT_5;
-		for (i = sdio_priv->nint; i < MAX_NUM_INT; i++) {
-			if ((tmp >> (IRG_FLAGS_OFFSET + i)) & 0x1) {
-				dev_err(&func->dev,
-					"Unexpected interrupt (1) : tmp=%x, data=%x\n",
-					tmp, cmd.data);
-				break;
-			}
+		irq_flags = cmd.data;
+		tmp |= FIELD_PREP(IRG_FLAGS_MASK, cmd.data);
+
+		if (FIELD_GET(UNHANDLED_IRQ_MASK, irq_flags)) {
+			dev_err(&func->dev, "Unexpected interrupt (1) int=%lx\n",
+				FIELD_GET(UNHANDLED_IRQ_MASK, irq_flags));
 		}
-	} else {
-		u32 irq_flags;
 
-		cmd.read_write = 0;
-		cmd.function = 0;
-		cmd.raw = 0;
-		cmd.address = 0xf7;
-		cmd.data = 0;
-		wilc_sdio_cmd52(wilc, &cmd);
-		irq_flags = cmd.data & 0x1f;
-		tmp |= ((irq_flags >> 0) << IRG_FLAGS_OFFSET);
+		*int_status = tmp;
 	}
 
-	*int_status = tmp;
-
-	return 1;
+	return 0;
 }
 
 static int wilc_sdio_clear_int_ext(struct wilc *wilc, u32 val)
@@ -873,19 +880,12 @@ static int wilc_sdio_clear_int_ext(struct wilc *wilc, u32 val)
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	int ret;
-	int vmm_ctl;
+	u32 reg = 0;
 
-	if (sdio_priv->has_thrpt_enh3) {
-		u32 reg;
+	if (wilc->chip == WILC_1000) {
+		if (sdio_priv->irq_gpio)
+			reg = val & (BIT(MAX_NUM_INT) - 1);
 
-		if (sdio_priv->irq_gpio) {
-			u32 flags;
-
-			flags = val & (BIT(MAX_NUN_INT_THRPT_ENH2) - 1);
-			reg = flags;
-		} else {
-			reg = 0;
-		}
 		/* select VMM table 0 */
 		if (val & SEL_VMM_TBL0)
 			reg |= BIT(5);
@@ -901,7 +901,7 @@ static int wilc_sdio_clear_int_ext(struct wilc *wilc, u32 val)
 			cmd.read_write = 1;
 			cmd.function = 0;
 			cmd.raw = 0;
-			cmd.address = 0xf8;
+			cmd.address = WILC1000_SDIO_IRQ_CLEAR_FLAG_REG;
 			cmd.data = reg;
 
 			ret = wilc_sdio_cmd52(wilc, &cmd);
@@ -909,87 +909,60 @@ static int wilc_sdio_clear_int_ext(struct wilc *wilc, u32 val)
 				dev_err(&func->dev,
 					"Failed cmd52, set 0xf8 data (%d) ...\n",
 					__LINE__);
-				goto fail;
+				return ret;
 			}
 		}
-		return 1;
-	}
-	if (sdio_priv->irq_gpio) {
-		/* has_thrpt_enh2 uses register 0xf8 to clear interrupts. */
-		/*
-		 * Cannot clear multiple interrupts.
-		 * Must clear each interrupt individually.
-		 */
-		u32 flags;
-
-		flags = val & (BIT(MAX_NUM_INT) - 1);
-		if (flags) {
-			int i;
-
-			ret = 1;
-			for (i = 0; i < sdio_priv->nint; i++) {
-				if (flags & 1) {
-					struct sdio_cmd52 cmd;
-
-					cmd.read_write = 1;
-					cmd.function = 0;
-					cmd.raw = 0;
-					cmd.address = 0xf8;
-					cmd.data = BIT(i);
-
-					ret = wilc_sdio_cmd52(wilc, &cmd);
-					if (ret) {
-						dev_err(&func->dev,
-							"Failed cmd52, set 0xf8 data (%d) ...\n",
-							__LINE__);
-						goto fail;
-					}
-				}
-				if (!ret)
-					break;
-				flags >>= 1;
-			}
-			if (!ret)
-				goto fail;
-			for (i = sdio_priv->nint; i < MAX_NUM_INT; i++) {
-				if (flags & 1)
+	} else {
+		if (sdio_priv->irq_gpio) {
+			reg = val & (BIT(MAX_NUM_INT) - 1);
+			if (reg) {
+				struct sdio_cmd52 cmd;
+
+				cmd.read_write = 1;
+				cmd.function = 0;
+				cmd.raw = 0;
+				cmd.address = WILC3000_SDIO_IRQ_CLEAR_FLAG_REG;
+				cmd.data = reg;
+
+				ret = wilc_sdio_cmd52(wilc, &cmd);
+				if (ret) {
 					dev_err(&func->dev,
-						"Unexpected interrupt cleared %d...\n",
-						i);
-				flags >>= 1;
+						"Failed cmd52, set 0xfe data (%d) ...\n",
+						__LINE__);
+					return ret;
+				}
 			}
 		}
-	}
+		reg = 0;
+		/* select VMM table 0 */
+		if (val & SEL_VMM_TBL0)
+			reg |= BIT(0);
+		/* select VMM table 1 */
+		if (val & SEL_VMM_TBL1)
+			reg |= BIT(1);
+		/* enable VMM */
+		if (val & EN_VMM)
+			reg |= BIT(2);
 
-	vmm_ctl = 0;
-	/* select VMM table 0 */
-	if (val & SEL_VMM_TBL0)
-		vmm_ctl |= BIT(0);
-	/* select VMM table 1 */
-	if (val & SEL_VMM_TBL1)
-		vmm_ctl |= BIT(1);
-	/* enable VMM */
-	if (val & EN_VMM)
-		vmm_ctl |= BIT(2);
-
-	if (vmm_ctl) {
-		struct sdio_cmd52 cmd;
+		if (reg) {
+			struct sdio_cmd52 cmd;
 
-		cmd.read_write = 1;
-		cmd.function = 0;
-		cmd.raw = 0;
-		cmd.address = 0xf6;
-		cmd.data = vmm_ctl;
-		ret = wilc_sdio_cmd52(wilc, &cmd);
-		if (ret) {
-			dev_err(&func->dev,
-				"Failed cmd52, set 0xf6 data (%d) ...\n",
-				__LINE__);
-			goto fail;
+			cmd.read_write = 1;
+			cmd.function = 0;
+			cmd.raw = 0;
+			cmd.address = WILC3000_SDIO_VMM_TBL_CTRL_REG;
+			cmd.data = reg;
+
+			ret = wilc_sdio_cmd52(wilc, &cmd);
+			if (ret) {
+				dev_err(&func->dev,
+					"Failed cmd52, set 0xf6 data (%d) ...\n",
+					__LINE__);
+				return ret;
+			}
 		}
 	}
-	return 1;
-fail:
+
 	return 0;
 }
 
@@ -998,94 +971,89 @@ static int wilc_sdio_sync_ext(struct wilc *wilc, int nint)
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	u32 reg;
+	int ret, i;
 
 	if (nint > MAX_NUM_INT) {
-		dev_err(&func->dev, "Too many interrupts (%d)...\n", nint);
-		return 0;
+		dev_err(&func->dev, "Too many interrupts %d\n", nint);
+		return -EINVAL;
 	}
-	if (nint > MAX_NUN_INT_THRPT_ENH2) {
-		dev_err(&func->dev,
-			"Cannot support more than 5 interrupts when has_thrpt_enh2=1.\n");
-		return 0;
-	}
-
-	sdio_priv->nint = nint;
 
-	/**
-	 *      Disable power sequencer
-	 **/
-	if (!wilc_sdio_read_reg(wilc, WILC_MISC, &reg)) {
-		dev_err(&func->dev, "Failed read misc reg...\n");
-		return 0;
-	}
-
-	reg &= ~BIT(8);
-	if (!wilc_sdio_write_reg(wilc, WILC_MISC, reg)) {
-		dev_err(&func->dev, "Failed write misc reg...\n");
-		return 0;
+/* WILC3000 only. Was removed in WILC1000 on revision 6200.
+ * Might be related to suspend/resume
+ */
+	if (wilc->chip == WILC_3000) {
+		/**
+		 *      Disable power sequencer
+		 **/
+		if (wilc_sdio_read_reg(wilc, WILC_MISC, &reg)) {
+			dev_err(&func->dev, "Failed read misc reg\n");
+			return -EINVAL;
+		}
+		reg &= ~BIT(8);
+		if (wilc_sdio_write_reg(wilc, WILC_MISC, reg)) {
+			dev_err(&func->dev, "Failed write misc reg\n");
+			return -EINVAL;
+		}
 	}
 
 	if (sdio_priv->irq_gpio) {
-		u32 reg;
-		int ret, i;
-
 		/**
 		 *      interrupt pin mux select
 		 **/
 		ret = wilc_sdio_read_reg(wilc, WILC_PIN_MUX_0, &reg);
-		if (!ret) {
+		if (ret) {
 			dev_err(&func->dev, "Failed read reg (%08x)...\n",
 				WILC_PIN_MUX_0);
-			return 0;
+			return ret;
 		}
 		reg |= BIT(8);
 		ret = wilc_sdio_write_reg(wilc, WILC_PIN_MUX_0, reg);
-		if (!ret) {
+		if (ret) {
 			dev_err(&func->dev, "Failed write reg (%08x)...\n",
 				WILC_PIN_MUX_0);
-			return 0;
+			return ret;
 		}
 
 		/**
 		 *      interrupt enable
 		 **/
 		ret = wilc_sdio_read_reg(wilc, WILC_INTR_ENABLE, &reg);
-		if (!ret) {
+		if (ret) {
 			dev_err(&func->dev, "Failed read reg (%08x)...\n",
 				WILC_INTR_ENABLE);
-			return 0;
+			return ret;
 		}
 
 		for (i = 0; (i < 5) && (nint > 0); i++, nint--)
 			reg |= BIT((27 + i));
 		ret = wilc_sdio_write_reg(wilc, WILC_INTR_ENABLE, reg);
-		if (!ret) {
+		if (ret) {
 			dev_err(&func->dev, "Failed write reg (%08x)...\n",
 				WILC_INTR_ENABLE);
-			return 0;
+			return ret;
 		}
 		if (nint) {
 			ret = wilc_sdio_read_reg(wilc, WILC_INTR2_ENABLE, &reg);
-			if (!ret) {
+			if (ret) {
 				dev_err(&func->dev,
 					"Failed read reg (%08x)...\n",
 					WILC_INTR2_ENABLE);
-				return 0;
+				return ret;
 			}
 
 			for (i = 0; (i < 3) && (nint > 0); i++, nint--)
 				reg |= BIT(i);
 
-			ret = wilc_sdio_read_reg(wilc, WILC_INTR2_ENABLE, &reg);
-			if (!ret) {
+			ret = wilc_sdio_write_reg(wilc, WILC_INTR2_ENABLE, reg);
+			if (ret) {
 				dev_err(&func->dev,
 					"Failed write reg (%08x)...\n",
 					WILC_INTR2_ENABLE);
-				return 0;
+				return ret;
 			}
 		}
 	}
-	return 1;
+	return 0;
 }
 
 /* Global sdio HIF function table */
@@ -1104,6 +1072,8 @@ static const struct wilc_hif_func wilc_hif_sdio = {
 	.hif_sync_ext = wilc_sdio_sync_ext,
 	.enable_interrupt = wilc_sdio_enable_interrupt,
 	.disable_interrupt = wilc_sdio_disable_interrupt,
+	.hif_reset = wilc_sdio_reset,
+	.hif_is_init = wilc_sdio_is_init,
 };
 
 static int wilc_sdio_resume(struct device *dev)
@@ -1111,22 +1081,29 @@ static int wilc_sdio_resume(struct device *dev)
 	struct sdio_func *func = dev_to_sdio_func(dev);
 	struct wilc *wilc = sdio_get_drvdata(func);
 
-	dev_info(dev, "sdio resume\n");
-	sdio_release_host(func);
-	chip_wakeup(wilc);
+	dev_info(&func->dev, "sdio resume\n");
+	chip_wakeup(wilc, 0);
 	wilc_sdio_init(wilc, true);
 
-	if (wilc->suspend_event)
-		host_wakeup_notify(wilc);
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_wakeup_notify(wilc, 0);
 
-	chip_allow_sleep(wilc);
+	mutex_lock(&wilc->hif_cs);
+
+	chip_allow_sleep(wilc, 0);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
 
 	return 0;
 }
 
 static const struct of_device_id wilc_of_match[] = {
-	{ .compatible = "microchip,wilc1000-sdio", },
-	{ /* sentinel */ }
+	{ .compatible = "microchip,wilc1000", },
+	{ .compatible = "microchip,wilc3000", },
+	{ /* sentinel */}
 };
 MODULE_DEVICE_TABLE(of, wilc_of_match);
 
@@ -1149,3 +1126,5 @@ module_driver(wilc_sdio_driver,
 	      sdio_register_driver,
 	      sdio_unregister_driver);
 MODULE_LICENSE("GPL");
+MODULE_VERSION("15.4.1");
+
diff --git a/drivers/staging/wilc1000/spi.c b/drivers/staging/wilc1000/spi.c
new file mode 100644
index 000000000..634454a00
--- /dev/null
+++ b/drivers/staging/wilc1000/spi.c
@@ -0,0 +1,1283 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
+#include <linux/module.h>
+#include <linux/crc7.h>
+
+#include "netdev.h"
+#include "cfg80211.h"
+
+struct wilc_spi {
+	int crc_off;
+	bool is_init;
+};
+
+static const struct wilc_hif_func wilc_hif_spi;
+
+static int wilc_spi_rx(struct wilc *wilc, u8 *rb, u32 rlen);
+static int wilc_spi_reset(struct wilc *wilc);
+
+static u8 wilc_get_crc7(u8 *buffer, u32 len)
+{
+	return crc7_be(0xfe, (const u8 *)buffer, len);
+}
+
+/********************************************
+ *
+ *      Spi protocol Function
+ *
+ ********************************************/
+
+#define CMD_DMA_WRITE				0xc1
+#define CMD_DMA_READ				0xc2
+#define CMD_INTERNAL_WRITE			0xc3
+#define CMD_INTERNAL_READ			0xc4
+#define CMD_TERMINATE				0xc5
+#define CMD_REPEAT				0xc6
+#define CMD_DMA_EXT_WRITE			0xc7
+#define CMD_DMA_EXT_READ			0xc8
+#define CMD_SINGLE_WRITE			0xc9
+#define CMD_SINGLE_READ				0xca
+#define CMD_RESET				0xcf
+
+#define SPI_RESP_RETRY_COUNT			(10)
+#define SPI_RETRY_COUNT				(10)
+#define SPI_ENABLE_VMM_RETRY_LIMIT		2
+#define DATA_PKT_SZ_256				256
+#define DATA_PKT_SZ_512				512
+#define DATA_PKT_SZ_1K				1024
+#define DATA_PKT_SZ_2K				(2 * 1024)
+#define DATA_PKT_SZ_4K				(4 * 1024)
+#define DATA_PKT_SZ_8K				(8 * 1024)
+#define DATA_PKT_SZ				DATA_PKT_SZ_8K
+
+#define USE_SPI_DMA				0
+
+#define WILC_SPI_COMMAND_STAT_SUCCESS		0
+#define WILC_GET_RESP_HDR_START(h)		(((h) >> 4) & 0xf)
+
+struct wilc_spi_cmd {
+	u8 cmd_type;
+	union {
+		struct {
+			u8 addr[3];
+			u8 crc[];
+		} __packed simple_cmd;
+		struct {
+			u8 addr[3];
+			u8 size[2];
+			u8 crc[];
+		} __packed dma_cmd;
+		struct {
+			u8 addr[3];
+			u8 size[3];
+			u8 crc[];
+		} __packed dma_cmd_ext;
+		struct {
+			u8 addr[2];
+			__be32 data;
+			u8 crc[];
+		} __packed internal_w_cmd;
+		struct {
+			u8 addr[3];
+			__be32 data;
+			u8 crc[];
+		} __packed w_cmd;
+	} u;
+} __packed;
+
+struct wilc_spi_read_rsp_data {
+	u8 header;
+	u8 data[4];
+	u8 crc[];
+} __packed;
+
+struct wilc_spi_rsp_data {
+	u8 rsp_cmd_type;
+	u8 status;
+	u8 data[];
+} __packed;
+
+struct wilc_spi_special_cmd_rsp {
+	u8 skip_byte;
+	u8 rsp_cmd_type;
+	u8 status;
+} __packed;
+
+static int wilc_bus_probe(struct spi_device *spi)
+{
+	int ret;
+	static bool init_power;
+	struct wilc *wilc;
+	struct device *dev = &spi->dev;
+	struct wilc_spi *spi_priv;
+
+	dev_info(&spi->dev, "spiModalias: %s, spiMax-Speed: %d\n",
+			spi->modalias, spi->max_speed_hz);
+
+	spi_priv = kzalloc(sizeof(*spi_priv), GFP_KERNEL);
+	if (!spi_priv)
+		return -ENOMEM;
+
+	ret = wilc_cfg80211_init(&wilc, dev, WILC_HIF_SPI, &wilc_hif_spi);
+	if (ret)
+		goto free;
+
+	spi_set_drvdata(spi, wilc);
+	wilc->dev = &spi->dev;
+	wilc->bus_data = spi_priv;
+	wilc->dt_dev = &spi->dev;
+	wilc->dev_irq_num = spi->irq;
+
+	wilc->rtc_clk = devm_clk_get(&spi->dev, "rtc");
+	if (PTR_ERR_OR_ZERO(wilc->rtc_clk) == -EPROBE_DEFER)
+		goto netdev_cleanup;
+	else if (!IS_ERR(wilc->rtc_clk))
+		clk_prepare_enable(wilc->rtc_clk);
+
+	ret = wilc_of_parse_power_pins(wilc);
+	if (ret)
+		goto disable_rtc_clk;
+
+	if (!init_power) {
+		wilc_wlan_power(wilc, false);
+		init_power = 1;
+		wilc_wlan_power(wilc, true);
+	}
+
+	wilc_bt_init(wilc);
+
+	dev_info(dev, "WILC SPI probe success\n");
+	return 0;
+
+disable_rtc_clk:
+	if (!IS_ERR(wilc->rtc_clk))
+		clk_disable_unprepare(wilc->rtc_clk);
+netdev_cleanup:
+	wilc_netdev_cleanup(wilc);
+free:
+	kfree(spi_priv);
+	return ret;
+}
+
+static int wilc_bus_remove(struct spi_device *spi)
+{
+	struct wilc *wilc = spi_get_drvdata(spi);
+
+	if (!IS_ERR(wilc->rtc_clk))
+		clk_disable_unprepare(wilc->rtc_clk);
+
+	wilc_netdev_cleanup(wilc);
+	wilc_bt_deinit();
+	return 0;
+}
+
+static int wilc_spi_suspend(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct wilc *wilc = spi_get_drvdata(spi);
+
+	dev_info(&spi->dev, "\n\n << SUSPEND >>\n\n");
+	mutex_lock(&wilc->hif_cs);
+	chip_wakeup(wilc, 0);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	/* notify the chip that host will sleep */
+	host_sleep_notify(wilc, 0);
+	chip_allow_sleep(wilc, 0);
+	mutex_lock(&wilc->hif_cs);
+
+	return 0;
+}
+
+static int wilc_spi_resume(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct wilc *wilc = spi_get_drvdata(spi);
+
+	dev_info(&spi->dev, "\n\n  <<RESUME>>\n\n");
+
+	/* wake the chip to compelete the re-intialization */
+	chip_wakeup(wilc, 0);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_wakeup_notify(wilc, 0);
+
+	mutex_lock(&wilc->hif_cs);
+
+	chip_allow_sleep(wilc, 0);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	return 0;
+}
+
+static const struct of_device_id wilc_of_match[] = {
+	{ .compatible = "microchip,wilc1000", },
+	{ .compatible = "microchip,wilc3000", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, wilc_of_match);
+static const struct dev_pm_ops wilc_spi_pm_ops = {
+	.suspend = wilc_spi_suspend,
+	.resume = wilc_spi_resume,
+};
+
+static struct spi_driver wilc_spi_driver = {
+	.driver = {
+		.name = MODALIAS,
+		.of_match_table = wilc_of_match,
+		.pm = &wilc_spi_pm_ops,
+	},
+	.probe =  wilc_bus_probe,
+	.remove = wilc_bus_remove,
+};
+module_spi_driver(wilc_spi_driver);
+MODULE_LICENSE("GPL");
+MODULE_VERSION("15.4.1");
+
+static int spi_data_rsp(struct wilc *wilc, u8 cmd)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
+	u8 len;
+	u8 rsp[3];
+	int result;
+
+	if (!spi_priv->crc_off)
+		len = 2;
+	else
+		len = 3;
+
+	result = wilc_spi_rx(wilc, &rsp[0], len);
+	if (result) {
+		dev_err(&spi->dev, "Failed bus error...\n");
+		return result;
+	}
+
+	if ((rsp[len-1] != 0) || (rsp[len-2] != 0xC3)) {
+		dev_err(&spi->dev, "Failed data response read, %x %x %x\n",
+			rsp[0], rsp[1], rsp[2]);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int wilc_spi_tx(struct wilc *wilc, u8 *b, u32 len)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	int ret;
+	struct spi_message msg;
+
+	if (len > 0 && b) {
+		struct spi_transfer tr = {
+			.tx_buf = b,
+			.len = len,
+#if KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE
+			.delay = {
+			.value = 0,
+			.unit = SPI_DELAY_UNIT_USECS
+			},
+#else
+			.delay_usecs = 0,
+#endif
+		};
+		char *r_buffer = kzalloc(len, GFP_KERNEL);
+
+		if (!r_buffer)
+			return -ENOMEM;
+
+		tr.rx_buf = r_buffer;
+		dev_dbg(&spi->dev, "Request writing %d bytes\n", len);
+
+		memset(&msg, 0, sizeof(msg));
+		spi_message_init(&msg);
+		msg.spi = spi;
+		msg.is_dma_mapped = USE_SPI_DMA;
+		spi_message_add_tail(&tr, &msg);
+
+		ret = spi_sync(spi, &msg);
+		if (ret < 0)
+			dev_err(&spi->dev, "SPI transaction failed\n");
+
+		kfree(r_buffer);
+	} else {
+		dev_err(&spi->dev,
+			"can't write data with the following length: %d\n",
+			len);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int wilc_spi_rx(struct wilc *wilc, u8 *rb, u32 rlen)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	int ret;
+
+	if (rlen > 0) {
+		struct spi_message msg;
+		struct spi_transfer tr = {
+			.rx_buf = rb,
+			.len = rlen,
+#if KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE
+						.delay = {
+						.value = 0,
+						.unit = SPI_DELAY_UNIT_USECS
+						},
+#else
+			.delay_usecs = 0,
+#endif
+		};
+		char *t_buffer = kzalloc(rlen, GFP_KERNEL);
+
+		if (!t_buffer)
+			return -ENOMEM;
+
+		tr.tx_buf = t_buffer;
+
+		memset(&msg, 0, sizeof(msg));
+		spi_message_init(&msg);
+		msg.spi = spi;
+		msg.is_dma_mapped = USE_SPI_DMA;
+		spi_message_add_tail(&tr, &msg);
+
+		ret = spi_sync(spi, &msg);
+		if (ret < 0)
+			dev_err(&spi->dev, "SPI transaction failed\n");
+		kfree(t_buffer);
+	} else {
+		dev_err(&spi->dev,
+			"can't read data with the following length: %u\n",
+			rlen);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int wilc_spi_tx_rx(struct wilc *wilc, u8 *wb, u8 *rb, u32 rlen)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	int ret;
+
+	if (rlen > 0) {
+		struct spi_message msg;
+		struct spi_transfer tr = {
+			.rx_buf = rb,
+			.tx_buf = wb,
+			.len = rlen,
+			.bits_per_word = 8,
+#if KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE
+						.delay = {
+						.value = 0,
+						.unit = SPI_DELAY_UNIT_USECS
+						},
+#else
+			.delay_usecs = 0,
+#endif
+		};
+
+		memset(&msg, 0, sizeof(msg));
+		spi_message_init(&msg);
+		msg.spi = spi;
+		msg.is_dma_mapped = USE_SPI_DMA;
+
+		spi_message_add_tail(&tr, &msg);
+		ret = spi_sync(spi, &msg);
+		if (ret < 0)
+			dev_err(&spi->dev, "SPI transaction failed\n");
+	} else {
+		dev_err(&spi->dev,
+			"can't read data with the following length: %u\n",
+			rlen);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
+	int ix, nbytes;
+	int result = 0;
+	u8 cmd, order, crc[2] = {0};
+
+	/*
+	 * Data
+	 */
+	ix = 0;
+	do {
+		if (sz <= DATA_PKT_SZ) {
+			nbytes = sz;
+			order = 0x3;
+		} else {
+			nbytes = DATA_PKT_SZ;
+			if (ix == 0)
+				order = 0x1;
+			else
+				order = 0x02;
+		}
+
+		/*
+		 * Write command
+		 */
+		cmd = 0xf0;
+		cmd |= order;
+
+		result = wilc_spi_tx(wilc, &cmd, 1);
+		if (result) {
+			dev_err(&spi->dev,
+				"Failed data block cmd write, bus error...\n");
+			break;
+		}
+
+		/*
+		 * Write data
+		 */
+		result = wilc_spi_tx(wilc, &b[ix], nbytes);
+		if (result) {
+			dev_err(&spi->dev,
+				"Failed data block write, bus error...\n");
+			break;
+		}
+
+		/*
+		 * Write Crc
+		 */
+		if (!spi_priv->crc_off) {
+			result = wilc_spi_tx(wilc, crc, 2);
+			if (result) {
+				dev_err(&spi->dev, "Failed data block crc write, bus error...\n");
+				break;
+			}
+		}
+
+		/*
+		 * No need to wait for response
+		 */
+		ix += nbytes;
+		sz -= nbytes;
+	} while (sz);
+
+	return result;
+}
+
+/********************************************
+ *
+ *      Spi Internal Read/Write Function
+ *
+ ********************************************/
+#define WILC_SPI_RSP_HDR_EXTRA_DATA (3)
+static int wilc_spi_single_read(struct wilc *wilc, u8 cmd, u32 adr, void *b,
+				u8 clockless)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
+	u8 wb[32], rb[32];
+	int cmd_len, resp_len = 0;
+	u8 crc[2];
+	struct wilc_spi_cmd *c;
+	struct wilc_spi_rsp_data *rsp;
+	struct wilc_spi_read_rsp_data *r_data;
+	int i = 0;
+
+	memset(wb, 0x0, sizeof(wb));
+	memset(rb, 0x0, sizeof(rb));
+	c = (struct wilc_spi_cmd *)wb;
+	c->cmd_type = cmd;
+	if (cmd == CMD_SINGLE_READ) {
+		c->u.simple_cmd.addr[0] = adr >> 16;
+		c->u.simple_cmd.addr[1] = adr >> 8;
+		c->u.simple_cmd.addr[2] = adr;
+	} else if (cmd == CMD_INTERNAL_READ) { /* internal register read */
+		c->u.simple_cmd.addr[0] = adr >> 8;
+		if (clockless == 1)
+			c->u.simple_cmd.addr[0] |= BIT(7);
+		c->u.simple_cmd.addr[1] = adr;
+		c->u.simple_cmd.addr[2] = 0x0;
+	} else {
+		dev_err(&spi->dev, "cmd [%x] not supported\n", cmd);
+		return -EINVAL;
+	}
+
+	cmd_len = offsetof(struct wilc_spi_cmd, u.simple_cmd.crc);
+	resp_len = sizeof(*rsp) + sizeof(*r_data) + WILC_SPI_RSP_HDR_EXTRA_DATA;
+
+	if (!spi_priv->crc_off) {
+		c->u.simple_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);
+		cmd_len += 1;
+		resp_len += 2;
+	}
+
+	if (cmd_len + resp_len > ARRAY_SIZE(wb)) {
+		dev_err(&spi->dev, "spi buffer size too small (%d) (%d )(%zu)\n",
+			cmd_len, resp_len, ARRAY_SIZE(wb));
+		return -EINVAL;
+	}
+
+	if (wilc_spi_tx_rx(wilc, wb, rb, cmd_len + resp_len)) {
+		dev_err(&spi->dev, "Failed cmd write, bus error...\n");
+		return -EINVAL;
+	}
+
+	rsp = (struct wilc_spi_rsp_data *)&rb[cmd_len];
+	/*
+	 * Clockless registers operations might return unexptected responses,
+	 * even if successful.
+	 */
+	if (rsp->rsp_cmd_type != cmd && !clockless) {
+		dev_err(&spi->dev,
+			"Failed cmd response, cmd (%02x), resp (%02x)\n",
+			cmd, rsp->rsp_cmd_type);
+		return -EINVAL;
+	}
+
+	if (rsp->status != WILC_SPI_COMMAND_STAT_SUCCESS && !clockless) {
+		dev_err(&spi->dev, "Failed cmd state response state (%02x)\n",
+			rsp->status);
+		return -EINVAL;
+	}
+
+	do {
+		if (WILC_GET_RESP_HDR_START(rsp->data[i]) == 0xf)
+			break;
+		i++;
+	} while (i < SPI_RESP_RETRY_COUNT);
+
+	if (i >= SPI_RESP_RETRY_COUNT) {
+		dev_err(&spi->dev, "Error, data read response\n");
+		return -EINVAL;
+	}
+
+	r_data = (struct wilc_spi_read_rsp_data *)&rsp->data[i];
+
+	if (b)
+		memcpy(b, r_data->data, 4);
+
+	if (!spi_priv->crc_off)
+		memcpy(crc, r_data->crc, 2);
+
+	return 0;
+}
+
+static int wilc_spi_write_cmd(struct wilc *wilc, u8 cmd, u32 adr, u32 data,
+			      u8 clockless)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
+	u8 wb[32], rb[32];
+	u32 cmd_len, resp_len;
+	struct wilc_spi_cmd *c;
+	struct wilc_spi_rsp_data *r;
+
+	memset(wb, 0x0, sizeof(wb));
+	memset(rb, 0x0, sizeof(rb));
+	c = (struct wilc_spi_cmd *)wb;
+	c->cmd_type = cmd;
+	if (cmd == CMD_INTERNAL_WRITE) { /* internal register write */
+		c->u.internal_w_cmd.addr[0] = adr >> 8;
+		if (clockless == 1)
+			c->u.internal_w_cmd.addr[0] |= BIT(7);
+
+		c->u.internal_w_cmd.addr[1] = adr;
+		c->u.internal_w_cmd.data = cpu_to_be32(data);
+		cmd_len = offsetof(struct wilc_spi_cmd, u.internal_w_cmd.crc);
+		if (!spi_priv->crc_off)
+			c->u.internal_w_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);
+	} else if (cmd == CMD_SINGLE_WRITE) {
+		c->u.w_cmd.addr[0] = adr >> 16;
+		c->u.w_cmd.addr[1] = adr >> 8;
+		c->u.w_cmd.addr[2] = adr;
+		c->u.w_cmd.data = cpu_to_be32(data);
+		cmd_len = offsetof(struct wilc_spi_cmd, u.w_cmd.crc);
+		if (!spi_priv->crc_off)
+			c->u.w_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);
+	} else {
+		return -EINVAL;
+	}
+
+	if (!spi_priv->crc_off)
+		cmd_len += 1;
+
+	resp_len = sizeof(*r);
+
+	if (cmd_len + resp_len > ARRAY_SIZE(wb)) {
+		dev_err(&spi->dev,
+			"spi buffer size too small (%d) (%d) (%zu)\n",
+			cmd_len, resp_len, ARRAY_SIZE(wb));
+		return -EINVAL;
+	}
+
+	if (wilc_spi_tx_rx(wilc, wb, rb, cmd_len + resp_len)) {
+		dev_err(&spi->dev, "Failed cmd write, bus error...\n");
+		return -EINVAL;
+	}
+
+	r = (struct wilc_spi_rsp_data *)&rb[cmd_len];
+	/*
+	 * Clockless registers operations might return unexptected responses,
+	 * even if successful.
+	 */
+	if (r->rsp_cmd_type != cmd && !clockless) {
+		dev_err(&spi->dev,
+			"Failed cmd response, cmd (%02x), resp (%02x)\n",
+			cmd, r->rsp_cmd_type);
+		return -EINVAL;
+	}
+
+	if (r->status != WILC_SPI_COMMAND_STAT_SUCCESS && !clockless) {
+		dev_err(&spi->dev, "Failed cmd state response state (%02x)\n",
+			r->status);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int wilc_spi_dma_rw(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
+	u8 wb[32], rb[32];
+	int cmd_len, resp_len;
+	int retry, ix = 0;
+	u8 crc[2];
+	struct wilc_spi_cmd *c;
+	struct wilc_spi_rsp_data *r;
+
+	memset(wb, 0x0, sizeof(wb));
+	memset(rb, 0x0, sizeof(rb));
+	c = (struct wilc_spi_cmd *)wb;
+	c->cmd_type = cmd;
+	if (cmd == CMD_DMA_WRITE || cmd == CMD_DMA_READ) {
+		c->u.dma_cmd.addr[0] = adr >> 16;
+		c->u.dma_cmd.addr[1] = adr >> 8;
+		c->u.dma_cmd.addr[2] = adr;
+		c->u.dma_cmd.size[0] = sz >> 8;
+		c->u.dma_cmd.size[1] = sz;
+		cmd_len = offsetof(struct wilc_spi_cmd, u.dma_cmd.crc);
+		if (!spi_priv->crc_off)
+			c->u.dma_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);
+	} else if (cmd == CMD_DMA_EXT_WRITE || cmd == CMD_DMA_EXT_READ) {
+		c->u.dma_cmd_ext.addr[0] = adr >> 16;
+		c->u.dma_cmd_ext.addr[1] = adr >> 8;
+		c->u.dma_cmd_ext.addr[2] = adr;
+		c->u.dma_cmd_ext.size[0] = sz >> 16;
+		c->u.dma_cmd_ext.size[1] = sz >> 8;
+		c->u.dma_cmd_ext.size[2] = sz;
+		cmd_len = offsetof(struct wilc_spi_cmd, u.dma_cmd_ext.crc);
+		if (!spi_priv->crc_off)
+			c->u.dma_cmd_ext.crc[0] = wilc_get_crc7(wb, cmd_len);
+	} else {
+		return -EINVAL;
+	}
+
+	if (!spi_priv->crc_off)
+		cmd_len += 1;
+
+	resp_len = sizeof(*r);
+
+	if (cmd_len + resp_len > ARRAY_SIZE(wb)) {
+		dev_err(&spi->dev,
+			"spi buffer size too small (%d) (%d) (%zu)\n",
+			cmd_len, resp_len, ARRAY_SIZE(wb));
+		return -EINVAL;
+	}
+
+	if (wilc_spi_tx_rx(wilc, wb, rb, cmd_len + resp_len)) {
+		dev_err(&spi->dev, "Failed cmd write, bus error...\n");
+		return -EINVAL;
+	}
+
+	r = (struct wilc_spi_rsp_data *)&rb[cmd_len];
+	if (r->rsp_cmd_type != cmd) {
+		dev_err(&spi->dev,
+			"Failed cmd response, cmd (%02x), resp (%02x)\n",
+			cmd, r->rsp_cmd_type);
+		return -EINVAL;
+	}
+
+	if (cmd == CMD_DMA_WRITE || cmd == CMD_DMA_EXT_WRITE)
+		return 0;
+
+	while (sz > 0) {
+		int nbytes;
+		u8 rsp;
+
+		if (sz <= DATA_PKT_SZ)
+			nbytes = sz;
+		else
+			nbytes = DATA_PKT_SZ;
+
+		/*
+		 * Data Respnose header
+		 */
+		retry = SPI_RESP_RETRY_COUNT;
+		do {
+			if (wilc_spi_rx(wilc, &rsp, 1)) {
+				dev_err(&spi->dev,
+					"Failed resp read, bus err\n");
+				return -EINVAL;
+			}
+			if (WILC_GET_RESP_HDR_START(rsp) == 0xf)
+				break;
+		} while (retry--);
+		/*
+		 * Read bytes
+		 */
+		if (wilc_spi_rx(wilc, &b[ix], nbytes)) {
+			dev_err(&spi->dev,
+				"Failed block read, bus err\n");
+			return -EINVAL;
+		}
+
+		/*
+		 * Read Crc
+		 */
+		if (!spi_priv->crc_off && wilc_spi_rx(wilc, crc, 2)) {
+			dev_err(&spi->dev,
+				"Failed block crc read, bus err\n");
+			return -EINVAL;
+		}
+
+		ix += nbytes;
+		sz -= nbytes;
+	}
+	return 0;
+}
+
+static int wilc_spi_special_cmd(struct wilc *wilc, u8 cmd)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
+	u8 wb[32], rb[32];
+	int cmd_len, resp_len = 0;
+	struct wilc_spi_cmd *c;
+	struct wilc_spi_special_cmd_rsp *r;
+
+	if (cmd != CMD_TERMINATE && cmd != CMD_REPEAT && cmd != CMD_RESET)
+		return -EINVAL;
+
+	memset(wb, 0x0, sizeof(wb));
+	memset(rb, 0x0, sizeof(rb));
+	c = (struct wilc_spi_cmd *)wb;
+	c->cmd_type = cmd;
+
+	if (cmd == CMD_RESET)
+		memset(c->u.simple_cmd.addr, 0xFF, 3);
+
+	cmd_len = offsetof(struct wilc_spi_cmd, u.simple_cmd.crc);
+	resp_len = sizeof(*r);
+
+	if (!spi_priv->crc_off) {
+		c->u.simple_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);
+		cmd_len += 1;
+	}
+	if (cmd_len + resp_len > ARRAY_SIZE(wb)) {
+		dev_err(&spi->dev, "spi buffer size too small (%d) (%d) (%zu)\n",
+			cmd_len, resp_len, ARRAY_SIZE(wb));
+		return -EINVAL;
+	}
+
+	if (wilc_spi_tx_rx(wilc, wb, rb, cmd_len + resp_len)) {
+		dev_err(&spi->dev, "Failed cmd write, bus error...\n");
+		return -EINVAL;
+	}
+
+	r = (struct wilc_spi_special_cmd_rsp *)&rb[cmd_len];
+	if (r->rsp_cmd_type != cmd) {
+		dev_err(&spi->dev,
+			"Failed cmd response, cmd (%02x), resp (%02x)\n",
+			cmd, r->rsp_cmd_type);
+		return -EINVAL;
+	}
+
+	if (r->status != WILC_SPI_COMMAND_STAT_SUCCESS) {
+		dev_err(&spi->dev, "Failed cmd state response state (%02x)\n",
+			r->status);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int spi_internal_write(struct wilc *wilc, u32 adr, u32 dat)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	int result;
+	u8 retry = SPI_RETRY_COUNT;
+
+retry:
+	result = wilc_spi_write_cmd(wilc, CMD_INTERNAL_WRITE, adr, dat, 0);
+	if (result) {
+		dev_err(&spi->dev, "Failed internal write cmd...\n");
+		goto fail;
+	}
+
+fail:
+	if (result) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev, "Reset and retry %d %x\n", retry, adr);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
+}
+
+static int spi_internal_read(struct wilc *wilc, u32 adr, u32 *data)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	int result;
+	u8 retry = SPI_RETRY_COUNT;
+
+retry:
+	result = wilc_spi_single_read(wilc, CMD_INTERNAL_READ, adr, data, 0);
+	if (result) {
+		dev_err(&spi->dev, "Failed internal read cmd...\n");
+		goto fail;
+	}
+
+	le32_to_cpus(data);
+
+fail:
+	if (result) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev, "Reset and retry %d %x\n", retry, adr);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
+}
+
+/********************************************
+ *
+ *      Spi interfaces
+ *
+ ********************************************/
+
+static int wilc_spi_write_reg(struct wilc *wilc, u32 addr, u32 data)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	u8 retry = SPI_RETRY_COUNT;
+	int result;
+	u8 cmd = CMD_SINGLE_WRITE;
+	u8 clockless = 0;
+
+_RETRY_:
+	if (addr <= WILC_SPI_CLOCKLESS_ADDR_LIMIT) {
+		/* Clockless register */
+		cmd = CMD_INTERNAL_WRITE;
+		clockless = 1;
+	} else {
+		cmd = CMD_SINGLE_WRITE;
+		clockless = 0;
+	}
+
+	result = wilc_spi_write_cmd(wilc, cmd, addr, data, clockless);
+	if (result) {
+		dev_err(&spi->dev, "Failed cmd, write reg (%08x)...\n", addr);
+		goto fail;
+	}
+
+fail:
+	if (result && !clockless) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev,
+			"Reset and retry %d %x %d\n", retry, addr, data);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto _RETRY_;
+	}
+	return result;
+}
+
+static int wilc_spi_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	int result;
+	u8 retry = SPI_RETRY_COUNT;
+
+	/*
+	 * has to be greated than 4
+	 */
+	if (size <= 4)
+		return -EINVAL;
+
+retry:
+	result = wilc_spi_dma_rw(wilc, CMD_DMA_EXT_WRITE, addr, NULL, size);
+	if (result) {
+		dev_err(&spi->dev,
+			"Failed cmd, write block (%08x)...\n", addr);
+		goto fail;
+	}
+
+	/*
+	 * Data
+	 */
+	result = spi_data_write(wilc, buf, size);
+	if (result) {
+		dev_err(&spi->dev, "Failed block data write...\n");
+		goto fail;
+	}
+	/*
+	 * Data RESP
+	 */
+	result = spi_data_rsp(wilc, CMD_DMA_EXT_WRITE);
+	if (result) {
+		dev_err(&spi->dev, "Failed block data write...\n");
+		goto fail;
+	}
+
+fail:
+	if (result) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev,
+			"Reset and retry %d %x %d\n", retry, addr, size);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
+}
+
+static int wilc_spi_read_reg(struct wilc *wilc, u32 addr, u32 *data)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	u8 retry = SPI_RETRY_COUNT;
+	int result;
+	u8 cmd = CMD_SINGLE_READ;
+	u8 clockless = 0;
+
+retry:
+	if (addr <= WILC_SPI_CLOCKLESS_ADDR_LIMIT) {
+		/* Clockless register */
+		cmd = CMD_INTERNAL_READ;
+		clockless = 1;
+	} else {
+		cmd = CMD_SINGLE_READ;
+		clockless = 0;
+	}
+
+	result = wilc_spi_single_read(wilc, cmd, addr, data, clockless);
+	if (result) {
+		dev_err(&spi->dev, "Failed cmd, read reg (%08x)...\n", addr);
+		goto fail;
+	}
+
+	le32_to_cpus(data);
+
+fail:
+	if (result && !clockless) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_warn(&spi->dev, "Reset and retry %d %x\n", retry, addr);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
+}
+
+static int wilc_spi_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	int result;
+	u8 retry = SPI_RETRY_COUNT;
+
+	if (size <= 4)
+		return -EINVAL;
+
+retry:
+	result = wilc_spi_dma_rw(wilc, CMD_DMA_EXT_READ, addr, buf, size);
+	if (result) {
+		dev_err(&spi->dev, "Failed cmd, read block (%08x)...\n", addr);
+		goto fail;
+	}
+
+fail:
+	if (result) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_warn(&spi->dev, "Reset and retry %d %x %d\n", retry, addr,
+			 size);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
+}
+
+/********************************************
+ *
+ *      Bus interfaces
+ *
+ ********************************************/
+
+static int wilc_spi_reset(struct wilc *wilc)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	int result;
+
+	result = wilc_spi_special_cmd(wilc, CMD_RESET);
+	if (result)
+		dev_err(&spi->dev, "Failed cmd reset\n");
+
+	return result;
+}
+
+static bool wilc_spi_is_init(struct wilc *wilc)
+{
+	struct wilc_spi *spi_priv = wilc->bus_data;
+
+	return spi_priv->is_init;
+}
+
+static int wilc_spi_deinit(struct wilc *wilc)
+{
+	struct wilc_spi *spi_priv = wilc->bus_data;
+
+	/*
+	 * TODO:
+	 */
+	spi_priv->is_init = false;
+	wilc_wlan_power(wilc, false);
+
+	return 0;
+}
+
+static int wilc_spi_init(struct wilc *wilc, bool resume)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
+	u32 reg;
+	u32 chipid;
+	int ret;
+
+	if (spi_priv->is_init) {
+		ret = wilc_spi_read_reg(wilc, WILC_CHIPID, &chipid);
+		if (ret)
+			dev_err(&spi->dev, "Fail cmd read chip id...\n");
+
+		return ret;
+	}
+
+	/*
+	 * configure protocol
+	 */
+
+	/*
+	 * TODO: We can remove the CRC trials if there is a definite
+	 * way to reset
+	 */
+	/* the SPI to it's initial value. */
+	ret = spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg);
+	if (ret) {
+		/*
+		 * Read failed. Try with CRC off. This might happen when module
+		 * is removed but chip isn't reset
+		 */
+		spi_priv->crc_off = 1;
+		dev_err(&spi->dev,
+			"Failed read with CRC on, retrying with CRC off\n");
+		ret = spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg);
+		if (ret) {
+			/*
+			 * Read failed with both CRC on and off,
+			 * something went bad
+			 */
+			dev_err(&spi->dev, "Failed internal read protocol...\n");
+			return ret;
+		}
+	}
+	if (spi_priv->crc_off == 0) {
+		reg &= ~0xc; /* disable crc checking */
+		reg &= ~0x70;
+		reg |= (0x5 << 4);
+		ret = spi_internal_write(wilc, WILC_SPI_PROTOCOL_OFFSET, reg);
+		if (ret) {
+			dev_err(&spi->dev,
+				"[wilc spi %d]: Failed internal write reg\n",
+				__LINE__);
+			return ret;
+		}
+		spi_priv->crc_off = 1;
+	}
+
+	/*
+	 * make sure can read back chip id correctly
+	 */
+	ret = wilc_spi_read_reg(wilc, WILC_CHIPID, &chipid);
+	if (ret) {
+		dev_err(&spi->dev, "Fail cmd read chip id...\n");
+		return ret;
+	}
+
+	if (!resume) {
+		chipid = wilc_get_chipid(wilc, true);
+		if (is_wilc3000(chipid)) {
+			wilc->chip = WILC_3000;
+		} else if (is_wilc1000(chipid)) {
+			wilc->chip = WILC_1000;
+		} else {
+			dev_err(&spi->dev, "Unsupported chipid: %x\n", chipid);
+			return -EINVAL;
+		}
+		dev_dbg(&spi->dev, "chipid %08x\n", chipid);
+	}
+
+	spi_priv->is_init = true;
+	return 0;
+}
+
+static int wilc_spi_read_size(struct wilc *wilc, u32 *size)
+{
+	int ret;
+
+	ret = spi_internal_read(wilc, WILC_SPI_INT_STATUS - WILC_SPI_REG_BASE,
+				size);
+	*size = FIELD_GET(IRQ_DMA_WD_CNT_MASK, *size);
+
+	return ret;
+}
+
+static int wilc_spi_read_int(struct wilc *wilc, u32 *int_status)
+{
+	return spi_internal_read(wilc, WILC_SPI_INT_STATUS - WILC_SPI_REG_BASE,
+				int_status);
+}
+
+static int wilc_spi_clear_int_ext(struct wilc *wilc, u32 val)
+{
+	int ret;
+	int retry = SPI_ENABLE_VMM_RETRY_LIMIT;
+	u32 check;
+
+	while (retry) {
+		ret = spi_internal_write(wilc,
+					 WILC_SPI_INT_CLEAR - WILC_SPI_REG_BASE,
+					 val);
+		if (ret)
+			break;
+
+		ret = spi_internal_read(wilc,
+					WILC_SPI_INT_CLEAR - WILC_SPI_REG_BASE,
+					&check);
+		if (ret || ((check & EN_VMM) == (val & EN_VMM)))
+			break;
+
+		retry--;
+	}
+	return ret;
+}
+
+static int wilc_spi_sync_ext(struct wilc *wilc, int nint)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	u32 reg;
+	int ret, i;
+
+	if (nint > MAX_NUM_INT) {
+		dev_err(&spi->dev, "Too many interrupts (%d)...\n", nint);
+		return -EINVAL;
+	}
+
+	/*
+	 * interrupt pin mux select
+	 */
+	ret = wilc_spi_read_reg(wilc, WILC_PIN_MUX_0, &reg);
+	if (ret) {
+		dev_err(&spi->dev, "Failed read reg (%08x)...\n",
+			WILC_PIN_MUX_0);
+		return ret;
+	}
+	reg |= BIT(8);
+	ret = wilc_spi_write_reg(wilc, WILC_PIN_MUX_0, reg);
+	if (ret) {
+		dev_err(&spi->dev, "Failed write reg (%08x)...\n",
+			WILC_PIN_MUX_0);
+		return ret;
+	}
+
+	/*
+	 * interrupt enable
+	 */
+	ret = wilc_spi_read_reg(wilc, WILC_INTR_ENABLE, &reg);
+	if (ret) {
+		dev_err(&spi->dev, "Failed read reg (%08x)...\n",
+			WILC_INTR_ENABLE);
+		return ret;
+	}
+
+	for (i = 0; (i < 5) && (nint > 0); i++, nint--)
+		reg |= (BIT((27 + i)));
+
+	ret = wilc_spi_write_reg(wilc, WILC_INTR_ENABLE, reg);
+	if (ret) {
+		dev_err(&spi->dev, "Failed write reg (%08x)...\n",
+			WILC_INTR_ENABLE);
+		return ret;
+	}
+	if (nint) {
+		ret = wilc_spi_read_reg(wilc, WILC_INTR2_ENABLE, &reg);
+		if (ret) {
+			dev_err(&spi->dev, "Failed read reg (%08x)...\n",
+				WILC_INTR2_ENABLE);
+			return ret;
+		}
+
+		for (i = 0; (i < 3) && (nint > 0); i++, nint--)
+			reg |= BIT(i);
+
+		ret = wilc_spi_write_reg(wilc, WILC_INTR2_ENABLE, reg);
+		if (ret) {
+			dev_err(&spi->dev, "Failed write reg (%08x)...\n",
+				WILC_INTR2_ENABLE);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/* Global spi HIF function table */
+static const struct wilc_hif_func wilc_hif_spi = {
+	.hif_init = wilc_spi_init,
+	.hif_deinit = wilc_spi_deinit,
+	.hif_read_reg = wilc_spi_read_reg,
+	.hif_write_reg = wilc_spi_write_reg,
+	.hif_block_rx = wilc_spi_read,
+	.hif_block_tx = wilc_spi_write,
+	.hif_read_int = wilc_spi_read_int,
+	.hif_clear_int_ext = wilc_spi_clear_int_ext,
+	.hif_read_size = wilc_spi_read_size,
+	.hif_block_tx_ext = wilc_spi_write,
+	.hif_block_rx_ext = wilc_spi_read,
+	.hif_sync_ext = wilc_spi_sync_ext,
+	.hif_reset = wilc_spi_reset,
+	.hif_is_init = wilc_spi_is_init,
+};
diff --git a/drivers/staging/wilc1000/sysfs.c b/drivers/staging/wilc1000/sysfs.c
new file mode 100644
index 000000000..3f79ad2c9
--- /dev/null
+++ b/drivers/staging/wilc1000/sysfs.c
@@ -0,0 +1,108 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/kobject.h>
+#include "cfg80211.h"
+
+static struct kobject *wilc_kobj;
+static int device_created;
+static struct wilc *wl;
+
+static ssize_t wilc_sysfs_show(struct kobject *kobj,
+			       struct kobj_attribute *attr, char *buf)
+{
+	int attr_val = -1;
+
+	if (strcmp(attr->attr.name, "p2p_mode") == 0)
+		attr_val = wl->attr_sysfs.p2p_mode;
+	if (strcmp(attr->attr.name, "ant_swtch_mode") == 0)
+		attr_val = wl->attr_sysfs.ant_swtch_mode;
+	else if (strcmp(attr->attr.name, "antenna1") == 0)
+		attr_val = wl->attr_sysfs.antenna1;
+	else if (strcmp(attr->attr.name, "antenna2") == 0)
+		attr_val = wl->attr_sysfs.antenna2;
+
+	return sprintf(buf, "%d\n", attr_val);
+}
+
+static ssize_t wilc_sysfs_store(struct kobject *kobj,
+				struct kobj_attribute *attr, const char *buf,
+				size_t count)
+{
+	int attr_val;
+
+	if (kstrtoint(buf, 10, &attr_val))
+		pr_err("Failed to convert p2p_mode string");
+	if (strcmp(attr->attr.name, "p2p_mode") == 0) {
+		wl->attr_sysfs.p2p_mode = (attr_val?1:0);
+	} else if (strcmp(attr->attr.name, "ant_swtch_mode") == 0) {
+		if (attr_val > ANT_SWTCH_DUAL_GPIO_CTRL)
+			pr_err("Valid antenna switch modes:\n1-Single Antenna, 2-Dual Antenna\n");
+		else
+			wl->attr_sysfs.ant_swtch_mode = attr_val;
+	} else if (strcmp(attr->attr.name, "antenna1") == 0) {
+		wl->attr_sysfs.antenna1 = attr_val;
+	} else if (strcmp(attr->attr.name, "antenna2") == 0) {
+		wl->attr_sysfs.antenna2 = attr_val;
+	}
+
+	return count;
+}
+
+static struct kobj_attribute p2p_mode_attr =
+	__ATTR(p2p_mode, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_mode_attr =
+	__ATTR(ant_swtch_mode, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_antenna1_attr =
+	__ATTR(antenna1, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_antenna2_attr =
+	__ATTR(antenna2, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+
+static struct attribute *wilc_attrs[] = {
+	&p2p_mode_attr.attr,
+	&ant_swtch_mode_attr.attr,
+	&ant_swtch_antenna1_attr.attr,
+	&ant_swtch_antenna2_attr.attr,
+	NULL
+};
+
+static struct attribute_group attr_group = {
+	.attrs = wilc_attrs,
+};
+
+void wilc_sysfs_init(struct wilc *wilc)
+{
+	int retval;
+
+	if (device_created)
+		return;
+
+	wilc_kobj = kobject_create_and_add("wilc", NULL);
+	if (!wilc_kobj) {
+		retval = -ENOMEM;
+		return;
+	}
+
+	retval = sysfs_create_group(wilc_kobj, &attr_group);
+	device_created = 1;
+	wl = wilc;
+	/* By default p2p mode is Group Owner */
+	wl->attr_sysfs.p2p_mode = WILC_P2P_ROLE_GO;
+	wl->attr_sysfs.ant_swtch_mode = ANT_SWTCH_INVALID_GPIO_CTRL;
+	wl->attr_sysfs.antenna1 = 0xFF;
+	wl->attr_sysfs.antenna2 = 0xFF;
+}
+
+void wilc_sysfs_exit(void)
+{
+	device_created = 0;
+	sysfs_remove_group(wilc_kobj, &attr_group);
+	kobject_put(wilc_kobj);
+}
diff --git a/drivers/staging/wilc1000/wilc_netdev.c b/drivers/staging/wilc1000/wilc_netdev.c
deleted file mode 100644
index 508acb8bb..000000000
--- a/drivers/staging/wilc1000/wilc_netdev.c
+++ /dev/null
@@ -1,931 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
- * All rights reserved.
- */
-
-#include <linux/irq.h>
-#include <linux/kthread.h>
-#include <linux/firmware.h>
-#include <linux/netdevice.h>
-#include <linux/inetdevice.h>
-
-#include "wilc_wfi_cfgoperations.h"
-#include "wilc_wlan_cfg.h"
-
-#define WILC_MULTICAST_TABLE_SIZE	8
-
-static irqreturn_t isr_uh_routine(int irq, void *user_data)
-{
-	struct net_device *dev = user_data;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-
-	if (wilc->close) {
-		netdev_err(dev, "Can't handle UH interrupt\n");
-		return IRQ_HANDLED;
-	}
-	return IRQ_WAKE_THREAD;
-}
-
-static irqreturn_t isr_bh_routine(int irq, void *userdata)
-{
-	struct net_device *dev = userdata;
-	struct wilc_vif *vif = netdev_priv(userdata);
-	struct wilc *wilc = vif->wilc;
-
-	if (wilc->close) {
-		netdev_err(dev, "Can't handle BH interrupt\n");
-		return IRQ_HANDLED;
-	}
-
-	wilc_handle_isr(wilc);
-
-	return IRQ_HANDLED;
-}
-
-static int init_irq(struct net_device *dev)
-{
-	int ret = 0;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wl = vif->wilc;
-
-	ret = gpiod_direction_input(wl->gpio_irq);
-	if (ret) {
-		netdev_err(dev, "could not obtain gpio for WILC_INTR\n");
-		return ret;
-	}
-
-	wl->dev_irq_num = gpiod_to_irq(wl->gpio_irq);
-
-	ret = request_threaded_irq(wl->dev_irq_num, isr_uh_routine,
-				   isr_bh_routine,
-				   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
-				   "WILC_IRQ", dev);
-	if (ret < 0)
-		netdev_err(dev, "Failed to request IRQ\n");
-	else
-		netdev_dbg(dev, "IRQ request succeeded IRQ-NUM= %d\n",
-			   wl->dev_irq_num);
-
-	return ret;
-}
-
-static void deinit_irq(struct net_device *dev)
-{
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-
-	/* Deinitialize IRQ */
-	if (wilc->dev_irq_num)
-		free_irq(wilc->dev_irq_num, wilc);
-}
-
-void wilc_mac_indicate(struct wilc *wilc)
-{
-	s8 status;
-
-	wilc_wlan_cfg_get_val(wilc, WID_STATUS, &status, 1);
-	if (wilc->mac_status == WILC_MAC_STATUS_INIT) {
-		wilc->mac_status = status;
-		complete(&wilc->sync_event);
-	} else {
-		wilc->mac_status = status;
-	}
-}
-
-static struct net_device *get_if_handler(struct wilc *wilc, u8 *mac_header)
-{
-	u8 *bssid, *bssid1;
-	int i = 0;
-	struct net_device *ndev = NULL;
-
-	bssid = mac_header + 10;
-	bssid1 = mac_header + 4;
-
-	mutex_lock(&wilc->vif_mutex);
-	for (i = 0; i < wilc->vif_num; i++) {
-		if (wilc->vif[i]->mode == WILC_STATION_MODE)
-			if (ether_addr_equal_unaligned(bssid,
-						       wilc->vif[i]->bssid)) {
-				ndev = wilc->vif[i]->ndev;
-				goto out;
-			}
-		if (wilc->vif[i]->mode == WILC_AP_MODE)
-			if (ether_addr_equal_unaligned(bssid1,
-						       wilc->vif[i]->bssid)) {
-				ndev = wilc->vif[i]->ndev;
-				goto out;
-			}
-	}
-out:
-	mutex_unlock(&wilc->vif_mutex);
-	return ndev;
-}
-
-void wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode)
-{
-	struct wilc_vif *vif = netdev_priv(wilc_netdev);
-
-	if (bssid)
-		ether_addr_copy(vif->bssid, bssid);
-	else
-		eth_zero_addr(vif->bssid);
-
-	vif->mode = mode;
-}
-
-int wilc_wlan_get_num_conn_ifcs(struct wilc *wilc)
-{
-	u8 i = 0;
-	u8 ret_val = 0;
-
-	for (i = 0; i < wilc->vif_num; i++)
-		if (!is_zero_ether_addr(wilc->vif[i]->bssid))
-			ret_val++;
-
-	return ret_val;
-}
-
-static int wilc_txq_task(void *vp)
-{
-	int ret;
-	u32 txq_count;
-	struct wilc *wl = vp;
-
-	complete(&wl->txq_thread_started);
-	while (1) {
-		wait_for_completion(&wl->txq_event);
-
-		if (wl->close) {
-			complete(&wl->txq_thread_started);
-
-			while (!kthread_should_stop())
-				schedule();
-			break;
-		}
-		do {
-			ret = wilc_wlan_handle_txq(wl, &txq_count);
-			if (txq_count < FLOW_CONTROL_LOWER_THRESHOLD) {
-				int i;
-				struct wilc_vif *ifc;
-
-				mutex_lock(&wl->vif_mutex);
-				for (i = 0; i < wl->vif_num; i++) {
-					ifc = wl->vif[i];
-					if (ifc->mac_opened && ifc->ndev)
-						netif_wake_queue(ifc->ndev);
-				}
-				mutex_unlock(&wl->vif_mutex);
-			}
-		} while (ret == -ENOBUFS && !wl->close);
-	}
-	return 0;
-}
-
-static int wilc_wlan_get_firmware(struct net_device *dev)
-{
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-	int chip_id, ret = 0;
-	const struct firmware *wilc_firmware;
-	char *firmware;
-
-	chip_id = wilc_get_chipid(wilc, false);
-
-	if (chip_id < 0x1003a0)
-		firmware = FIRMWARE_1002;
-	else
-		firmware = FIRMWARE_1003;
-
-	netdev_info(dev, "loading firmware %s\n", firmware);
-
-	if (request_firmware(&wilc_firmware, firmware, wilc->dev) != 0) {
-		netdev_err(dev, "%s - firmware not available\n", firmware);
-		ret = -1;
-		goto fail;
-	}
-	wilc->firmware = wilc_firmware;
-
-fail:
-
-	return ret;
-}
-
-static int wilc_start_firmware(struct net_device *dev)
-{
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-	int ret = 0;
-
-	ret = wilc_wlan_start(wilc);
-	if (ret < 0)
-		return ret;
-
-	if (!wait_for_completion_timeout(&wilc->sync_event,
-					 msecs_to_jiffies(5000)))
-		return -ETIME;
-
-	return 0;
-}
-
-static int wilc1000_firmware_download(struct net_device *dev)
-{
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-	int ret = 0;
-
-	if (!wilc->firmware) {
-		netdev_err(dev, "Firmware buffer is NULL\n");
-		return -ENOBUFS;
-	}
-
-	ret = wilc_wlan_firmware_download(wilc, wilc->firmware->data,
-					  wilc->firmware->size);
-	if (ret < 0)
-		return ret;
-
-	release_firmware(wilc->firmware);
-	wilc->firmware = NULL;
-
-	netdev_dbg(dev, "Download Succeeded\n");
-
-	return 0;
-}
-
-static int wilc_init_fw_config(struct net_device *dev, struct wilc_vif *vif)
-{
-	struct wilc_priv *priv = &vif->priv;
-	struct host_if_drv *hif_drv;
-	u8 b;
-	u16 hw;
-	u32 w;
-
-	netdev_dbg(dev, "Start configuring Firmware\n");
-	hif_drv = (struct host_if_drv *)priv->hif_drv;
-	netdev_dbg(dev, "Host = %p\n", hif_drv);
-
-	w = vif->iftype;
-	cpu_to_le32s(&w);
-	if (!wilc_wlan_cfg_set(vif, 1, WID_SET_OPERATION_MODE, (u8 *)&w, 4,
-			       0, 0))
-		goto fail;
-
-	b = WILC_FW_BSS_TYPE_INFRA;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_BSS_TYPE, &b, 1, 0, 0))
-		goto fail;
-
-	b = WILC_FW_TX_RATE_AUTO;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_CURRENT_TX_RATE, &b, 1, 0, 0))
-		goto fail;
-
-	b = WILC_FW_OPER_MODE_G_MIXED_11B_2;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11G_OPERATING_MODE, &b, 1, 0, 0))
-		goto fail;
-
-	b = WILC_FW_PREAMBLE_SHORT;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_PREAMBLE, &b, 1, 0, 0))
-		goto fail;
-
-	b = WILC_FW_11N_PROT_AUTO;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_PROT_MECH, &b, 1, 0, 0))
-		goto fail;
-
-	b = WILC_FW_ACTIVE_SCAN;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_SCAN_TYPE, &b, 1, 0, 0))
-		goto fail;
-
-	b = WILC_FW_SITE_SURVEY_OFF;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_SITE_SURVEY, &b, 1, 0, 0))
-		goto fail;
-
-	hw = 0xffff;
-	cpu_to_le16s(&hw);
-	if (!wilc_wlan_cfg_set(vif, 0, WID_RTS_THRESHOLD, (u8 *)&hw, 2, 0, 0))
-		goto fail;
-
-	hw = 2346;
-	cpu_to_le16s(&hw);
-	if (!wilc_wlan_cfg_set(vif, 0, WID_FRAG_THRESHOLD, (u8 *)&hw, 2, 0, 0))
-		goto fail;
-
-	b = 0;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_BCAST_SSID, &b, 1, 0, 0))
-		goto fail;
-
-	b = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_QOS_ENABLE, &b, 1, 0, 0))
-		goto fail;
-
-	b = WILC_FW_NO_POWERSAVE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_POWER_MANAGEMENT, &b, 1, 0, 0))
-		goto fail;
-
-	b = WILC_FW_SEC_NO;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11I_MODE, &b, 1, 0, 0))
-		goto fail;
-
-	b = WILC_FW_AUTH_OPEN_SYSTEM;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_AUTH_TYPE, &b, 1, 0, 0))
-		goto fail;
-
-	b = 3;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_LISTEN_INTERVAL, &b, 1, 0, 0))
-		goto fail;
-
-	b = 3;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_DTIM_PERIOD, &b, 1, 0, 0))
-		goto fail;
-
-	b = WILC_FW_ACK_POLICY_NORMAL;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_ACK_POLICY, &b, 1, 0, 0))
-		goto fail;
-
-	b = 0;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_USER_CONTROL_ON_TX_POWER, &b, 1,
-			       0, 0))
-		goto fail;
-
-	b = 48;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_TX_POWER_LEVEL_11A, &b, 1, 0, 0))
-		goto fail;
-
-	b = 28;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_TX_POWER_LEVEL_11B, &b, 1, 0, 0))
-		goto fail;
-
-	hw = 100;
-	cpu_to_le16s(&hw);
-	if (!wilc_wlan_cfg_set(vif, 0, WID_BEACON_INTERVAL, (u8 *)&hw, 2, 0, 0))
-		goto fail;
-
-	b = WILC_FW_REKEY_POLICY_DISABLE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_POLICY, &b, 1, 0, 0))
-		goto fail;
-
-	w = 84600;
-	cpu_to_le32s(&w);
-	if (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_PERIOD, (u8 *)&w, 4, 0, 0))
-		goto fail;
-
-	w = 500;
-	cpu_to_le32s(&w);
-	if (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_PACKET_COUNT, (u8 *)&w, 4, 0,
-			       0))
-		goto fail;
-
-	b = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_SHORT_SLOT_ALLOWED, &b, 1, 0,
-			       0))
-		goto fail;
-
-	b = WILC_FW_ERP_PROT_SELF_CTS;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_ERP_PROT_TYPE, &b, 1, 0, 0))
-		goto fail;
-
-	b = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_ENABLE, &b, 1, 0, 0))
-		goto fail;
-
-	b = WILC_FW_11N_OP_MODE_HT_MIXED;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_OPERATING_MODE, &b, 1, 0, 0))
-		goto fail;
-
-	b = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_TXOP_PROT_DISABLE, &b, 1, 0, 0))
-		goto fail;
-
-	b = WILC_FW_OBBS_NONHT_DETECT_PROTECT_REPORT;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_OBSS_NONHT_DETECTION, &b, 1,
-			       0, 0))
-		goto fail;
-
-	b = WILC_FW_HT_PROT_RTS_CTS_NONHT;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_HT_PROT_TYPE, &b, 1, 0, 0))
-		goto fail;
-
-	b = 0;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_RIFS_PROT_ENABLE, &b, 1, 0,
-			       0))
-		goto fail;
-
-	b = 7;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_CURRENT_TX_MCS, &b, 1, 0, 0))
-		goto fail;
-
-	b = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_IMMEDIATE_BA_ENABLED, &b, 1,
-			       1, 1))
-		goto fail;
-
-	return 0;
-
-fail:
-	return -1;
-}
-
-static void wlan_deinit_locks(struct net_device *dev)
-{
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-
-	mutex_destroy(&wilc->hif_cs);
-	mutex_destroy(&wilc->rxq_cs);
-	mutex_destroy(&wilc->cfg_cmd_lock);
-	mutex_destroy(&wilc->txq_add_to_head_cs);
-	mutex_destroy(&wilc->vif_mutex);
-}
-
-static void wlan_deinitialize_threads(struct net_device *dev)
-{
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wl = vif->wilc;
-
-	wl->close = 1;
-
-	complete(&wl->txq_event);
-
-	if (wl->txq_thread) {
-		kthread_stop(wl->txq_thread);
-		wl->txq_thread = NULL;
-	}
-}
-
-static void wilc_wlan_deinitialize(struct net_device *dev)
-{
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wl = vif->wilc;
-
-	if (!wl) {
-		netdev_err(dev, "wl is NULL\n");
-		return;
-	}
-
-	if (wl->initialized) {
-		netdev_info(dev, "Deinitializing wilc1000...\n");
-
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->disable_interrupt) {
-			mutex_lock(&wl->hif_cs);
-			wl->hif_func->disable_interrupt(wl);
-			mutex_unlock(&wl->hif_cs);
-		}
-		complete(&wl->txq_event);
-
-		wlan_deinitialize_threads(dev);
-		deinit_irq(dev);
-
-		wilc_wlan_stop(wl, vif);
-		wilc_wlan_cleanup(dev);
-		wlan_deinit_locks(dev);
-
-		wl->initialized = false;
-
-		netdev_dbg(dev, "wilc1000 deinitialization Done\n");
-	} else {
-		netdev_dbg(dev, "wilc1000 is not initialized\n");
-	}
-}
-
-static int wlan_initialize_threads(struct net_device *dev)
-{
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-
-	wilc->txq_thread = kthread_run(wilc_txq_task, (void *)wilc,
-				       "K_TXQ_TASK");
-	if (IS_ERR(wilc->txq_thread)) {
-		netdev_err(dev, "couldn't create TXQ thread\n");
-		wilc->close = 0;
-		return PTR_ERR(wilc->txq_thread);
-	}
-	wait_for_completion(&wilc->txq_thread_started);
-
-	return 0;
-}
-
-static int wilc_wlan_initialize(struct net_device *dev, struct wilc_vif *vif)
-{
-	int ret = 0;
-	struct wilc *wl = vif->wilc;
-
-	if (!wl->initialized) {
-		wl->mac_status = WILC_MAC_STATUS_INIT;
-		wl->close = 0;
-
-		ret = wilc_wlan_init(dev);
-		if (ret < 0)
-			return -EIO;
-
-		ret = wlan_initialize_threads(dev);
-		if (ret < 0) {
-			ret = -EIO;
-			goto fail_wilc_wlan;
-		}
-
-		if (wl->gpio_irq && init_irq(dev)) {
-			ret = -EIO;
-			goto fail_threads;
-		}
-
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->enable_interrupt &&
-		    wl->hif_func->enable_interrupt(wl)) {
-			ret = -EIO;
-			goto fail_irq_init;
-		}
-
-		if (wilc_wlan_get_firmware(dev)) {
-			ret = -EIO;
-			goto fail_irq_enable;
-		}
-
-		ret = wilc1000_firmware_download(dev);
-		if (ret < 0) {
-			ret = -EIO;
-			goto fail_irq_enable;
-		}
-
-		ret = wilc_start_firmware(dev);
-		if (ret < 0) {
-			ret = -EIO;
-			goto fail_irq_enable;
-		}
-
-		if (wilc_wlan_cfg_get(vif, 1, WID_FIRMWARE_VERSION, 1, 0)) {
-			int size;
-			char firmware_ver[20];
-
-			size = wilc_wlan_cfg_get_val(wl, WID_FIRMWARE_VERSION,
-						     firmware_ver,
-						     sizeof(firmware_ver));
-			firmware_ver[size] = '\0';
-			netdev_dbg(dev, "Firmware Ver = %s\n", firmware_ver);
-		}
-		ret = wilc_init_fw_config(dev, vif);
-
-		if (ret < 0) {
-			netdev_err(dev, "Failed to configure firmware\n");
-			ret = -EIO;
-			goto fail_fw_start;
-		}
-		wl->initialized = true;
-		return 0;
-
-fail_fw_start:
-		wilc_wlan_stop(wl, vif);
-
-fail_irq_enable:
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->disable_interrupt)
-			wl->hif_func->disable_interrupt(wl);
-fail_irq_init:
-		if (wl->dev_irq_num)
-			deinit_irq(dev);
-fail_threads:
-		wlan_deinitialize_threads(dev);
-fail_wilc_wlan:
-		wilc_wlan_cleanup(dev);
-		netdev_err(dev, "WLAN initialization FAILED\n");
-	} else {
-		netdev_dbg(dev, "wilc1000 already initialized\n");
-	}
-	return ret;
-}
-
-static int mac_init_fn(struct net_device *ndev)
-{
-	netif_start_queue(ndev);
-	netif_stop_queue(ndev);
-
-	return 0;
-}
-
-static int wilc_mac_open(struct net_device *ndev)
-{
-	struct wilc_vif *vif = netdev_priv(ndev);
-	struct wilc *wl = vif->wilc;
-	struct wilc_priv *priv = wdev_priv(vif->ndev->ieee80211_ptr);
-	unsigned char mac_add[ETH_ALEN] = {0};
-	int ret = 0;
-
-	if (!wl || !wl->dev) {
-		netdev_err(ndev, "device not ready\n");
-		return -ENODEV;
-	}
-
-	netdev_dbg(ndev, "MAC OPEN[%p]\n", ndev);
-
-	ret = wilc_init_host_int(ndev);
-	if (ret < 0)
-		return ret;
-
-	ret = wilc_wlan_initialize(ndev, vif);
-	if (ret < 0) {
-		wilc_deinit_host_int(ndev);
-		return ret;
-	}
-
-	wilc_set_operation_mode(vif, wilc_get_vif_idx(vif), vif->iftype,
-				vif->idx);
-	wilc_get_mac_address(vif, mac_add);
-	netdev_dbg(ndev, "Mac address: %pM\n", mac_add);
-	ether_addr_copy(ndev->dev_addr, mac_add);
-
-	if (!is_valid_ether_addr(ndev->dev_addr)) {
-		netdev_err(ndev, "Wrong MAC address\n");
-		wilc_deinit_host_int(ndev);
-		wilc_wlan_deinitialize(ndev);
-		return -EINVAL;
-	}
-
-	wilc_mgmt_frame_register(vif->ndev->ieee80211_ptr->wiphy,
-				 vif->ndev->ieee80211_ptr,
-				 vif->frame_reg[0].type,
-				 vif->frame_reg[0].reg);
-	wilc_mgmt_frame_register(vif->ndev->ieee80211_ptr->wiphy,
-				 vif->ndev->ieee80211_ptr,
-				 vif->frame_reg[1].type,
-				 vif->frame_reg[1].reg);
-	netif_wake_queue(ndev);
-	wl->open_ifcs++;
-	priv->p2p.local_random = 0x01;
-	vif->mac_opened = 1;
-	return 0;
-}
-
-static struct net_device_stats *mac_stats(struct net_device *dev)
-{
-	struct wilc_vif *vif = netdev_priv(dev);
-
-	return &vif->netstats;
-}
-
-static void wilc_set_multicast_list(struct net_device *dev)
-{
-	struct netdev_hw_addr *ha;
-	struct wilc_vif *vif = netdev_priv(dev);
-	int i;
-	u8 *mc_list;
-	u8 *cur_mc;
-
-	if (dev->flags & IFF_PROMISC)
-		return;
-
-	if (dev->flags & IFF_ALLMULTI ||
-	    dev->mc.count > WILC_MULTICAST_TABLE_SIZE) {
-		wilc_setup_multicast_filter(vif, 0, 0, NULL);
-		return;
-	}
-
-	if (dev->mc.count == 0) {
-		wilc_setup_multicast_filter(vif, 1, 0, NULL);
-		return;
-	}
-
-	mc_list = kmalloc_array(dev->mc.count, ETH_ALEN, GFP_ATOMIC);
-	if (!mc_list)
-		return;
-
-	cur_mc = mc_list;
-	i = 0;
-	netdev_for_each_mc_addr(ha, dev) {
-		memcpy(cur_mc, ha->addr, ETH_ALEN);
-		netdev_dbg(dev, "Entry[%d]: %pM\n", i, cur_mc);
-		i++;
-		cur_mc += ETH_ALEN;
-	}
-
-	if (wilc_setup_multicast_filter(vif, 1, dev->mc.count, mc_list))
-		kfree(mc_list);
-}
-
-static void wilc_tx_complete(void *priv, int status)
-{
-	struct tx_complete_data *pv_data = priv;
-
-	dev_kfree_skb(pv_data->skb);
-	kfree(pv_data);
-}
-
-netdev_tx_t wilc_mac_xmit(struct sk_buff *skb, struct net_device *ndev)
-{
-	struct wilc_vif *vif = netdev_priv(ndev);
-	struct wilc *wilc = vif->wilc;
-	struct tx_complete_data *tx_data = NULL;
-	int queue_count;
-
-	if (skb->dev != ndev) {
-		netdev_err(ndev, "Packet not destined to this device\n");
-		return 0;
-	}
-
-	tx_data = kmalloc(sizeof(*tx_data), GFP_ATOMIC);
-	if (!tx_data) {
-		dev_kfree_skb(skb);
-		netif_wake_queue(ndev);
-		return 0;
-	}
-
-	tx_data->buff = skb->data;
-	tx_data->size = skb->len;
-	tx_data->skb  = skb;
-
-	vif->netstats.tx_packets++;
-	vif->netstats.tx_bytes += tx_data->size;
-	queue_count = wilc_wlan_txq_add_net_pkt(ndev, (void *)tx_data,
-						tx_data->buff, tx_data->size,
-						wilc_tx_complete);
-
-	if (queue_count > FLOW_CONTROL_UPPER_THRESHOLD) {
-		int i;
-
-		mutex_lock(&wilc->vif_mutex);
-		for (i = 0; i < wilc->vif_num; i++) {
-			if (wilc->vif[i]->mac_opened)
-				netif_stop_queue(wilc->vif[i]->ndev);
-		}
-		mutex_unlock(&wilc->vif_mutex);
-	}
-
-	return 0;
-}
-
-static int wilc_mac_close(struct net_device *ndev)
-{
-	struct wilc_vif *vif = netdev_priv(ndev);
-	struct wilc *wl = vif->wilc;
-
-	netdev_dbg(ndev, "Mac close\n");
-
-	if (wl->open_ifcs > 0)
-		wl->open_ifcs--;
-	else
-		return 0;
-
-	if (vif->ndev) {
-		netif_stop_queue(vif->ndev);
-
-		wilc_deinit_host_int(vif->ndev);
-	}
-
-	if (wl->open_ifcs == 0) {
-		netdev_dbg(ndev, "Deinitializing wilc1000\n");
-		wl->close = 1;
-		wilc_wlan_deinitialize(ndev);
-	}
-
-	vif->mac_opened = 0;
-
-	return 0;
-}
-
-void wilc_frmw_to_host(struct wilc *wilc, u8 *buff, u32 size,
-		       u32 pkt_offset)
-{
-	unsigned int frame_len = 0;
-	int stats;
-	unsigned char *buff_to_send = NULL;
-	struct sk_buff *skb;
-	struct net_device *wilc_netdev;
-	struct wilc_vif *vif;
-
-	if (!wilc)
-		return;
-
-	wilc_netdev = get_if_handler(wilc, buff);
-	if (!wilc_netdev)
-		return;
-
-	buff += pkt_offset;
-	vif = netdev_priv(wilc_netdev);
-
-	if (size > 0) {
-		frame_len = size;
-		buff_to_send = buff;
-
-		skb = dev_alloc_skb(frame_len);
-		if (!skb)
-			return;
-
-		skb->dev = wilc_netdev;
-
-		skb_put_data(skb, buff_to_send, frame_len);
-
-		skb->protocol = eth_type_trans(skb, wilc_netdev);
-		vif->netstats.rx_packets++;
-		vif->netstats.rx_bytes += frame_len;
-		skb->ip_summed = CHECKSUM_UNNECESSARY;
-		stats = netif_rx(skb);
-		netdev_dbg(wilc_netdev, "netif_rx ret value is: %d\n", stats);
-	}
-}
-
-void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size)
-{
-	int i = 0;
-	struct wilc_vif *vif;
-
-	mutex_lock(&wilc->vif_mutex);
-	for (i = 0; i < wilc->vif_num; i++) {
-		u16 type = le16_to_cpup((__le16 *)buff);
-
-		vif = netdev_priv(wilc->vif[i]->ndev);
-		if ((type == vif->frame_reg[0].type && vif->frame_reg[0].reg) ||
-		    (type == vif->frame_reg[1].type && vif->frame_reg[1].reg)) {
-			wilc_wfi_p2p_rx(vif, buff, size);
-			break;
-		}
-
-		if (vif->monitor_flag) {
-			wilc_wfi_monitor_rx(wilc->monitor_dev, buff, size);
-			break;
-		}
-	}
-	mutex_unlock(&wilc->vif_mutex);
-}
-
-static const struct net_device_ops wilc_netdev_ops = {
-	.ndo_init = mac_init_fn,
-	.ndo_open = wilc_mac_open,
-	.ndo_stop = wilc_mac_close,
-	.ndo_start_xmit = wilc_mac_xmit,
-	.ndo_get_stats = mac_stats,
-	.ndo_set_rx_mode  = wilc_set_multicast_list,
-};
-
-void wilc_netdev_cleanup(struct wilc *wilc)
-{
-	int i;
-
-	if (!wilc)
-		return;
-
-	if (wilc->firmware) {
-		release_firmware(wilc->firmware);
-		wilc->firmware = NULL;
-	}
-
-	for (i = 0; i < wilc->vif_num; i++) {
-		if (wilc->vif[i] && wilc->vif[i]->ndev)
-			unregister_netdev(wilc->vif[i]->ndev);
-	}
-
-	wilc_wfi_deinit_mon_interface(wilc, false);
-	flush_workqueue(wilc->hif_workqueue);
-	destroy_workqueue(wilc->hif_workqueue);
-	wilc_wlan_cfg_deinit(wilc);
-	kfree(wilc->bus_data);
-	wiphy_unregister(wilc->wiphy);
-	wiphy_free(wilc->wiphy);
-}
-EXPORT_SYMBOL_GPL(wilc_netdev_cleanup);
-
-struct wilc_vif *wilc_netdev_ifc_init(struct wilc *wl, const char *name,
-				      int vif_type, enum nl80211_iftype type,
-				      bool rtnl_locked)
-{
-	struct net_device *ndev;
-	struct wilc_vif *vif;
-	int ret;
-
-	ndev = alloc_etherdev(sizeof(*vif));
-	if (!ndev)
-		return ERR_PTR(-ENOMEM);
-
-	vif = netdev_priv(ndev);
-	ndev->ieee80211_ptr = &vif->priv.wdev;
-	strcpy(ndev->name, name);
-	vif->wilc = wl;
-	vif->ndev = ndev;
-	ndev->ml_priv = vif;
-
-	ndev->netdev_ops = &wilc_netdev_ops;
-
-	SET_NETDEV_DEV(ndev, wiphy_dev(wl->wiphy));
-
-	vif->priv.wdev.wiphy = wl->wiphy;
-	vif->priv.wdev.netdev = ndev;
-	vif->priv.wdev.iftype = type;
-	vif->priv.dev = ndev;
-
-	if (rtnl_locked)
-		ret = register_netdevice(ndev);
-	else
-		ret = register_netdev(ndev);
-
-	if (ret) {
-		free_netdev(ndev);
-		return ERR_PTR(-EFAULT);
-	}
-
-	ndev->needs_free_netdev = true;
-	vif->iftype = vif_type;
-	vif->wilc->vif[wl->vif_num] = vif;
-	vif->idx = wl->vif_num;
-	wl->vif_num += 1;
-	vif->mac_opened = 0;
-	return vif;
-}
-
-MODULE_LICENSE("GPL");
diff --git a/drivers/staging/wilc1000/wilc_spi.c b/drivers/staging/wilc1000/wilc_spi.c
deleted file mode 100644
index 3c1ae9e9f..000000000
--- a/drivers/staging/wilc1000/wilc_spi.c
+++ /dev/null
@@ -1,1134 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
- * All rights reserved.
- */
-
-#include <linux/spi/spi.h>
-
-#include "wilc_wfi_netdevice.h"
-#include "wilc_wfi_cfgoperations.h"
-
-struct wilc_spi {
-	int crc_off;
-	int nint;
-	int has_thrpt_enh;
-};
-
-static const struct wilc_hif_func wilc_hif_spi;
-
-/********************************************
- *
- *      Crc7
- *
- ********************************************/
-
-static const u8 crc7_syndrome_table[256] = {
-	0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f,
-	0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
-	0x19, 0x10, 0x0b, 0x02, 0x3d, 0x34, 0x2f, 0x26,
-	0x51, 0x58, 0x43, 0x4a, 0x75, 0x7c, 0x67, 0x6e,
-	0x32, 0x3b, 0x20, 0x29, 0x16, 0x1f, 0x04, 0x0d,
-	0x7a, 0x73, 0x68, 0x61, 0x5e, 0x57, 0x4c, 0x45,
-	0x2b, 0x22, 0x39, 0x30, 0x0f, 0x06, 0x1d, 0x14,
-	0x63, 0x6a, 0x71, 0x78, 0x47, 0x4e, 0x55, 0x5c,
-	0x64, 0x6d, 0x76, 0x7f, 0x40, 0x49, 0x52, 0x5b,
-	0x2c, 0x25, 0x3e, 0x37, 0x08, 0x01, 0x1a, 0x13,
-	0x7d, 0x74, 0x6f, 0x66, 0x59, 0x50, 0x4b, 0x42,
-	0x35, 0x3c, 0x27, 0x2e, 0x11, 0x18, 0x03, 0x0a,
-	0x56, 0x5f, 0x44, 0x4d, 0x72, 0x7b, 0x60, 0x69,
-	0x1e, 0x17, 0x0c, 0x05, 0x3a, 0x33, 0x28, 0x21,
-	0x4f, 0x46, 0x5d, 0x54, 0x6b, 0x62, 0x79, 0x70,
-	0x07, 0x0e, 0x15, 0x1c, 0x23, 0x2a, 0x31, 0x38,
-	0x41, 0x48, 0x53, 0x5a, 0x65, 0x6c, 0x77, 0x7e,
-	0x09, 0x00, 0x1b, 0x12, 0x2d, 0x24, 0x3f, 0x36,
-	0x58, 0x51, 0x4a, 0x43, 0x7c, 0x75, 0x6e, 0x67,
-	0x10, 0x19, 0x02, 0x0b, 0x34, 0x3d, 0x26, 0x2f,
-	0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
-	0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04,
-	0x6a, 0x63, 0x78, 0x71, 0x4e, 0x47, 0x5c, 0x55,
-	0x22, 0x2b, 0x30, 0x39, 0x06, 0x0f, 0x14, 0x1d,
-	0x25, 0x2c, 0x37, 0x3e, 0x01, 0x08, 0x13, 0x1a,
-	0x6d, 0x64, 0x7f, 0x76, 0x49, 0x40, 0x5b, 0x52,
-	0x3c, 0x35, 0x2e, 0x27, 0x18, 0x11, 0x0a, 0x03,
-	0x74, 0x7d, 0x66, 0x6f, 0x50, 0x59, 0x42, 0x4b,
-	0x17, 0x1e, 0x05, 0x0c, 0x33, 0x3a, 0x21, 0x28,
-	0x5f, 0x56, 0x4d, 0x44, 0x7b, 0x72, 0x69, 0x60,
-	0x0e, 0x07, 0x1c, 0x15, 0x2a, 0x23, 0x38, 0x31,
-	0x46, 0x4f, 0x54, 0x5d, 0x62, 0x6b, 0x70, 0x79
-};
-
-static u8 crc7_byte(u8 crc, u8 data)
-{
-	return crc7_syndrome_table[(crc << 1) ^ data];
-}
-
-static u8 crc7(u8 crc, const u8 *buffer, u32 len)
-{
-	while (len--)
-		crc = crc7_byte(crc, *buffer++);
-	return crc;
-}
-
-/********************************************
- *
- *      Spi protocol Function
- *
- ********************************************/
-
-#define CMD_DMA_WRITE				0xc1
-#define CMD_DMA_READ				0xc2
-#define CMD_INTERNAL_WRITE			0xc3
-#define CMD_INTERNAL_READ			0xc4
-#define CMD_TERMINATE				0xc5
-#define CMD_REPEAT				0xc6
-#define CMD_DMA_EXT_WRITE			0xc7
-#define CMD_DMA_EXT_READ			0xc8
-#define CMD_SINGLE_WRITE			0xc9
-#define CMD_SINGLE_READ				0xca
-#define CMD_RESET				0xcf
-
-#define N_OK					1
-#define N_FAIL					0
-#define N_RESET					-1
-#define N_RETRY					-2
-
-#define DATA_PKT_SZ_256				256
-#define DATA_PKT_SZ_512				512
-#define DATA_PKT_SZ_1K				1024
-#define DATA_PKT_SZ_4K				(4 * 1024)
-#define DATA_PKT_SZ_8K				(8 * 1024)
-#define DATA_PKT_SZ				DATA_PKT_SZ_8K
-
-#define USE_SPI_DMA				0
-
-static int wilc_bus_probe(struct spi_device *spi)
-{
-	int ret;
-	struct wilc *wilc;
-	struct gpio_desc *gpio;
-	struct wilc_spi *spi_priv;
-
-	spi_priv = kzalloc(sizeof(*spi_priv), GFP_KERNEL);
-	if (!spi_priv)
-		return -ENOMEM;
-
-	gpio = gpiod_get(&spi->dev, "irq", GPIOD_IN);
-	if (IS_ERR(gpio)) {
-		/* get the GPIO descriptor from hardcode GPIO number */
-		gpio = gpio_to_desc(GPIO_NUM);
-		if (!gpio)
-			dev_err(&spi->dev, "failed to get the irq gpio\n");
-	}
-
-	ret = wilc_cfg80211_init(&wilc, &spi->dev, WILC_HIF_SPI, &wilc_hif_spi);
-	if (ret) {
-		kfree(spi_priv);
-		return ret;
-	}
-
-	spi_set_drvdata(spi, wilc);
-	wilc->dev = &spi->dev;
-	wilc->bus_data = spi_priv;
-	wilc->gpio_irq = gpio;
-
-	return 0;
-}
-
-static int wilc_bus_remove(struct spi_device *spi)
-{
-	struct wilc *wilc = spi_get_drvdata(spi);
-
-	/* free the GPIO in module remove */
-	if (wilc->gpio_irq)
-		gpiod_put(wilc->gpio_irq);
-	wilc_netdev_cleanup(wilc);
-	return 0;
-}
-
-static const struct of_device_id wilc_of_match[] = {
-	{ .compatible = "microchip,wilc1000-spi", },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, wilc_of_match);
-
-static struct spi_driver wilc_spi_driver = {
-	.driver = {
-		.name = MODALIAS,
-		.of_match_table = wilc_of_match,
-	},
-	.probe =  wilc_bus_probe,
-	.remove = wilc_bus_remove,
-};
-module_spi_driver(wilc_spi_driver);
-MODULE_LICENSE("GPL");
-
-static int wilc_spi_tx(struct wilc *wilc, u8 *b, u32 len)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	int ret;
-	struct spi_message msg;
-
-	if (len > 0 && b) {
-		struct spi_transfer tr = {
-			.tx_buf = b,
-			.len = len,
-			.delay_usecs = 0,
-		};
-		char *r_buffer = kzalloc(len, GFP_KERNEL);
-
-		if (!r_buffer)
-			return -ENOMEM;
-
-		tr.rx_buf = r_buffer;
-		dev_dbg(&spi->dev, "Request writing %d bytes\n", len);
-
-		memset(&msg, 0, sizeof(msg));
-		spi_message_init(&msg);
-		msg.spi = spi;
-		msg.is_dma_mapped = USE_SPI_DMA;
-		spi_message_add_tail(&tr, &msg);
-
-		ret = spi_sync(spi, &msg);
-		if (ret < 0)
-			dev_err(&spi->dev, "SPI transaction failed\n");
-
-		kfree(r_buffer);
-	} else {
-		dev_err(&spi->dev,
-			"can't write data with the following length: %d\n",
-			len);
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-static int wilc_spi_rx(struct wilc *wilc, u8 *rb, u32 rlen)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	int ret;
-
-	if (rlen > 0) {
-		struct spi_message msg;
-		struct spi_transfer tr = {
-			.rx_buf = rb,
-			.len = rlen,
-			.delay_usecs = 0,
-
-		};
-		char *t_buffer = kzalloc(rlen, GFP_KERNEL);
-
-		if (!t_buffer)
-			return -ENOMEM;
-
-		tr.tx_buf = t_buffer;
-
-		memset(&msg, 0, sizeof(msg));
-		spi_message_init(&msg);
-		msg.spi = spi;
-		msg.is_dma_mapped = USE_SPI_DMA;
-		spi_message_add_tail(&tr, &msg);
-
-		ret = spi_sync(spi, &msg);
-		if (ret < 0)
-			dev_err(&spi->dev, "SPI transaction failed\n");
-		kfree(t_buffer);
-	} else {
-		dev_err(&spi->dev,
-			"can't read data with the following length: %u\n",
-			rlen);
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-static int wilc_spi_tx_rx(struct wilc *wilc, u8 *wb, u8 *rb, u32 rlen)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	int ret;
-
-	if (rlen > 0) {
-		struct spi_message msg;
-		struct spi_transfer tr = {
-			.rx_buf = rb,
-			.tx_buf = wb,
-			.len = rlen,
-			.bits_per_word = 8,
-			.delay_usecs = 0,
-
-		};
-
-		memset(&msg, 0, sizeof(msg));
-		spi_message_init(&msg);
-		msg.spi = spi;
-		msg.is_dma_mapped = USE_SPI_DMA;
-
-		spi_message_add_tail(&tr, &msg);
-		ret = spi_sync(spi, &msg);
-		if (ret < 0)
-			dev_err(&spi->dev, "SPI transaction failed\n");
-	} else {
-		dev_err(&spi->dev,
-			"can't read data with the following length: %u\n",
-			rlen);
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
-			    u8 clockless)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	struct wilc_spi *spi_priv = wilc->bus_data;
-	u8 wb[32], rb[32];
-	u8 wix, rix;
-	u32 len2;
-	u8 rsp;
-	int len = 0;
-	int result = N_OK;
-	int retry;
-	u8 crc[2];
-
-	wb[0] = cmd;
-	switch (cmd) {
-	case CMD_SINGLE_READ: /* single word (4 bytes) read */
-		wb[1] = (u8)(adr >> 16);
-		wb[2] = (u8)(adr >> 8);
-		wb[3] = (u8)adr;
-		len = 5;
-		break;
-
-	case CMD_INTERNAL_READ: /* internal register read */
-		wb[1] = (u8)(adr >> 8);
-		if (clockless == 1)
-			wb[1] |= BIT(7);
-		wb[2] = (u8)adr;
-		wb[3] = 0x00;
-		len = 5;
-		break;
-
-	case CMD_TERMINATE:
-		wb[1] = 0x00;
-		wb[2] = 0x00;
-		wb[3] = 0x00;
-		len = 5;
-		break;
-
-	case CMD_REPEAT:
-		wb[1] = 0x00;
-		wb[2] = 0x00;
-		wb[3] = 0x00;
-		len = 5;
-		break;
-
-	case CMD_RESET:
-		wb[1] = 0xff;
-		wb[2] = 0xff;
-		wb[3] = 0xff;
-		len = 5;
-		break;
-
-	case CMD_DMA_WRITE: /* dma write */
-	case CMD_DMA_READ:  /* dma read */
-		wb[1] = (u8)(adr >> 16);
-		wb[2] = (u8)(adr >> 8);
-		wb[3] = (u8)adr;
-		wb[4] = (u8)(sz >> 8);
-		wb[5] = (u8)(sz);
-		len = 7;
-		break;
-
-	case CMD_DMA_EXT_WRITE: /* dma extended write */
-	case CMD_DMA_EXT_READ:  /* dma extended read */
-		wb[1] = (u8)(adr >> 16);
-		wb[2] = (u8)(adr >> 8);
-		wb[3] = (u8)adr;
-		wb[4] = (u8)(sz >> 16);
-		wb[5] = (u8)(sz >> 8);
-		wb[6] = (u8)(sz);
-		len = 8;
-		break;
-
-	case CMD_INTERNAL_WRITE: /* internal register write */
-		wb[1] = (u8)(adr >> 8);
-		if (clockless == 1)
-			wb[1] |= BIT(7);
-		wb[2] = (u8)(adr);
-		wb[3] = b[3];
-		wb[4] = b[2];
-		wb[5] = b[1];
-		wb[6] = b[0];
-		len = 8;
-		break;
-
-	case CMD_SINGLE_WRITE: /* single word write */
-		wb[1] = (u8)(adr >> 16);
-		wb[2] = (u8)(adr >> 8);
-		wb[3] = (u8)(adr);
-		wb[4] = b[3];
-		wb[5] = b[2];
-		wb[6] = b[1];
-		wb[7] = b[0];
-		len = 9;
-		break;
-
-	default:
-		result = N_FAIL;
-		break;
-	}
-
-	if (result != N_OK)
-		return result;
-
-	if (!spi_priv->crc_off)
-		wb[len - 1] = (crc7(0x7f, (const u8 *)&wb[0], len - 1)) << 1;
-	else
-		len -= 1;
-
-#define NUM_SKIP_BYTES (1)
-#define NUM_RSP_BYTES (2)
-#define NUM_DATA_HDR_BYTES (1)
-#define NUM_DATA_BYTES (4)
-#define NUM_CRC_BYTES (2)
-#define NUM_DUMMY_BYTES (3)
-	if (cmd == CMD_RESET ||
-	    cmd == CMD_TERMINATE ||
-	    cmd == CMD_REPEAT) {
-		len2 = len + (NUM_SKIP_BYTES + NUM_RSP_BYTES + NUM_DUMMY_BYTES);
-	} else if (cmd == CMD_INTERNAL_READ || cmd == CMD_SINGLE_READ) {
-		int tmp = NUM_RSP_BYTES + NUM_DATA_HDR_BYTES + NUM_DATA_BYTES
-			+ NUM_DUMMY_BYTES;
-		if (!spi_priv->crc_off)
-			len2 = len + tmp + NUM_CRC_BYTES;
-		else
-			len2 = len + tmp;
-	} else {
-		len2 = len + (NUM_RSP_BYTES + NUM_DUMMY_BYTES);
-	}
-#undef NUM_DUMMY_BYTES
-
-	if (len2 > ARRAY_SIZE(wb)) {
-		dev_err(&spi->dev, "spi buffer size too small (%d) (%zu)\n",
-			len2, ARRAY_SIZE(wb));
-		return N_FAIL;
-	}
-	/* zero spi write buffers. */
-	for (wix = len; wix < len2; wix++)
-		wb[wix] = 0;
-	rix = len;
-
-	if (wilc_spi_tx_rx(wilc, wb, rb, len2)) {
-		dev_err(&spi->dev, "Failed cmd write, bus error...\n");
-		return N_FAIL;
-	}
-
-	/*
-	 * Command/Control response
-	 */
-	if (cmd == CMD_RESET || cmd == CMD_TERMINATE || cmd == CMD_REPEAT)
-		rix++; /* skip 1 byte */
-
-	rsp = rb[rix++];
-
-	if (rsp != cmd) {
-		dev_err(&spi->dev,
-			"Failed cmd response, cmd (%02x), resp (%02x)\n",
-			cmd, rsp);
-		return N_FAIL;
-	}
-
-	/*
-	 * State response
-	 */
-	rsp = rb[rix++];
-	if (rsp != 0x00) {
-		dev_err(&spi->dev, "Failed cmd state response state (%02x)\n",
-			rsp);
-		return N_FAIL;
-	}
-
-	if (cmd == CMD_INTERNAL_READ || cmd == CMD_SINGLE_READ ||
-	    cmd == CMD_DMA_READ || cmd == CMD_DMA_EXT_READ) {
-		/*
-		 * Data Respnose header
-		 */
-		retry = 100;
-		do {
-			/*
-			 * ensure there is room in buffer later
-			 * to read data and crc
-			 */
-			if (rix < len2) {
-				rsp = rb[rix++];
-			} else {
-				retry = 0;
-				break;
-			}
-			if (((rsp >> 4) & 0xf) == 0xf)
-				break;
-		} while (retry--);
-
-		if (retry <= 0) {
-			dev_err(&spi->dev,
-				"Error, data read response (%02x)\n", rsp);
-			return N_RESET;
-		}
-	}
-
-	if (cmd == CMD_INTERNAL_READ || cmd == CMD_SINGLE_READ) {
-		/*
-		 * Read bytes
-		 */
-		if ((rix + 3) < len2) {
-			b[0] = rb[rix++];
-			b[1] = rb[rix++];
-			b[2] = rb[rix++];
-			b[3] = rb[rix++];
-		} else {
-			dev_err(&spi->dev,
-				"buffer overrun when reading data.\n");
-			return N_FAIL;
-		}
-
-		if (!spi_priv->crc_off) {
-			/*
-			 * Read Crc
-			 */
-			if ((rix + 1) < len2) {
-				crc[0] = rb[rix++];
-				crc[1] = rb[rix++];
-			} else {
-				dev_err(&spi->dev,
-					"buffer overrun when reading crc.\n");
-				return N_FAIL;
-			}
-		}
-	} else if ((cmd == CMD_DMA_READ) || (cmd == CMD_DMA_EXT_READ)) {
-		int ix;
-
-		/* some data may be read in response to dummy bytes. */
-		for (ix = 0; (rix < len2) && (ix < sz); )
-			b[ix++] = rb[rix++];
-
-		sz -= ix;
-
-		if (sz > 0) {
-			int nbytes;
-
-			if (sz <= (DATA_PKT_SZ - ix))
-				nbytes = sz;
-			else
-				nbytes = DATA_PKT_SZ - ix;
-
-			/*
-			 * Read bytes
-			 */
-			if (wilc_spi_rx(wilc, &b[ix], nbytes)) {
-				dev_err(&spi->dev,
-					"Failed block read, bus err\n");
-				return N_FAIL;
-			}
-
-			/*
-			 * Read Crc
-			 */
-			if (!spi_priv->crc_off && wilc_spi_rx(wilc, crc, 2)) {
-				dev_err(&spi->dev,
-					"Failed block crc read, bus err\n");
-				return N_FAIL;
-			}
-
-			ix += nbytes;
-			sz -= nbytes;
-		}
-
-		/*
-		 * if any data in left unread,
-		 * then read the rest using normal DMA code.
-		 */
-		while (sz > 0) {
-			int nbytes;
-
-			if (sz <= DATA_PKT_SZ)
-				nbytes = sz;
-			else
-				nbytes = DATA_PKT_SZ;
-
-			/*
-			 * read data response only on the next DMA cycles not
-			 * the first DMA since data response header is already
-			 * handled above for the first DMA.
-			 */
-			/*
-			 * Data Respnose header
-			 */
-			retry = 10;
-			do {
-				if (wilc_spi_rx(wilc, &rsp, 1)) {
-					dev_err(&spi->dev,
-						"Failed resp read, bus err\n");
-					result = N_FAIL;
-					break;
-				}
-				if (((rsp >> 4) & 0xf) == 0xf)
-					break;
-			} while (retry--);
-
-			if (result == N_FAIL)
-				break;
-
-			/*
-			 * Read bytes
-			 */
-			if (wilc_spi_rx(wilc, &b[ix], nbytes)) {
-				dev_err(&spi->dev,
-					"Failed block read, bus err\n");
-				result = N_FAIL;
-				break;
-			}
-
-			/*
-			 * Read Crc
-			 */
-			if (!spi_priv->crc_off && wilc_spi_rx(wilc, crc, 2)) {
-				dev_err(&spi->dev,
-					"Failed block crc read, bus err\n");
-				result = N_FAIL;
-				break;
-			}
-
-			ix += nbytes;
-			sz -= nbytes;
-		}
-	}
-	return result;
-}
-
-static int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	struct wilc_spi *spi_priv = wilc->bus_data;
-	int ix, nbytes;
-	int result = 1;
-	u8 cmd, order, crc[2] = {0};
-
-	/*
-	 * Data
-	 */
-	ix = 0;
-	do {
-		if (sz <= DATA_PKT_SZ) {
-			nbytes = sz;
-			order = 0x3;
-		} else {
-			nbytes = DATA_PKT_SZ;
-			if (ix == 0)
-				order = 0x1;
-			else
-				order = 0x02;
-		}
-
-		/*
-		 * Write command
-		 */
-		cmd = 0xf0;
-		cmd |= order;
-
-		if (wilc_spi_tx(wilc, &cmd, 1)) {
-			dev_err(&spi->dev,
-				"Failed data block cmd write, bus error...\n");
-			result = N_FAIL;
-			break;
-		}
-
-		/*
-		 * Write data
-		 */
-		if (wilc_spi_tx(wilc, &b[ix], nbytes)) {
-			dev_err(&spi->dev,
-				"Failed data block write, bus error...\n");
-			result = N_FAIL;
-			break;
-		}
-
-		/*
-		 * Write Crc
-		 */
-		if (!spi_priv->crc_off) {
-			if (wilc_spi_tx(wilc, crc, 2)) {
-				dev_err(&spi->dev, "Failed data block crc write, bus error...\n");
-				result = N_FAIL;
-				break;
-			}
-		}
-
-		/*
-		 * No need to wait for response
-		 */
-		ix += nbytes;
-		sz -= nbytes;
-	} while (sz);
-
-	return result;
-}
-
-/********************************************
- *
- *      Spi Internal Read/Write Function
- *
- ********************************************/
-
-static int spi_internal_write(struct wilc *wilc, u32 adr, u32 dat)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	int result;
-
-	cpu_to_le32s(&dat);
-	result = spi_cmd_complete(wilc, CMD_INTERNAL_WRITE, adr, (u8 *)&dat, 4,
-				  0);
-	if (result != N_OK)
-		dev_err(&spi->dev, "Failed internal write cmd...\n");
-
-	return result;
-}
-
-static int spi_internal_read(struct wilc *wilc, u32 adr, u32 *data)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	int result;
-
-	result = spi_cmd_complete(wilc, CMD_INTERNAL_READ, adr, (u8 *)data, 4,
-				  0);
-	if (result != N_OK) {
-		dev_err(&spi->dev, "Failed internal read cmd...\n");
-		return 0;
-	}
-
-	le32_to_cpus(data);
-
-	return 1;
-}
-
-/********************************************
- *
- *      Spi interfaces
- *
- ********************************************/
-
-static int wilc_spi_write_reg(struct wilc *wilc, u32 addr, u32 data)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	int result = N_OK;
-	u8 cmd = CMD_SINGLE_WRITE;
-	u8 clockless = 0;
-
-	cpu_to_le32s(&data);
-	if (addr < 0x30) {
-		/* Clockless register */
-		cmd = CMD_INTERNAL_WRITE;
-		clockless = 1;
-	}
-
-	result = spi_cmd_complete(wilc, cmd, addr, (u8 *)&data, 4, clockless);
-	if (result != N_OK)
-		dev_err(&spi->dev, "Failed cmd, write reg (%08x)...\n", addr);
-
-	return result;
-}
-
-static int wilc_spi_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	int result;
-
-	/*
-	 * has to be greated than 4
-	 */
-	if (size <= 4)
-		return 0;
-
-	result = spi_cmd_complete(wilc, CMD_DMA_EXT_WRITE, addr, NULL, size, 0);
-	if (result != N_OK) {
-		dev_err(&spi->dev,
-			"Failed cmd, write block (%08x)...\n", addr);
-		return 0;
-	}
-
-	/*
-	 * Data
-	 */
-	result = spi_data_write(wilc, buf, size);
-	if (result != N_OK)
-		dev_err(&spi->dev, "Failed block data write...\n");
-
-	return 1;
-}
-
-static int wilc_spi_read_reg(struct wilc *wilc, u32 addr, u32 *data)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	int result = N_OK;
-	u8 cmd = CMD_SINGLE_READ;
-	u8 clockless = 0;
-
-	if (addr < 0x30) {
-		/* Clockless register */
-		cmd = CMD_INTERNAL_READ;
-		clockless = 1;
-	}
-
-	result = spi_cmd_complete(wilc, cmd, addr, (u8 *)data, 4, clockless);
-	if (result != N_OK) {
-		dev_err(&spi->dev, "Failed cmd, read reg (%08x)...\n", addr);
-		return 0;
-	}
-
-	le32_to_cpus(data);
-
-	return 1;
-}
-
-static int wilc_spi_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	int result;
-
-	if (size <= 4)
-		return 0;
-
-	result = spi_cmd_complete(wilc, CMD_DMA_EXT_READ, addr, buf, size, 0);
-	if (result != N_OK) {
-		dev_err(&spi->dev, "Failed cmd, read block (%08x)...\n", addr);
-		return 0;
-	}
-
-	return 1;
-}
-
-/********************************************
- *
- *      Bus interfaces
- *
- ********************************************/
-
-static int wilc_spi_deinit(struct wilc *wilc)
-{
-	/*
-	 * TODO:
-	 */
-	return 1;
-}
-
-static int wilc_spi_init(struct wilc *wilc, bool resume)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	struct wilc_spi *spi_priv = wilc->bus_data;
-	u32 reg;
-	u32 chipid;
-	static int isinit;
-
-	if (isinit) {
-		if (!wilc_spi_read_reg(wilc, 0x1000, &chipid)) {
-			dev_err(&spi->dev, "Fail cmd read chip id...\n");
-			return 0;
-		}
-		return 1;
-	}
-
-	/*
-	 * configure protocol
-	 */
-
-	/*
-	 * TODO: We can remove the CRC trials if there is a definite
-	 * way to reset
-	 */
-	/* the SPI to it's initial value. */
-	if (!spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg)) {
-		/*
-		 * Read failed. Try with CRC off. This might happen when module
-		 * is removed but chip isn't reset
-		 */
-		spi_priv->crc_off = 1;
-		dev_err(&spi->dev,
-			"Failed read with CRC on, retrying with CRC off\n");
-		if (!spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg)) {
-			/*
-			 * Read failed with both CRC on and off,
-			 * something went bad
-			 */
-			dev_err(&spi->dev, "Failed internal read protocol\n");
-			return 0;
-		}
-	}
-	if (spi_priv->crc_off == 0) {
-		reg &= ~0xc; /* disable crc checking */
-		reg &= ~0x70;
-		reg |= (0x5 << 4);
-		if (!spi_internal_write(wilc, WILC_SPI_PROTOCOL_OFFSET, reg)) {
-			dev_err(&spi->dev,
-				"[wilc spi %d]: Failed internal write reg\n",
-				__LINE__);
-			return 0;
-		}
-		spi_priv->crc_off = 1;
-	}
-
-	/*
-	 * make sure can read back chip id correctly
-	 */
-	if (!wilc_spi_read_reg(wilc, 0x1000, &chipid)) {
-		dev_err(&spi->dev, "Fail cmd read chip id...\n");
-		return 0;
-	}
-
-	spi_priv->has_thrpt_enh = 1;
-
-	isinit = 1;
-
-	return 1;
-}
-
-static int wilc_spi_read_size(struct wilc *wilc, u32 *size)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	struct wilc_spi *spi_priv = wilc->bus_data;
-	int ret;
-
-	if (spi_priv->has_thrpt_enh) {
-		ret = spi_internal_read(wilc, 0xe840 - WILC_SPI_REG_BASE,
-					size);
-		*size = *size  & IRQ_DMA_WD_CNT_MASK;
-	} else {
-		u32 tmp;
-		u32 byte_cnt;
-
-		ret = wilc_spi_read_reg(wilc, WILC_VMM_TO_HOST_SIZE,
-					&byte_cnt);
-		if (!ret) {
-			dev_err(&spi->dev,
-				"Failed read WILC_VMM_TO_HOST_SIZE ...\n");
-			return ret;
-		}
-		tmp = (byte_cnt >> 2) & IRQ_DMA_WD_CNT_MASK;
-		*size = tmp;
-	}
-
-	return ret;
-}
-
-static int wilc_spi_read_int(struct wilc *wilc, u32 *int_status)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	struct wilc_spi *spi_priv = wilc->bus_data;
-	int ret;
-	u32 tmp;
-	u32 byte_cnt;
-	bool unexpected_irq;
-	int j;
-	u32 unknown_mask;
-	u32 irq_flags;
-	int k = IRG_FLAGS_OFFSET + 5;
-
-	if (spi_priv->has_thrpt_enh)
-		return spi_internal_read(wilc, 0xe840 - WILC_SPI_REG_BASE,
-					 int_status);
-	ret = wilc_spi_read_reg(wilc, WILC_VMM_TO_HOST_SIZE, &byte_cnt);
-	if (!ret) {
-		dev_err(&spi->dev,
-			"Failed read WILC_VMM_TO_HOST_SIZE ...\n");
-		return ret;
-	}
-	tmp = (byte_cnt >> 2) & IRQ_DMA_WD_CNT_MASK;
-
-	j = 0;
-	do {
-		wilc_spi_read_reg(wilc, 0x1a90, &irq_flags);
-		tmp |= ((irq_flags >> 27) << IRG_FLAGS_OFFSET);
-
-		if (spi_priv->nint > 5) {
-			wilc_spi_read_reg(wilc, 0x1a94, &irq_flags);
-			tmp |= (((irq_flags >> 0) & 0x7) << k);
-		}
-
-		unknown_mask = ~((1ul << spi_priv->nint) - 1);
-
-		unexpected_irq = (tmp >> IRG_FLAGS_OFFSET) & unknown_mask;
-		if (unexpected_irq) {
-			dev_err(&spi->dev,
-				"Unexpected interrupt(2):j=%d,tmp=%x,mask=%x\n",
-				j, tmp, unknown_mask);
-		}
-
-		j++;
-	} while (unexpected_irq);
-
-	*int_status = tmp;
-
-	return ret;
-}
-
-static int wilc_spi_clear_int_ext(struct wilc *wilc, u32 val)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	struct wilc_spi *spi_priv = wilc->bus_data;
-	int ret;
-	u32 flags;
-	u32 tbl_ctl;
-
-	if (spi_priv->has_thrpt_enh) {
-		return spi_internal_write(wilc, 0xe844 - WILC_SPI_REG_BASE,
-					  val);
-	}
-
-	flags = val & (BIT(MAX_NUM_INT) - 1);
-	if (flags) {
-		int i;
-
-		ret = 1;
-		for (i = 0; i < spi_priv->nint; i++) {
-			/*
-			 * No matter what you write 1 or 0,
-			 * it will clear interrupt.
-			 */
-			if (flags & 1)
-				ret = wilc_spi_write_reg(wilc,
-							 0x10c8 + i * 4, 1);
-			if (!ret)
-				break;
-			flags >>= 1;
-		}
-		if (!ret) {
-			dev_err(&spi->dev,
-				"Failed wilc_spi_write_reg, set reg %x ...\n",
-				0x10c8 + i * 4);
-			return ret;
-		}
-		for (i = spi_priv->nint; i < MAX_NUM_INT; i++) {
-			if (flags & 1)
-				dev_err(&spi->dev,
-					"Unexpected interrupt cleared %d...\n",
-					i);
-			flags >>= 1;
-		}
-	}
-
-	tbl_ctl = 0;
-	/* select VMM table 0 */
-	if (val & SEL_VMM_TBL0)
-		tbl_ctl |= BIT(0);
-	/* select VMM table 1 */
-	if (val & SEL_VMM_TBL1)
-		tbl_ctl |= BIT(1);
-
-	ret = wilc_spi_write_reg(wilc, WILC_VMM_TBL_CTL, tbl_ctl);
-	if (!ret) {
-		dev_err(&spi->dev, "fail write reg vmm_tbl_ctl...\n");
-		return ret;
-	}
-
-	if (val & EN_VMM) {
-		/*
-		 * enable vmm transfer.
-		 */
-		ret = wilc_spi_write_reg(wilc, WILC_VMM_CORE_CTL, 1);
-		if (!ret) {
-			dev_err(&spi->dev, "fail write reg vmm_core_ctl...\n");
-			return ret;
-		}
-	}
-
-	return ret;
-}
-
-static int wilc_spi_sync_ext(struct wilc *wilc, int nint)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	struct wilc_spi *spi_priv = wilc->bus_data;
-	u32 reg;
-	int ret, i;
-
-	if (nint > MAX_NUM_INT) {
-		dev_err(&spi->dev, "Too many interrupts (%d)...\n", nint);
-		return 0;
-	}
-
-	spi_priv->nint = nint;
-
-	/*
-	 * interrupt pin mux select
-	 */
-	ret = wilc_spi_read_reg(wilc, WILC_PIN_MUX_0, &reg);
-	if (!ret) {
-		dev_err(&spi->dev, "Failed read reg (%08x)...\n",
-			WILC_PIN_MUX_0);
-		return 0;
-	}
-	reg |= BIT(8);
-	ret = wilc_spi_write_reg(wilc, WILC_PIN_MUX_0, reg);
-	if (!ret) {
-		dev_err(&spi->dev, "Failed write reg (%08x)...\n",
-			WILC_PIN_MUX_0);
-		return 0;
-	}
-
-	/*
-	 * interrupt enable
-	 */
-	ret = wilc_spi_read_reg(wilc, WILC_INTR_ENABLE, &reg);
-	if (!ret) {
-		dev_err(&spi->dev, "Failed read reg (%08x)...\n",
-			WILC_INTR_ENABLE);
-		return 0;
-	}
-
-	for (i = 0; (i < 5) && (nint > 0); i++, nint--)
-		reg |= (BIT((27 + i)));
-
-	ret = wilc_spi_write_reg(wilc, WILC_INTR_ENABLE, reg);
-	if (!ret) {
-		dev_err(&spi->dev, "Failed write reg (%08x)...\n",
-			WILC_INTR_ENABLE);
-		return 0;
-	}
-	if (nint) {
-		ret = wilc_spi_read_reg(wilc, WILC_INTR2_ENABLE, &reg);
-		if (!ret) {
-			dev_err(&spi->dev, "Failed read reg (%08x)...\n",
-				WILC_INTR2_ENABLE);
-			return 0;
-		}
-
-		for (i = 0; (i < 3) && (nint > 0); i++, nint--)
-			reg |= BIT(i);
-
-		ret = wilc_spi_read_reg(wilc, WILC_INTR2_ENABLE, &reg);
-		if (!ret) {
-			dev_err(&spi->dev, "Failed write reg (%08x)...\n",
-				WILC_INTR2_ENABLE);
-			return 0;
-		}
-	}
-
-	return 1;
-}
-
-/* Global spi HIF function table */
-static const struct wilc_hif_func wilc_hif_spi = {
-	.hif_init = wilc_spi_init,
-	.hif_deinit = wilc_spi_deinit,
-	.hif_read_reg = wilc_spi_read_reg,
-	.hif_write_reg = wilc_spi_write_reg,
-	.hif_block_rx = wilc_spi_read,
-	.hif_block_tx = wilc_spi_write,
-	.hif_read_int = wilc_spi_read_int,
-	.hif_clear_int_ext = wilc_spi_clear_int_ext,
-	.hif_read_size = wilc_spi_read_size,
-	.hif_block_tx_ext = wilc_spi_write,
-	.hif_block_rx_ext = wilc_spi_read,
-	.hif_sync_ext = wilc_spi_sync_ext,
-};
diff --git a/drivers/staging/wilc1000/wilc_wfi_netdevice.h b/drivers/staging/wilc1000/wilc_wfi_netdevice.h
deleted file mode 100644
index 978a8bdbf..000000000
--- a/drivers/staging/wilc1000/wilc_wfi_netdevice.h
+++ /dev/null
@@ -1,293 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
- * All rights reserved.
- */
-
-#ifndef WILC_WFI_NETDEVICE
-#define WILC_WFI_NETDEVICE
-
-#include <linux/tcp.h>
-#include <linux/ieee80211.h>
-#include <net/cfg80211.h>
-#include <net/ieee80211_radiotap.h>
-#include <linux/if_arp.h>
-#include <linux/gpio/consumer.h>
-
-#include "wilc_hif.h"
-#include "wilc_wlan.h"
-#include "wilc_wlan_cfg.h"
-
-#define FLOW_CONTROL_LOWER_THRESHOLD		128
-#define FLOW_CONTROL_UPPER_THRESHOLD		256
-
-#define WILC_MAX_NUM_PMKIDS			16
-#define PMKID_FOUND				1
-#define NUM_STA_ASSOCIATED			8
-
-#define NUM_REG_FRAME				2
-
-#define TCP_ACK_FILTER_LINK_SPEED_THRESH	54
-#define DEFAULT_LINK_SPEED			72
-
-#define GET_PKT_OFFSET(a) (((a) >> 22) & 0x1ff)
-
-struct wilc_wfi_stats {
-	unsigned long rx_packets;
-	unsigned long tx_packets;
-	unsigned long rx_bytes;
-	unsigned long tx_bytes;
-	u64 rx_time;
-	u64 tx_time;
-
-};
-
-struct wilc_wfi_key {
-	u8 *key;
-	u8 *seq;
-	int key_len;
-	int seq_len;
-	u32 cipher;
-};
-
-struct wilc_wfi_wep_key {
-	u8 *key;
-	u8 key_len;
-	u8 key_idx;
-};
-
-struct sta_info {
-	u8 sta_associated_bss[WILC_MAX_NUM_STA][ETH_ALEN];
-};
-
-/*Parameters needed for host interface for  remaining on channel*/
-struct wilc_wfi_p2p_listen_params {
-	struct ieee80211_channel *listen_ch;
-	u32 listen_duration;
-	u64 listen_cookie;
-};
-
-struct wilc_p2p_var {
-	u8 local_random;
-	u8 recv_random;
-	bool is_wilc_ie;
-};
-
-static const u32 wilc_cipher_suites[] = {
-	WLAN_CIPHER_SUITE_WEP40,
-	WLAN_CIPHER_SUITE_WEP104,
-	WLAN_CIPHER_SUITE_TKIP,
-	WLAN_CIPHER_SUITE_CCMP,
-	WLAN_CIPHER_SUITE_AES_CMAC
-};
-
-#define CHAN2G(_channel, _freq, _flags) {	 \
-	.band             = NL80211_BAND_2GHZ, \
-	.center_freq      = (_freq),		 \
-	.hw_value         = (_channel),		 \
-	.flags            = (_flags),		 \
-	.max_antenna_gain = 0,			 \
-	.max_power        = 30,			 \
-}
-
-static const struct ieee80211_channel wilc_2ghz_channels[] = {
-	CHAN2G(1,  2412, 0),
-	CHAN2G(2,  2417, 0),
-	CHAN2G(3,  2422, 0),
-	CHAN2G(4,  2427, 0),
-	CHAN2G(5,  2432, 0),
-	CHAN2G(6,  2437, 0),
-	CHAN2G(7,  2442, 0),
-	CHAN2G(8,  2447, 0),
-	CHAN2G(9,  2452, 0),
-	CHAN2G(10, 2457, 0),
-	CHAN2G(11, 2462, 0),
-	CHAN2G(12, 2467, 0),
-	CHAN2G(13, 2472, 0),
-	CHAN2G(14, 2484, 0)
-};
-
-#define RATETAB_ENT(_rate, _hw_value, _flags) {	\
-	.bitrate  = (_rate),			\
-	.hw_value = (_hw_value),		\
-	.flags    = (_flags),			\
-}
-
-static struct ieee80211_rate wilc_bitrates[] = {
-	RATETAB_ENT(10,  0,  0),
-	RATETAB_ENT(20,  1,  0),
-	RATETAB_ENT(55,  2,  0),
-	RATETAB_ENT(110, 3,  0),
-	RATETAB_ENT(60,  9,  0),
-	RATETAB_ENT(90,  6,  0),
-	RATETAB_ENT(120, 7,  0),
-	RATETAB_ENT(180, 8,  0),
-	RATETAB_ENT(240, 9,  0),
-	RATETAB_ENT(360, 10, 0),
-	RATETAB_ENT(480, 11, 0),
-	RATETAB_ENT(540, 12, 0)
-};
-
-struct wilc_priv {
-	struct wireless_dev wdev;
-	struct cfg80211_scan_request *scan_req;
-
-	struct wilc_wfi_p2p_listen_params remain_on_ch_params;
-	u64 tx_cookie;
-
-	bool cfg_scanning;
-
-	u8 associated_bss[ETH_ALEN];
-	struct sta_info assoc_stainfo;
-	struct sk_buff *skb;
-	struct net_device *dev;
-	struct host_if_drv *hif_drv;
-	struct wilc_pmkid_attr pmkid_list;
-	u8 wep_key[4][WLAN_KEY_LEN_WEP104];
-	u8 wep_key_len[4];
-	/* The real interface that the monitor is on */
-	struct net_device *real_ndev;
-	struct wilc_wfi_key *wilc_gtk[WILC_MAX_NUM_STA];
-	struct wilc_wfi_key *wilc_ptk[WILC_MAX_NUM_STA];
-	u8 wilc_groupkey;
-	/* mutexes */
-	struct mutex scan_req_lock;
-	bool p2p_listen_state;
-	int scanned_cnt;
-	struct wilc_p2p_var p2p;
-
-	u64 inc_roc_cookie;
-};
-
-struct frame_reg {
-	u16 type;
-	bool reg;
-};
-
-#define MAX_TCP_SESSION                25
-#define MAX_PENDING_ACKS               256
-
-struct ack_session_info {
-	u32 seq_num;
-	u32 bigger_ack_num;
-	u16 src_port;
-	u16 dst_port;
-	u16 status;
-};
-
-struct pending_acks {
-	u32 ack_num;
-	u32 session_index;
-	struct txq_entry_t  *txqe;
-};
-
-struct tcp_ack_filter {
-	struct ack_session_info ack_session_info[2 * MAX_TCP_SESSION];
-	struct pending_acks pending_acks[MAX_PENDING_ACKS];
-	u32 pending_base;
-	u32 tcp_session;
-	u32 pending_acks_idx;
-	bool enabled;
-};
-
-struct wilc_vif {
-	u8 idx;
-	u8 iftype;
-	int monitor_flag;
-	int mac_opened;
-	struct frame_reg frame_reg[NUM_REG_FRAME];
-	struct net_device_stats netstats;
-	struct wilc *wilc;
-	u8 bssid[ETH_ALEN];
-	struct host_if_drv *hif_drv;
-	struct net_device *ndev;
-	u8 mode;
-	struct timer_list during_ip_timer;
-	struct timer_list periodic_rssi;
-	struct rf_info periodic_stat;
-	struct tcp_ack_filter ack_filter;
-	bool connecting;
-	struct wilc_priv priv;
-};
-
-struct wilc {
-	struct wiphy *wiphy;
-	const struct wilc_hif_func *hif_func;
-	int io_type;
-	s8 mac_status;
-	struct gpio_desc *gpio_irq;
-	struct clk *rtc_clk;
-	bool initialized;
-	int dev_irq_num;
-	int close;
-	u8 vif_num;
-	struct wilc_vif *vif[WILC_NUM_CONCURRENT_IFC];
-	/*protect vif list*/
-	struct mutex vif_mutex;
-	u8 open_ifcs;
-	/*protect head of transmit queue*/
-	struct mutex txq_add_to_head_cs;
-	/*protect txq_entry_t transmit queue*/
-	spinlock_t txq_spinlock;
-	/*protect rxq_entry_t receiver queue*/
-	struct mutex rxq_cs;
-	/* lock to protect hif access */
-	struct mutex hif_cs;
-
-	struct completion cfg_event;
-	struct completion sync_event;
-	struct completion txq_event;
-	struct completion txq_thread_started;
-
-	struct task_struct *txq_thread;
-
-	int quit;
-	/* lock to protect issue of wid command to firmware */
-	struct mutex cfg_cmd_lock;
-	struct wilc_cfg_frame cfg_frame;
-	u32 cfg_frame_offset;
-	u8 cfg_seq_no;
-
-	u8 *rx_buffer;
-	u32 rx_buffer_offset;
-	u8 *tx_buffer;
-
-	struct txq_entry_t txq_head;
-	int txq_entries;
-
-	struct rxq_entry_t rxq_head;
-
-	const struct firmware *firmware;
-
-	struct device *dev;
-	bool suspend_event;
-
-	int clients_count;
-	struct workqueue_struct *hif_workqueue;
-	enum chip_ps_states chip_ps_state;
-	struct wilc_cfg cfg;
-	void *bus_data;
-	struct net_device *monitor_dev;
-	/* deinit lock */
-	struct mutex deinit_lock;
-	u8 sta_ch;
-	u8 op_ch;
-	struct ieee80211_channel channels[ARRAY_SIZE(wilc_2ghz_channels)];
-	struct ieee80211_rate bitrates[ARRAY_SIZE(wilc_bitrates)];
-	struct ieee80211_supported_band band;
-	u32 cipher_suites[ARRAY_SIZE(wilc_cipher_suites)];
-};
-
-struct wilc_wfi_mon_priv {
-	struct net_device *real_ndev;
-};
-
-void wilc_frmw_to_host(struct wilc *wilc, u8 *buff, u32 size, u32 pkt_offset);
-void wilc_mac_indicate(struct wilc *wilc);
-void wilc_netdev_cleanup(struct wilc *wilc);
-void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size);
-void wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode);
-struct wilc_vif *wilc_netdev_ifc_init(struct wilc *wl, const char *name,
-				      int vif_type, enum nl80211_iftype type,
-				      bool rtnl_locked);
-#endif
diff --git a/drivers/staging/wilc1000/wilc_wlan.c b/drivers/staging/wilc1000/wilc_wlan.c
deleted file mode 100644
index 02f551536..000000000
--- a/drivers/staging/wilc1000/wilc_wlan.c
+++ /dev/null
@@ -1,1268 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
- * All rights reserved.
- */
-
-#include <linux/if_ether.h>
-#include <linux/ip.h>
-#include "wilc_wfi_cfgoperations.h"
-#include "wilc_wlan_cfg.h"
-
-static inline bool is_wilc1000(u32 id)
-{
-	return (id & 0xfffff000) == 0x100000;
-}
-
-static inline void acquire_bus(struct wilc *wilc, enum bus_acquire acquire)
-{
-	mutex_lock(&wilc->hif_cs);
-	if (acquire == WILC_BUS_ACQUIRE_AND_WAKEUP)
-		chip_wakeup(wilc);
-}
-
-static inline void release_bus(struct wilc *wilc, enum bus_release release)
-{
-	if (release == WILC_BUS_RELEASE_ALLOW_SLEEP)
-		chip_allow_sleep(wilc);
-	mutex_unlock(&wilc->hif_cs);
-}
-
-static void wilc_wlan_txq_remove(struct wilc *wilc, struct txq_entry_t *tqe)
-{
-	list_del(&tqe->list);
-	wilc->txq_entries -= 1;
-}
-
-static struct txq_entry_t *
-wilc_wlan_txq_remove_from_head(struct net_device *dev)
-{
-	struct txq_entry_t *tqe = NULL;
-	unsigned long flags;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-
-	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-
-	if (!list_empty(&wilc->txq_head.list)) {
-		tqe = list_first_entry(&wilc->txq_head.list, struct txq_entry_t,
-				       list);
-		list_del(&tqe->list);
-		wilc->txq_entries -= 1;
-	}
-	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
-	return tqe;
-}
-
-static void wilc_wlan_txq_add_to_tail(struct net_device *dev,
-				      struct txq_entry_t *tqe)
-{
-	unsigned long flags;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-
-	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-
-	list_add_tail(&tqe->list, &wilc->txq_head.list);
-	wilc->txq_entries += 1;
-
-	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
-
-	complete(&wilc->txq_event);
-}
-
-static void wilc_wlan_txq_add_to_head(struct wilc_vif *vif,
-				      struct txq_entry_t *tqe)
-{
-	unsigned long flags;
-	struct wilc *wilc = vif->wilc;
-
-	mutex_lock(&wilc->txq_add_to_head_cs);
-
-	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-
-	list_add(&tqe->list, &wilc->txq_head.list);
-	wilc->txq_entries += 1;
-
-	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
-	mutex_unlock(&wilc->txq_add_to_head_cs);
-	complete(&wilc->txq_event);
-}
-
-#define NOT_TCP_ACK			(-1)
-
-static inline void add_tcp_session(struct wilc_vif *vif, u32 src_prt,
-				   u32 dst_prt, u32 seq)
-{
-	struct tcp_ack_filter *f = &vif->ack_filter;
-
-	if (f->tcp_session < 2 * MAX_TCP_SESSION) {
-		f->ack_session_info[f->tcp_session].seq_num = seq;
-		f->ack_session_info[f->tcp_session].bigger_ack_num = 0;
-		f->ack_session_info[f->tcp_session].src_port = src_prt;
-		f->ack_session_info[f->tcp_session].dst_port = dst_prt;
-		f->tcp_session++;
-	}
-}
-
-static inline void update_tcp_session(struct wilc_vif *vif, u32 index, u32 ack)
-{
-	struct tcp_ack_filter *f = &vif->ack_filter;
-
-	if (index < 2 * MAX_TCP_SESSION &&
-	    ack > f->ack_session_info[index].bigger_ack_num)
-		f->ack_session_info[index].bigger_ack_num = ack;
-}
-
-static inline void add_tcp_pending_ack(struct wilc_vif *vif, u32 ack,
-				       u32 session_index,
-				       struct txq_entry_t *txqe)
-{
-	struct tcp_ack_filter *f = &vif->ack_filter;
-	u32 i = f->pending_base + f->pending_acks_idx;
-
-	if (i < MAX_PENDING_ACKS) {
-		f->pending_acks[i].ack_num = ack;
-		f->pending_acks[i].txqe = txqe;
-		f->pending_acks[i].session_index = session_index;
-		txqe->ack_idx = i;
-		f->pending_acks_idx++;
-	}
-}
-
-static inline void tcp_process(struct net_device *dev, struct txq_entry_t *tqe)
-{
-	void *buffer = tqe->buffer;
-	const struct ethhdr *eth_hdr_ptr = buffer;
-	int i;
-	unsigned long flags;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-	struct tcp_ack_filter *f = &vif->ack_filter;
-	const struct iphdr *ip_hdr_ptr;
-	const struct tcphdr *tcp_hdr_ptr;
-	u32 ihl, total_length, data_offset;
-
-	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-
-	if (eth_hdr_ptr->h_proto != htons(ETH_P_IP))
-		goto out;
-
-	ip_hdr_ptr = buffer + ETH_HLEN;
-
-	if (ip_hdr_ptr->protocol != IPPROTO_TCP)
-		goto out;
-
-	ihl = ip_hdr_ptr->ihl << 2;
-	tcp_hdr_ptr = buffer + ETH_HLEN + ihl;
-	total_length = ntohs(ip_hdr_ptr->tot_len);
-
-	data_offset = tcp_hdr_ptr->doff << 2;
-	if (total_length == (ihl + data_offset)) {
-		u32 seq_no, ack_no;
-
-		seq_no = ntohl(tcp_hdr_ptr->seq);
-		ack_no = ntohl(tcp_hdr_ptr->ack_seq);
-		for (i = 0; i < f->tcp_session; i++) {
-			u32 j = f->ack_session_info[i].seq_num;
-
-			if (i < 2 * MAX_TCP_SESSION &&
-			    j == seq_no) {
-				update_tcp_session(vif, i, ack_no);
-				break;
-			}
-		}
-		if (i == f->tcp_session)
-			add_tcp_session(vif, 0, 0, seq_no);
-
-		add_tcp_pending_ack(vif, ack_no, i, tqe);
-	}
-
-out:
-	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
-}
-
-static void wilc_wlan_txq_filter_dup_tcp_ack(struct net_device *dev)
-{
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-	struct tcp_ack_filter *f = &vif->ack_filter;
-	u32 i = 0;
-	u32 dropped = 0;
-	unsigned long flags;
-
-	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-	for (i = f->pending_base;
-	     i < (f->pending_base + f->pending_acks_idx); i++) {
-		u32 index;
-		u32 bigger_ack_num;
-
-		if (i >= MAX_PENDING_ACKS)
-			break;
-
-		index = f->pending_acks[i].session_index;
-
-		if (index >= 2 * MAX_TCP_SESSION)
-			break;
-
-		bigger_ack_num = f->ack_session_info[index].bigger_ack_num;
-
-		if (f->pending_acks[i].ack_num < bigger_ack_num) {
-			struct txq_entry_t *tqe;
-
-			tqe = f->pending_acks[i].txqe;
-			if (tqe) {
-				wilc_wlan_txq_remove(wilc, tqe);
-				tqe->status = 1;
-				if (tqe->tx_complete_func)
-					tqe->tx_complete_func(tqe->priv,
-							      tqe->status);
-				kfree(tqe);
-				dropped++;
-			}
-		}
-	}
-	f->pending_acks_idx = 0;
-	f->tcp_session = 0;
-
-	if (f->pending_base == 0)
-		f->pending_base = MAX_TCP_SESSION;
-	else
-		f->pending_base = 0;
-
-	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
-
-	while (dropped > 0) {
-		wait_for_completion_timeout(&wilc->txq_event,
-					    msecs_to_jiffies(1));
-		dropped--;
-	}
-}
-
-void wilc_enable_tcp_ack_filter(struct wilc_vif *vif, bool value)
-{
-	vif->ack_filter.enabled = value;
-}
-
-static int wilc_wlan_txq_add_cfg_pkt(struct wilc_vif *vif, u8 *buffer,
-				     u32 buffer_size)
-{
-	struct txq_entry_t *tqe;
-	struct wilc *wilc = vif->wilc;
-
-	netdev_dbg(vif->ndev, "Adding config packet ...\n");
-	if (wilc->quit) {
-		netdev_dbg(vif->ndev, "Return due to clear function\n");
-		complete(&wilc->cfg_event);
-		return 0;
-	}
-
-	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
-	if (!tqe)
-		return 0;
-
-	tqe->type = WILC_CFG_PKT;
-	tqe->buffer = buffer;
-	tqe->buffer_size = buffer_size;
-	tqe->tx_complete_func = NULL;
-	tqe->priv = NULL;
-	tqe->ack_idx = NOT_TCP_ACK;
-	tqe->vif = vif;
-
-	wilc_wlan_txq_add_to_head(vif, tqe);
-
-	return 1;
-}
-
-int wilc_wlan_txq_add_net_pkt(struct net_device *dev, void *priv, u8 *buffer,
-			      u32 buffer_size,
-			      void (*tx_complete_fn)(void *, int))
-{
-	struct txq_entry_t *tqe;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc;
-
-	wilc = vif->wilc;
-
-	if (wilc->quit)
-		return 0;
-
-	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
-
-	if (!tqe)
-		return 0;
-	tqe->type = WILC_NET_PKT;
-	tqe->buffer = buffer;
-	tqe->buffer_size = buffer_size;
-	tqe->tx_complete_func = tx_complete_fn;
-	tqe->priv = priv;
-	tqe->vif = vif;
-
-	tqe->ack_idx = NOT_TCP_ACK;
-	if (vif->ack_filter.enabled)
-		tcp_process(dev, tqe);
-	wilc_wlan_txq_add_to_tail(dev, tqe);
-	return wilc->txq_entries;
-}
-
-int wilc_wlan_txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
-			       u32 buffer_size,
-			       void (*tx_complete_fn)(void *, int))
-{
-	struct txq_entry_t *tqe;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc;
-
-	wilc = vif->wilc;
-
-	if (wilc->quit)
-		return 0;
-
-	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
-
-	if (!tqe)
-		return 0;
-	tqe->type = WILC_MGMT_PKT;
-	tqe->buffer = buffer;
-	tqe->buffer_size = buffer_size;
-	tqe->tx_complete_func = tx_complete_fn;
-	tqe->priv = priv;
-	tqe->ack_idx = NOT_TCP_ACK;
-	tqe->vif = vif;
-	wilc_wlan_txq_add_to_tail(dev, tqe);
-	return 1;
-}
-
-static struct txq_entry_t *wilc_wlan_txq_get_first(struct wilc *wilc)
-{
-	struct txq_entry_t *tqe = NULL;
-	unsigned long flags;
-
-	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-
-	if (!list_empty(&wilc->txq_head.list))
-		tqe = list_first_entry(&wilc->txq_head.list, struct txq_entry_t,
-				       list);
-
-	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
-
-	return tqe;
-}
-
-static struct txq_entry_t *wilc_wlan_txq_get_next(struct wilc *wilc,
-						  struct txq_entry_t *tqe)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-
-	if (!list_is_last(&tqe->list, &wilc->txq_head.list))
-		tqe = list_next_entry(tqe, list);
-	else
-		tqe = NULL;
-	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
-
-	return tqe;
-}
-
-static void wilc_wlan_rxq_add(struct wilc *wilc, struct rxq_entry_t *rqe)
-{
-	if (wilc->quit)
-		return;
-
-	mutex_lock(&wilc->rxq_cs);
-	list_add_tail(&rqe->list, &wilc->rxq_head.list);
-	mutex_unlock(&wilc->rxq_cs);
-}
-
-static struct rxq_entry_t *wilc_wlan_rxq_remove(struct wilc *wilc)
-{
-	struct rxq_entry_t *rqe = NULL;
-
-	mutex_lock(&wilc->rxq_cs);
-	if (!list_empty(&wilc->rxq_head.list)) {
-		rqe = list_first_entry(&wilc->rxq_head.list, struct rxq_entry_t,
-				       list);
-		list_del(&rqe->list);
-	}
-	mutex_unlock(&wilc->rxq_cs);
-	return rqe;
-}
-
-void chip_allow_sleep(struct wilc *wilc)
-{
-	u32 reg = 0;
-
-	wilc->hif_func->hif_read_reg(wilc, 0xf0, &reg);
-
-	wilc->hif_func->hif_write_reg(wilc, 0xf0, reg & ~BIT(0));
-	wilc->hif_func->hif_write_reg(wilc, 0xfa, 0);
-}
-EXPORT_SYMBOL_GPL(chip_allow_sleep);
-
-void chip_wakeup(struct wilc *wilc)
-{
-	u32 reg, clk_status_reg;
-
-	if ((wilc->io_type & 0x1) == WILC_HIF_SPI) {
-		do {
-			wilc->hif_func->hif_read_reg(wilc, 1, &reg);
-			wilc->hif_func->hif_write_reg(wilc, 1, reg | BIT(1));
-			wilc->hif_func->hif_write_reg(wilc, 1, reg & ~BIT(1));
-
-			do {
-				usleep_range(2000, 2500);
-				wilc_get_chipid(wilc, true);
-			} while (wilc_get_chipid(wilc, true) == 0);
-		} while (wilc_get_chipid(wilc, true) == 0);
-	} else if ((wilc->io_type & 0x1) == WILC_HIF_SDIO) {
-		wilc->hif_func->hif_write_reg(wilc, 0xfa, 1);
-		usleep_range(200, 400);
-		wilc->hif_func->hif_read_reg(wilc, 0xf0, &reg);
-		do {
-			wilc->hif_func->hif_write_reg(wilc, 0xf0,
-						      reg | BIT(0));
-			wilc->hif_func->hif_read_reg(wilc, 0xf1,
-						     &clk_status_reg);
-
-			while ((clk_status_reg & 0x1) == 0) {
-				usleep_range(2000, 2500);
-
-				wilc->hif_func->hif_read_reg(wilc, 0xf1,
-							     &clk_status_reg);
-			}
-			if ((clk_status_reg & 0x1) == 0) {
-				wilc->hif_func->hif_write_reg(wilc, 0xf0,
-							      reg & (~BIT(0)));
-			}
-		} while ((clk_status_reg & 0x1) == 0);
-	}
-
-	if (wilc->chip_ps_state == WILC_CHIP_SLEEPING_MANUAL) {
-		if (wilc_get_chipid(wilc, false) < 0x1002b0) {
-			u32 val32;
-
-			wilc->hif_func->hif_read_reg(wilc, 0x1e1c, &val32);
-			val32 |= BIT(6);
-			wilc->hif_func->hif_write_reg(wilc, 0x1e1c, val32);
-
-			wilc->hif_func->hif_read_reg(wilc, 0x1e9c, &val32);
-			val32 |= BIT(6);
-			wilc->hif_func->hif_write_reg(wilc, 0x1e9c, val32);
-		}
-	}
-	wilc->chip_ps_state = WILC_CHIP_WAKEDUP;
-}
-EXPORT_SYMBOL_GPL(chip_wakeup);
-
-void host_wakeup_notify(struct wilc *wilc)
-{
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
-	wilc->hif_func->hif_write_reg(wilc, 0x10b0, 1);
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
-}
-EXPORT_SYMBOL_GPL(host_wakeup_notify);
-
-void host_sleep_notify(struct wilc *wilc)
-{
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
-	wilc->hif_func->hif_write_reg(wilc, 0x10ac, 1);
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
-}
-EXPORT_SYMBOL_GPL(host_sleep_notify);
-
-int wilc_wlan_handle_txq(struct wilc *wilc, u32 *txq_count)
-{
-	int i, entries = 0;
-	u32 sum;
-	u32 reg;
-	u32 offset = 0;
-	int vmm_sz = 0;
-	struct txq_entry_t *tqe;
-	int ret = 0;
-	int counter;
-	int timeout;
-	u32 vmm_table[WILC_VMM_TBL_SIZE];
-	const struct wilc_hif_func *func;
-	u8 *txb = wilc->tx_buffer;
-	struct net_device *dev;
-	struct wilc_vif *vif;
-
-	if (wilc->quit)
-		goto out;
-
-	mutex_lock(&wilc->txq_add_to_head_cs);
-	tqe = wilc_wlan_txq_get_first(wilc);
-	if (!tqe)
-		goto out;
-	dev = tqe->vif->ndev;
-	wilc_wlan_txq_filter_dup_tcp_ack(dev);
-	i = 0;
-	sum = 0;
-	do {
-		if (tqe && (i < (WILC_VMM_TBL_SIZE - 1))) {
-			if (tqe->type == WILC_CFG_PKT)
-				vmm_sz = ETH_CONFIG_PKT_HDR_OFFSET;
-
-			else if (tqe->type == WILC_NET_PKT)
-				vmm_sz = ETH_ETHERNET_HDR_OFFSET;
-
-			else
-				vmm_sz = HOST_HDR_OFFSET;
-
-			vmm_sz += tqe->buffer_size;
-
-			if (vmm_sz & 0x3)
-				vmm_sz = (vmm_sz + 4) & ~0x3;
-
-			if ((sum + vmm_sz) > WILC_TX_BUFF_SIZE)
-				break;
-
-			vmm_table[i] = vmm_sz / 4;
-			if (tqe->type == WILC_CFG_PKT)
-				vmm_table[i] |= BIT(10);
-			cpu_to_le32s(&vmm_table[i]);
-
-			i++;
-			sum += vmm_sz;
-			tqe = wilc_wlan_txq_get_next(wilc, tqe);
-		} else {
-			break;
-		}
-	} while (1);
-
-	if (i == 0)
-		goto out;
-	vmm_table[i] = 0x0;
-
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
-	counter = 0;
-	func = wilc->hif_func;
-	do {
-		ret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
-		if (!ret)
-			break;
-
-		if ((reg & 0x1) == 0)
-			break;
-
-		counter++;
-		if (counter > 200) {
-			counter = 0;
-			ret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, 0);
-			break;
-		}
-	} while (!wilc->quit);
-
-	if (!ret)
-		goto out_release_bus;
-
-	timeout = 200;
-	do {
-		ret = func->hif_block_tx(wilc,
-					 WILC_VMM_TBL_RX_SHADOW_BASE,
-					 (u8 *)vmm_table,
-					 ((i + 1) * 4));
-		if (!ret)
-			break;
-
-		ret = func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x2);
-		if (!ret)
-			break;
-
-		do {
-			ret = func->hif_read_reg(wilc, WILC_HOST_VMM_CTL, &reg);
-			if (!ret)
-				break;
-			if ((reg >> 2) & 0x1) {
-				entries = ((reg >> 3) & 0x3f);
-				break;
-			}
-		} while (--timeout);
-		if (timeout <= 0) {
-			ret = func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x0);
-			break;
-		}
-
-		if (!ret)
-			break;
-
-		if (entries == 0) {
-			ret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
-			if (!ret)
-				break;
-			reg &= ~BIT(0);
-			ret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, reg);
-			if (!ret)
-				break;
-			break;
-		}
-		break;
-	} while (1);
-
-	if (!ret)
-		goto out_release_bus;
-
-	if (entries == 0) {
-		ret = -ENOBUFS;
-		goto out_release_bus;
-	}
-
-	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
-
-	offset = 0;
-	i = 0;
-	do {
-		u32 header, buffer_offset;
-		char *bssid;
-
-		tqe = wilc_wlan_txq_remove_from_head(dev);
-		if (!tqe)
-			break;
-
-		vif = tqe->vif;
-		if (vmm_table[i] == 0)
-			break;
-
-		le32_to_cpus(&vmm_table[i]);
-		vmm_sz = (vmm_table[i] & 0x3ff);
-		vmm_sz *= 4;
-		header = (tqe->type << 31) |
-			 (tqe->buffer_size << 15) |
-			 vmm_sz;
-		if (tqe->type == WILC_MGMT_PKT)
-			header |= BIT(30);
-		else
-			header &= ~BIT(30);
-
-		cpu_to_le32s(&header);
-		memcpy(&txb[offset], &header, 4);
-		if (tqe->type == WILC_CFG_PKT) {
-			buffer_offset = ETH_CONFIG_PKT_HDR_OFFSET;
-		} else if (tqe->type == WILC_NET_PKT) {
-			bssid = tqe->vif->bssid;
-			buffer_offset = ETH_ETHERNET_HDR_OFFSET;
-			memcpy(&txb[offset + 8], bssid, 6);
-		} else {
-			buffer_offset = HOST_HDR_OFFSET;
-		}
-
-		memcpy(&txb[offset + buffer_offset],
-		       tqe->buffer, tqe->buffer_size);
-		offset += vmm_sz;
-		i++;
-		tqe->status = 1;
-		if (tqe->tx_complete_func)
-			tqe->tx_complete_func(tqe->priv, tqe->status);
-		if (tqe->ack_idx != NOT_TCP_ACK &&
-		    tqe->ack_idx < MAX_PENDING_ACKS)
-			vif->ack_filter.pending_acks[tqe->ack_idx].txqe = NULL;
-		kfree(tqe);
-	} while (--entries);
-
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
-
-	ret = func->hif_clear_int_ext(wilc, ENABLE_TX_VMM);
-	if (!ret)
-		goto out_release_bus;
-
-	ret = func->hif_block_tx_ext(wilc, 0, txb, offset);
-
-out_release_bus:
-	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
-
-out:
-	mutex_unlock(&wilc->txq_add_to_head_cs);
-
-	*txq_count = wilc->txq_entries;
-	return ret;
-}
-
-static void wilc_wlan_handle_rx_buff(struct wilc *wilc, u8 *buffer, int size)
-{
-	int offset = 0;
-	u32 header;
-	u32 pkt_len, pkt_offset, tp_len;
-	int is_cfg_packet;
-	u8 *buff_ptr;
-
-	do {
-		buff_ptr = buffer + offset;
-		header = get_unaligned_le32(buff_ptr);
-
-		is_cfg_packet = (header >> 31) & 0x1;
-		pkt_offset = (header >> 22) & 0x1ff;
-		tp_len = (header >> 11) & 0x7ff;
-		pkt_len = header & 0x7ff;
-
-		if (pkt_len == 0 || tp_len == 0)
-			break;
-
-		if (pkt_offset & IS_MANAGMEMENT) {
-			buff_ptr += HOST_HDR_OFFSET;
-			wilc_wfi_mgmt_rx(wilc, buff_ptr, pkt_len);
-		} else {
-			if (!is_cfg_packet) {
-				if (pkt_len > 0) {
-					wilc_frmw_to_host(wilc, buff_ptr,
-							  pkt_len, pkt_offset);
-				}
-			} else {
-				struct wilc_cfg_rsp rsp;
-
-				buff_ptr += pkt_offset;
-
-				wilc_wlan_cfg_indicate_rx(wilc, buff_ptr,
-							  pkt_len,
-							  &rsp);
-				if (rsp.type == WILC_CFG_RSP) {
-					if (wilc->cfg_seq_no == rsp.seq_no)
-						complete(&wilc->cfg_event);
-				} else if (rsp.type == WILC_CFG_RSP_STATUS) {
-					wilc_mac_indicate(wilc);
-				}
-			}
-		}
-		offset += tp_len;
-		if (offset >= size)
-			break;
-	} while (1);
-}
-
-static void wilc_wlan_handle_rxq(struct wilc *wilc)
-{
-	int size;
-	u8 *buffer;
-	struct rxq_entry_t *rqe;
-
-	do {
-		if (wilc->quit) {
-			complete(&wilc->cfg_event);
-			break;
-		}
-		rqe = wilc_wlan_rxq_remove(wilc);
-		if (!rqe)
-			break;
-
-		buffer = rqe->buffer;
-		size = rqe->buffer_size;
-		wilc_wlan_handle_rx_buff(wilc, buffer, size);
-
-		kfree(rqe);
-	} while (1);
-}
-
-static void wilc_unknown_isr_ext(struct wilc *wilc)
-{
-	wilc->hif_func->hif_clear_int_ext(wilc, 0);
-}
-
-static void wilc_wlan_handle_isr_ext(struct wilc *wilc, u32 int_status)
-{
-	u32 offset = wilc->rx_buffer_offset;
-	u8 *buffer = NULL;
-	u32 size;
-	u32 retries = 0;
-	int ret = 0;
-	struct rxq_entry_t *rqe;
-
-	size = (int_status & 0x7fff) << 2;
-
-	while (!size && retries < 10) {
-		wilc->hif_func->hif_read_size(wilc, &size);
-		size = (size & 0x7fff) << 2;
-		retries++;
-	}
-
-	if (size <= 0)
-		return;
-
-	if (WILC_RX_BUFF_SIZE - offset < size)
-		offset = 0;
-
-	buffer = &wilc->rx_buffer[offset];
-
-	wilc->hif_func->hif_clear_int_ext(wilc, DATA_INT_CLR | ENABLE_RX_VMM);
-	ret = wilc->hif_func->hif_block_rx_ext(wilc, 0, buffer, size);
-	if (!ret)
-		return;
-
-	offset += size;
-	wilc->rx_buffer_offset = offset;
-	rqe = kmalloc(sizeof(*rqe), GFP_KERNEL);
-	if (!rqe)
-		return;
-
-	rqe->buffer = buffer;
-	rqe->buffer_size = size;
-	wilc_wlan_rxq_add(wilc, rqe);
-	wilc_wlan_handle_rxq(wilc);
-}
-
-void wilc_handle_isr(struct wilc *wilc)
-{
-	u32 int_status;
-
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
-	wilc->hif_func->hif_read_int(wilc, &int_status);
-
-	if (int_status & DATA_INT_EXT)
-		wilc_wlan_handle_isr_ext(wilc, int_status);
-
-	if (!(int_status & (ALL_INT_EXT)))
-		wilc_unknown_isr_ext(wilc);
-
-	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
-}
-EXPORT_SYMBOL_GPL(wilc_handle_isr);
-
-int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
-				u32 buffer_size)
-{
-	u32 offset;
-	u32 addr, size, size2, blksz;
-	u8 *dma_buffer;
-	int ret = 0;
-
-	blksz = BIT(12);
-
-	dma_buffer = kmalloc(blksz, GFP_KERNEL);
-	if (!dma_buffer)
-		return -EIO;
-
-	offset = 0;
-	do {
-		addr = get_unaligned_le32(&buffer[offset]);
-		size = get_unaligned_le32(&buffer[offset + 4]);
-		acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
-		offset += 8;
-		while (((int)size) && (offset < buffer_size)) {
-			if (size <= blksz)
-				size2 = size;
-			else
-				size2 = blksz;
-
-			memcpy(dma_buffer, &buffer[offset], size2);
-			ret = wilc->hif_func->hif_block_tx(wilc, addr,
-							   dma_buffer, size2);
-			if (!ret)
-				break;
-
-			addr += size2;
-			offset += size2;
-			size -= size2;
-		}
-		release_bus(wilc, WILC_BUS_RELEASE_ONLY);
-
-		if (!ret) {
-			ret = -EIO;
-			goto fail;
-		}
-	} while (offset < buffer_size);
-
-fail:
-
-	kfree(dma_buffer);
-
-	return (ret < 0) ? ret : 0;
-}
-
-int wilc_wlan_start(struct wilc *wilc)
-{
-	u32 reg = 0;
-	int ret;
-	u32 chipid;
-
-	if (wilc->io_type == WILC_HIF_SDIO) {
-		reg = 0;
-		reg |= BIT(3);
-	} else if (wilc->io_type == WILC_HIF_SPI) {
-		reg = 1;
-	}
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_VMM_CORE_CFG, reg);
-	if (!ret) {
-		release_bus(wilc, WILC_BUS_RELEASE_ONLY);
-		return -EIO;
-	}
-	reg = 0;
-	if (wilc->io_type == WILC_HIF_SDIO && wilc->dev_irq_num)
-		reg |= WILC_HAVE_SDIO_IRQ_GPIO;
-
-#ifdef WILC_DISABLE_PMU
-#else
-	reg |= WILC_HAVE_USE_PMU;
-#endif
-
-#ifdef WILC_SLEEP_CLK_SRC_XO
-	reg |= WILC_HAVE_SLEEP_CLK_SRC_XO;
-#elif defined WILC_SLEEP_CLK_SRC_RTC
-	reg |= WILC_HAVE_SLEEP_CLK_SRC_RTC;
-#endif
-
-#ifdef WILC_EXT_PA_INV_TX_RX
-	reg |= WILC_HAVE_EXT_PA_INV_TX_RX;
-#endif
-	reg |= WILC_HAVE_USE_IRQ_AS_HOST_WAKE;
-	reg |= WILC_HAVE_LEGACY_RF_SETTINGS;
-#ifdef XTAL_24
-	reg |= WILC_HAVE_XTAL_24;
-#endif
-#ifdef DISABLE_WILC_UART
-	reg |= WILC_HAVE_DISABLE_WILC_UART;
-#endif
-
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_1, reg);
-	if (!ret) {
-		release_bus(wilc, WILC_BUS_RELEASE_ONLY);
-		return -EIO;
-	}
-
-	wilc->hif_func->hif_sync_ext(wilc, NUM_INT_EXT);
-
-	ret = wilc->hif_func->hif_read_reg(wilc, 0x1000, &chipid);
-	if (!ret) {
-		release_bus(wilc, WILC_BUS_RELEASE_ONLY);
-		return -EIO;
-	}
-
-	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
-	if ((reg & BIT(10)) == BIT(10)) {
-		reg &= ~BIT(10);
-		wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
-		wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
-	}
-
-	reg |= BIT(10);
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
-	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
-
-	return (ret < 0) ? ret : 0;
-}
-
-int wilc_wlan_stop(struct wilc *wilc, struct wilc_vif *vif)
-{
-	u32 reg = 0;
-	int ret;
-
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
-
-	ret = wilc->hif_func->hif_read_reg(wilc, WILC_GP_REG_0, &reg);
-	if (!ret) {
-		netdev_err(vif->ndev, "Error while reading reg\n");
-		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
-		return -EIO;
-	}
-
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_0,
-					(reg | WILC_ABORT_REQ_BIT));
-	if (!ret) {
-		netdev_err(vif->ndev, "Error while writing reg\n");
-		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
-		return -EIO;
-	}
-
-	ret = wilc->hif_func->hif_read_reg(wilc, WILC_FW_HOST_COMM, &reg);
-	if (!ret) {
-		netdev_err(vif->ndev, "Error while reading reg\n");
-		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
-		return -EIO;
-	}
-	reg = BIT(0);
-
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_FW_HOST_COMM, reg);
-	if (!ret) {
-		netdev_err(vif->ndev, "Error while writing reg\n");
-		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
-		return -EIO;
-	}
-
-	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
-
-	return 0;
-}
-
-void wilc_wlan_cleanup(struct net_device *dev)
-{
-	struct txq_entry_t *tqe;
-	struct rxq_entry_t *rqe;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-
-	wilc->quit = 1;
-	do {
-		tqe = wilc_wlan_txq_remove_from_head(dev);
-		if (!tqe)
-			break;
-		if (tqe->tx_complete_func)
-			tqe->tx_complete_func(tqe->priv, 0);
-		kfree(tqe);
-	} while (1);
-
-	do {
-		rqe = wilc_wlan_rxq_remove(wilc);
-		if (!rqe)
-			break;
-		kfree(rqe);
-	} while (1);
-
-	kfree(wilc->rx_buffer);
-	wilc->rx_buffer = NULL;
-	kfree(wilc->tx_buffer);
-	wilc->tx_buffer = NULL;
-	wilc->hif_func->hif_deinit(NULL);
-}
-
-static int wilc_wlan_cfg_commit(struct wilc_vif *vif, int type,
-				u32 drv_handler)
-{
-	struct wilc *wilc = vif->wilc;
-	struct wilc_cfg_frame *cfg = &wilc->cfg_frame;
-	int t_len = wilc->cfg_frame_offset + sizeof(struct wilc_cfg_cmd_hdr);
-
-	if (type == WILC_CFG_SET)
-		cfg->hdr.cmd_type = 'W';
-	else
-		cfg->hdr.cmd_type = 'Q';
-
-	cfg->hdr.seq_no = wilc->cfg_seq_no % 256;
-	cfg->hdr.total_len = cpu_to_le16(t_len);
-	cfg->hdr.driver_handler = cpu_to_le32(drv_handler);
-	wilc->cfg_seq_no = cfg->hdr.seq_no;
-
-	if (!wilc_wlan_txq_add_cfg_pkt(vif, (u8 *)&cfg->hdr, t_len))
-		return -1;
-
-	return 0;
-}
-
-int wilc_wlan_cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
-		      u32 buffer_size, int commit, u32 drv_handler)
-{
-	u32 offset;
-	int ret_size;
-	struct wilc *wilc = vif->wilc;
-
-	mutex_lock(&wilc->cfg_cmd_lock);
-
-	if (start)
-		wilc->cfg_frame_offset = 0;
-
-	offset = wilc->cfg_frame_offset;
-	ret_size = wilc_wlan_cfg_set_wid(wilc->cfg_frame.frame, offset,
-					 wid, buffer, buffer_size);
-	offset += ret_size;
-	wilc->cfg_frame_offset = offset;
-
-	if (!commit) {
-		mutex_unlock(&wilc->cfg_cmd_lock);
-		return ret_size;
-	}
-
-	netdev_dbg(vif->ndev, "%s: seqno[%d]\n", __func__, wilc->cfg_seq_no);
-
-	if (wilc_wlan_cfg_commit(vif, WILC_CFG_SET, drv_handler))
-		ret_size = 0;
-
-	if (!wait_for_completion_timeout(&wilc->cfg_event,
-					 WILC_CFG_PKTS_TIMEOUT)) {
-		netdev_dbg(vif->ndev, "%s: Timed Out\n", __func__);
-		ret_size = 0;
-	}
-
-	wilc->cfg_frame_offset = 0;
-	wilc->cfg_seq_no += 1;
-	mutex_unlock(&wilc->cfg_cmd_lock);
-
-	return ret_size;
-}
-
-int wilc_wlan_cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
-		      u32 drv_handler)
-{
-	u32 offset;
-	int ret_size;
-	struct wilc *wilc = vif->wilc;
-
-	mutex_lock(&wilc->cfg_cmd_lock);
-
-	if (start)
-		wilc->cfg_frame_offset = 0;
-
-	offset = wilc->cfg_frame_offset;
-	ret_size = wilc_wlan_cfg_get_wid(wilc->cfg_frame.frame, offset, wid);
-	offset += ret_size;
-	wilc->cfg_frame_offset = offset;
-
-	if (!commit) {
-		mutex_unlock(&wilc->cfg_cmd_lock);
-		return ret_size;
-	}
-
-	if (wilc_wlan_cfg_commit(vif, WILC_CFG_QUERY, drv_handler))
-		ret_size = 0;
-
-	if (!wait_for_completion_timeout(&wilc->cfg_event,
-					 WILC_CFG_PKTS_TIMEOUT)) {
-		netdev_dbg(vif->ndev, "%s: Timed Out\n", __func__);
-		ret_size = 0;
-	}
-	wilc->cfg_frame_offset = 0;
-	wilc->cfg_seq_no += 1;
-	mutex_unlock(&wilc->cfg_cmd_lock);
-
-	return ret_size;
-}
-
-int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
-			 u32 count)
-{
-	int i;
-	int ret = 0;
-	u32 drv = wilc_get_vif_idx(vif);
-
-	if (mode == WILC_GET_CFG) {
-		for (i = 0; i < count; i++) {
-			if (!wilc_wlan_cfg_get(vif, !i,
-					       wids[i].id,
-					       (i == count - 1),
-					       drv)) {
-				ret = -ETIMEDOUT;
-				break;
-			}
-		}
-		for (i = 0; i < count; i++) {
-			wids[i].size = wilc_wlan_cfg_get_val(vif->wilc,
-							     wids[i].id,
-							     wids[i].val,
-							     wids[i].size);
-		}
-	} else if (mode == WILC_SET_CFG) {
-		for (i = 0; i < count; i++) {
-			if (!wilc_wlan_cfg_set(vif, !i,
-					       wids[i].id,
-					       wids[i].val,
-					       wids[i].size,
-					       (i == count - 1),
-					       drv)) {
-				ret = -ETIMEDOUT;
-				break;
-			}
-		}
-	}
-
-	return ret;
-}
-
-static u32 init_chip(struct net_device *dev)
-{
-	u32 chipid;
-	u32 reg, ret = 0;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
-
-	chipid = wilc_get_chipid(wilc, true);
-
-	if ((chipid & 0xfff) != 0xa0) {
-		ret = wilc->hif_func->hif_read_reg(wilc, 0x1118, &reg);
-		if (!ret) {
-			netdev_err(dev, "fail read reg 0x1118\n");
-			goto release;
-		}
-		reg |= BIT(0);
-		ret = wilc->hif_func->hif_write_reg(wilc, 0x1118, reg);
-		if (!ret) {
-			netdev_err(dev, "fail write reg 0x1118\n");
-			goto release;
-		}
-		ret = wilc->hif_func->hif_write_reg(wilc, 0xc0000, 0x71);
-		if (!ret) {
-			netdev_err(dev, "fail write reg 0xc0000\n");
-			goto release;
-		}
-	}
-
-release:
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
-
-	return ret;
-}
-
-u32 wilc_get_chipid(struct wilc *wilc, bool update)
-{
-	static u32 chipid;
-	u32 tempchipid = 0;
-	u32 rfrevid = 0;
-
-	if (chipid == 0 || update) {
-		wilc->hif_func->hif_read_reg(wilc, 0x1000, &tempchipid);
-		wilc->hif_func->hif_read_reg(wilc, 0x13f4, &rfrevid);
-		if (!is_wilc1000(tempchipid)) {
-			chipid = 0;
-			return chipid;
-		}
-		if (tempchipid == 0x1002a0) {
-			if (rfrevid != 0x1)
-				tempchipid = 0x1002a1;
-		} else if (tempchipid == 0x1002b0) {
-			if (rfrevid == 0x4)
-				tempchipid = 0x1002b1;
-			else if (rfrevid != 0x3)
-				tempchipid = 0x1002b2;
-		}
-
-		chipid = tempchipid;
-	}
-	return chipid;
-}
-
-int wilc_wlan_init(struct net_device *dev)
-{
-	int ret = 0;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc;
-
-	wilc = vif->wilc;
-
-	wilc->quit = 0;
-
-	if (!wilc->hif_func->hif_init(wilc, false)) {
-		ret = -EIO;
-		goto fail;
-	}
-
-	if (!wilc->tx_buffer)
-		wilc->tx_buffer = kmalloc(WILC_TX_BUFF_SIZE, GFP_KERNEL);
-
-	if (!wilc->tx_buffer) {
-		ret = -ENOBUFS;
-		goto fail;
-	}
-
-	if (!wilc->rx_buffer)
-		wilc->rx_buffer = kmalloc(WILC_RX_BUFF_SIZE, GFP_KERNEL);
-
-	if (!wilc->rx_buffer) {
-		ret = -ENOBUFS;
-		goto fail;
-	}
-
-	if (!init_chip(dev)) {
-		ret = -EIO;
-		goto fail;
-	}
-
-	return 1;
-
-fail:
-
-	kfree(wilc->rx_buffer);
-	wilc->rx_buffer = NULL;
-	kfree(wilc->tx_buffer);
-	wilc->tx_buffer = NULL;
-
-	return ret;
-}
diff --git a/drivers/staging/wilc1000/wlan.c b/drivers/staging/wilc1000/wlan.c
new file mode 100644
index 000000000..d603cd6cb
--- /dev/null
+++ b/drivers/staging/wilc1000/wlan.c
@@ -0,0 +1,1931 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/if_ether.h>
+#include <linux/ip.h>
+
+#include "netdev.h"
+#include "wlan_cfg.h"
+#include "cfg80211.h"
+
+#define WAKUP_TRAILS_TIMEOUT		(10000)
+
+#if KERNEL_VERSION(3, 12, 21) > LINUX_VERSION_CODE
+#define list_next_entry(pos, member) \
+	list_entry((pos)->member.next, typeof(*(pos)), member)
+#endif
+
+void acquire_bus(struct wilc *wilc, enum bus_acquire acquire, int source)
+{
+	mutex_lock(&wilc->hif_cs);
+	if (acquire == WILC_BUS_ACQUIRE_AND_WAKEUP)
+		chip_wakeup(wilc, source);
+}
+
+void release_bus(struct wilc *wilc, enum bus_release release, int source)
+{
+	if (release == WILC_BUS_RELEASE_ALLOW_SLEEP)
+		chip_allow_sleep(wilc, source);
+	mutex_unlock(&wilc->hif_cs);
+}
+
+static u8 reset_bus(struct wilc *wilc)
+{
+	u8 ret = 0;
+
+	if (wilc->io_type == WILC_HIF_SPI)
+		return wilc->hif_func->hif_reset(wilc);
+	return ret;
+}
+
+static void wilc_wlan_txq_remove(struct wilc *wilc, u8 q_num,
+				 struct txq_entry_t *tqe)
+{
+	list_del(&tqe->list);
+	wilc->txq_entries -= 1;
+	wilc->txq[q_num].count--;
+}
+
+static struct txq_entry_t *
+wilc_wlan_txq_remove_from_head(struct wilc *wilc, u8 q_num)
+{
+	struct txq_entry_t *tqe = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+
+	if (!list_empty(&wilc->txq[q_num].txq_head.list)) {
+		tqe = list_first_entry(&wilc->txq[q_num].txq_head.list,
+				       struct txq_entry_t, list);
+		list_del(&tqe->list);
+		wilc->txq_entries -= 1;
+		wilc->txq[q_num].count--;
+	}
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+	return tqe;
+}
+
+static void wilc_wlan_txq_add_to_tail(struct net_device *dev, u8 q_num,
+				      struct txq_entry_t *tqe)
+{
+	unsigned long flags;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+
+	list_add_tail(&tqe->list, &wilc->txq[q_num].txq_head.list);
+	wilc->txq_entries += 1;
+	wilc->txq[q_num].count++;
+	PRINT_INFO(vif->ndev, TX_DBG, "Number of entries in TxQ = %d\n",
+		   wilc->txq_entries);
+
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+
+	PRINT_INFO(vif->ndev, TX_DBG, "Wake the txq_handling\n");
+	complete(&wilc->txq_event);
+}
+
+static void wilc_wlan_txq_add_to_head(struct wilc_vif *vif, u8 q_num,
+				     struct txq_entry_t *tqe)
+{
+	unsigned long flags;
+	struct wilc *wilc = vif->wilc;
+
+	mutex_lock(&wilc->txq_add_to_head_cs);
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+
+	list_add(&tqe->list, &wilc->txq[q_num].txq_head.list);
+	wilc->txq_entries += 1;
+	wilc->txq[q_num].count++;
+	PRINT_INFO(vif->ndev, TX_DBG, "Number of entries in TxQ = %d\n",
+		   wilc->txq_entries);
+
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+	mutex_unlock(&wilc->txq_add_to_head_cs);
+	complete(&wilc->txq_event);
+	PRINT_INFO(vif->ndev, TX_DBG, "Wake up the txq_handler\n");
+}
+
+#define NOT_TCP_ACK			(-1)
+
+static inline void add_tcp_session(struct wilc_vif *vif, u32 src_prt,
+				  u32 dst_prt, u32 seq)
+{
+	struct tcp_ack_filter *f = &vif->ack_filter;
+
+	if (f->tcp_session < 2 * MAX_TCP_SESSION) {
+		f->ack_session_info[f->tcp_session].seq_num = seq;
+		f->ack_session_info[f->tcp_session].bigger_ack_num = 0;
+		f->ack_session_info[f->tcp_session].src_port = src_prt;
+		f->ack_session_info[f->tcp_session].dst_port = dst_prt;
+		f->tcp_session++;
+		PRINT_INFO(vif->ndev, TCP_ENH, "TCP Session %d to Ack %d\n",
+			   f->tcp_session, seq);
+	}
+}
+
+static inline void update_tcp_session(struct wilc_vif *vif, u32 index, u32 ack)
+{
+	struct tcp_ack_filter *f = &vif->ack_filter;
+
+	if (index < 2 * MAX_TCP_SESSION &&
+	    ack > f->ack_session_info[index].bigger_ack_num)
+		f->ack_session_info[index].bigger_ack_num = ack;
+}
+
+static inline void add_tcp_pending_ack(struct wilc_vif *vif, u32 ack,
+				      u32 session_index,
+				      struct txq_entry_t *txqe)
+{
+	struct tcp_ack_filter *f = &vif->ack_filter;
+	u32 i = f->pending_base + f->pending_acks_idx;
+
+	if (i < MAX_PENDING_ACKS) {
+		f->pending_acks[i].ack_num = ack;
+		f->pending_acks[i].txqe = txqe;
+		f->pending_acks[i].session_index = session_index;
+		txqe->ack_idx = i;
+		f->pending_acks_idx++;
+	}
+}
+
+static inline void tcp_process(struct net_device *dev, struct txq_entry_t *tqe)
+{
+	void *buffer = tqe->buffer;
+	const struct ethhdr *eth_hdr_ptr = buffer;
+	int i;
+	unsigned long flags;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+	struct tcp_ack_filter *f = &vif->ack_filter;
+	const struct iphdr *ip_hdr_ptr;
+	const struct tcphdr *tcp_hdr_ptr;
+	u32 ihl, total_length, data_offset;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+
+	if (eth_hdr_ptr->h_proto != htons(ETH_P_IP))
+		goto out;
+
+	ip_hdr_ptr = buffer + ETH_HLEN;
+
+	if (ip_hdr_ptr->protocol != IPPROTO_TCP)
+		goto out;
+
+	ihl = ip_hdr_ptr->ihl << 2;
+	tcp_hdr_ptr = buffer + ETH_HLEN + ihl;
+	total_length = ntohs(ip_hdr_ptr->tot_len);
+
+	data_offset = tcp_hdr_ptr->doff << 2;
+	if (total_length == (ihl + data_offset)) {
+		u32 seq_no, ack_no;
+
+		seq_no = ntohl(tcp_hdr_ptr->seq);
+		ack_no = ntohl(tcp_hdr_ptr->ack_seq);
+		for (i = 0; i < f->tcp_session; i++) {
+			u32 j = f->ack_session_info[i].seq_num;
+
+			if (i < 2 * MAX_TCP_SESSION &&
+			    j == seq_no) {
+				update_tcp_session(vif, i, ack_no);
+				break;
+			}
+		}
+		if (i == f->tcp_session)
+			add_tcp_session(vif, 0, 0, seq_no);
+
+		add_tcp_pending_ack(vif, ack_no, i, tqe);
+	}
+
+out:
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+}
+
+static void wilc_wlan_txq_filter_dup_tcp_ack(struct net_device *dev)
+{
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+	struct tcp_ack_filter *f = &vif->ack_filter;
+	u32 i = 0;
+	u32 dropped = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+	for (i = f->pending_base;
+	     i < (f->pending_base + f->pending_acks_idx); i++) {
+		u32 index;
+		u32 bigger_ack_num;
+
+		if (i >= MAX_PENDING_ACKS)
+			break;
+
+		index = f->pending_acks[i].session_index;
+
+		if (index >= 2 * MAX_TCP_SESSION)
+			break;
+
+		bigger_ack_num = f->ack_session_info[index].bigger_ack_num;
+
+		if (f->pending_acks[i].ack_num < bigger_ack_num) {
+			struct txq_entry_t *tqe;
+
+			PRINT_INFO(vif->ndev, TCP_ENH, "DROP ACK: %u\n",
+				   f->pending_acks[i].ack_num);
+			tqe = f->pending_acks[i].txqe;
+			if (tqe) {
+				wilc_wlan_txq_remove(wilc, tqe->q_num, tqe);
+				tqe->status = 1;
+				if (tqe->tx_complete_func)
+					tqe->tx_complete_func(tqe->priv,
+							      tqe->status);
+				kfree(tqe);
+				dropped++;
+			}
+		}
+	}
+	f->pending_acks_idx = 0;
+	f->tcp_session = 0;
+
+	if (f->pending_base == 0)
+		f->pending_base = MAX_TCP_SESSION;
+	else
+		f->pending_base = 0;
+
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+
+	while (dropped > 0) {
+		if (!wait_for_completion_timeout(&wilc->txq_event,
+						msecs_to_jiffies(1)))
+			PRINT_ER(vif->ndev, "completion timedout\n");
+		dropped--;
+	}
+}
+
+static struct net_device *get_if_handler(struct wilc *wilc, u8 *mac_header)
+{
+	struct net_device *mon_netdev = NULL;
+	struct wilc_vif *vif;
+	struct ieee80211_hdr *h = (struct ieee80211_hdr *)mac_header;
+
+	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
+		if (vif->iftype == WILC_STATION_MODE)
+			if (ether_addr_equal_unaligned(h->addr2, vif->bssid))
+				return vif->ndev;
+		if (vif->iftype == WILC_AP_MODE)
+			if (ether_addr_equal_unaligned(h->addr1, vif->bssid))
+				return vif->ndev;
+		if (vif->iftype == WILC_MONITOR_MODE)
+			mon_netdev = vif->ndev;
+	}
+
+	if (!mon_netdev)
+		pr_warn("%s Invalid handle\n", __func__);
+	return mon_netdev;
+}
+
+void wilc_enable_tcp_ack_filter(struct wilc_vif *vif, bool value)
+{
+	vif->ack_filter.enabled = value;
+}
+
+static int wilc_wlan_txq_add_cfg_pkt(struct wilc_vif *vif, u8 *buffer,
+				     u32 buffer_size)
+{
+	struct txq_entry_t *tqe;
+	struct wilc *wilc = vif->wilc;
+
+	PRINT_INFO(vif->ndev, TX_DBG, "Adding config packet ...\n");
+	if (wilc->quit) {
+		PRINT_INFO(vif->ndev, TX_DBG, "Return due to clear function\n");
+		complete(&wilc->cfg_event);
+		return 0;
+	}
+
+	if (!(wilc->initialized)) {
+		PRINT_INFO(vif->ndev, TX_DBG, "wilc not initialized\n");
+		complete(&wilc->cfg_event);
+		return 0;
+	}
+	tqe = kmalloc(sizeof(*tqe), GFP_KERNEL);
+	if (!tqe) {
+		complete(&wilc->cfg_event);
+		return 0;
+	}
+	tqe->type = WILC_CFG_PKT;
+	tqe->buffer = buffer;
+	tqe->buffer_size = buffer_size;
+	tqe->tx_complete_func = NULL;
+	tqe->priv = NULL;
+	tqe->q_num = AC_VO_Q;
+	tqe->ack_idx = NOT_TCP_ACK;
+	tqe->vif = vif;
+
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "Adding the config packet at the Queue tail\n");
+
+	wilc_wlan_txq_add_to_head(vif, AC_VO_Q, tqe);
+
+	return 1;
+}
+
+static void ac_q_limit(struct wilc *wilc, u8 ac, u16 *q_limit)
+{
+	static u8 buffer[AC_BUFFER_SIZE];
+	static u16 end_index;
+	static bool initialized;
+	static u16 cnt[NQUEUES];
+	u8 factors[NQUEUES] = {1, 1, 1, 1};
+	static u16 sum;
+	u16 i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+	if (!initialized) {
+		for (i = 0; i < AC_BUFFER_SIZE; i++)
+			buffer[i] = i % NQUEUES;
+
+		for (i = 0; i < NQUEUES; i++) {
+			cnt[i] = AC_BUFFER_SIZE * factors[i] / NQUEUES;
+			sum += cnt[i];
+		}
+		end_index = AC_BUFFER_SIZE - 1;
+		initialized = 1;
+	}
+
+	cnt[buffer[end_index]] -= factors[buffer[end_index]];
+	cnt[ac] += factors[ac];
+	sum += (factors[ac] - factors[buffer[end_index]]);
+
+	buffer[end_index] = ac;
+	if (end_index > 0)
+		end_index--;
+	else
+		end_index = AC_BUFFER_SIZE - 1;
+
+	for (i = 0; i < NQUEUES; i++) {
+		if (!sum)
+			q_limit[i] = 1;
+		else
+			q_limit[i] = (cnt[i] * FLOW_CTRL_UP_THRESHLD / sum) + 1;
+	}
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+}
+
+static inline u8 ac_classify(struct wilc *wilc, struct txq_entry_t *tqe)
+{
+	u8 *eth_hdr_ptr;
+	u8 *buffer = tqe->buffer;
+	u8 ac;
+	u16 h_proto;
+	unsigned long flags;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+
+	eth_hdr_ptr = &buffer[0];
+	h_proto = ntohs(*((unsigned short *)&eth_hdr_ptr[12]));
+	if (h_proto == ETH_P_IP) {
+		u8 *ip_hdr_ptr;
+		u32 IHL, DSCP;
+
+		ip_hdr_ptr = &buffer[ETHERNET_HDR_LEN];
+		IHL = (ip_hdr_ptr[0] & 0xf) << 2;
+		DSCP = (ip_hdr_ptr[1] & 0xfc);
+
+		switch (DSCP) {
+		case 0x20:
+		case 0x40:
+		case 0x08:
+			ac = AC_BK_Q;
+			break;
+		case 0x80:
+		case 0xA0:
+		case 0x28:
+			ac = AC_VI_Q;
+			break;
+		case 0xC0:
+		case 0xd0:
+		case 0xE0:
+		case 0x88:
+		case 0xB8:
+			ac = AC_VO_Q;
+			break;
+		default:
+			ac = AC_BE_Q;
+			break;
+		}
+	} else {
+		ac  = AC_BE_Q;
+	}
+
+	tqe->q_num = ac;
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+
+	return ac;
+}
+
+static inline int ac_balance(u8 *count, u8 *ratio)
+{
+	u8 i, max_count = 0;
+
+	if (!count || !ratio)
+		return -1;
+
+	for (i = 0; i < NQUEUES; i++)
+		if (count[i] > max_count)
+			max_count = count[i];
+
+	for (i = 0; i < NQUEUES; i++)
+		ratio[i] = max_count - count[i];
+
+	return 0;
+}
+
+static inline void ac_pkt_count(u32 reg, u8 *pkt_count)
+{
+	pkt_count[AC_BK_Q] = (reg & 0x000000fa) >> BK_AC_COUNT_POS;
+	pkt_count[AC_BE_Q] = (reg & 0x0000fe00) >> BE_AC_COUNT_POS;
+	pkt_count[AC_VI_Q] = (reg & 0x00fe0000) >> VI_AC_COUNT_POS;
+	pkt_count[AC_VO_Q] = (reg & 0xfe000000) >> VO_AC_COUNT_POS;
+}
+
+static inline u8 ac_change(struct wilc *wilc, u8 *ac)
+{
+	do {
+		if (wilc->txq[*ac].acm == 0)
+			return 0;
+		(*ac)++;
+	} while (*ac < NQUEUES);
+	return 1;
+}
+
+static inline void ac_acm_bit(struct wilc *wilc, u32 reg)
+{
+	wilc->txq[AC_BK_Q].acm = (reg & 0x00000002) >> BK_AC_ACM_STAT_POS;
+	wilc->txq[AC_BE_Q].acm = (reg & 0x00000100) >> BE_AC_ACM_STAT_POS;
+	wilc->txq[AC_VI_Q].acm = (reg & 0x00010000) >> VI_AC_ACM_STAT_POS;
+	wilc->txq[AC_VO_Q].acm = (reg & 0x01000000) >> VO_AC_ACM_STAT_POS;
+}
+
+int txq_add_net_pkt(struct net_device *dev, void *priv, u8 *buffer,
+			      u32 buffer_size,
+			      void (*tx_complete_fn)(void *, int))
+{
+	struct txq_entry_t *tqe;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc;
+	u8 q_num;
+	u16 q_limit[NQUEUES] = {0, 0, 0, 0};
+
+	if (!vif) {
+		pr_info("%s vif is NULL\n", __func__);
+		return -1;
+	}
+
+	wilc = vif->wilc;
+
+	if (wilc->quit) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "drv is quitting, return from net_pkt\n");
+		tx_complete_fn(priv, 0);
+		return 0;
+	}
+
+	if (!(wilc->initialized)) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "not_init, return from net_pkt\n");
+		tx_complete_fn(priv, 0);
+		return 0;
+	}
+
+	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
+
+	if (!tqe) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "malloc failed, return from net_pkt\n");
+		tx_complete_fn(priv, 0);
+		return 0;
+	}
+	tqe->type = WILC_NET_PKT;
+	tqe->buffer = buffer;
+	tqe->buffer_size = buffer_size;
+	tqe->tx_complete_func = tx_complete_fn;
+	tqe->priv = priv;
+	tqe->vif = vif;
+
+	q_num = ac_classify(wilc, tqe);
+	if (ac_change(wilc, &q_num)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "No suitable non-ACM queue\n");
+		kfree(tqe);
+		return 0;
+	}
+	ac_q_limit(wilc, q_num, q_limit);
+
+	if ((q_num == AC_VO_Q && wilc->txq[q_num].count <= q_limit[AC_VO_Q]) ||
+	    (q_num == AC_VI_Q && wilc->txq[q_num].count <= q_limit[AC_VI_Q]) ||
+	    (q_num == AC_BE_Q && wilc->txq[q_num].count <= q_limit[AC_BE_Q]) ||
+	    (q_num == AC_BK_Q && wilc->txq[q_num].count <= q_limit[AC_BK_Q])) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "Adding mgmt packet at the Queue tail\n");
+		tqe->ack_idx = NOT_TCP_ACK;
+		if (vif->ack_filter.enabled)
+			tcp_process(dev, tqe);
+		wilc_wlan_txq_add_to_tail(dev, q_num, tqe);
+	} else {
+		tqe->status = 0;
+		if (tqe->tx_complete_func)
+			tqe->tx_complete_func(tqe->priv, tqe->status);
+		kfree(tqe);
+	}
+
+	return wilc->txq_entries;
+}
+
+int txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
+			       u32 buffer_size,
+			       void (*tx_complete_fn)(void *, int))
+{
+	struct txq_entry_t *tqe;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc;
+
+	wilc = vif->wilc;
+
+	if (wilc->quit) {
+		PRINT_INFO(vif->ndev, TX_DBG, "drv is quitting\n");
+		tx_complete_fn(priv, 0);
+		return 0;
+	}
+
+	if (!(wilc->initialized)) {
+		PRINT_INFO(vif->ndev, TX_DBG, "wilc not_init\n");
+		tx_complete_fn(priv, 0);
+		return 0;
+	}
+	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
+
+	if (!tqe) {
+		PRINT_INFO(vif->ndev, TX_DBG, "Queue malloc failed\n");
+		tx_complete_fn(priv, 0);
+		return 0;
+	}
+	tqe->type = WILC_MGMT_PKT;
+	tqe->buffer = buffer;
+	tqe->buffer_size = buffer_size;
+	tqe->tx_complete_func = tx_complete_fn;
+	tqe->priv = priv;
+	tqe->q_num = AC_BE_Q;
+	tqe->ack_idx = NOT_TCP_ACK;
+	tqe->vif = vif;
+
+	PRINT_INFO(vif->ndev, TX_DBG, "Adding Mgmt packet to Queue tail\n");
+	wilc_wlan_txq_add_to_tail(dev, AC_VO_Q, tqe);
+	return 1;
+}
+
+static struct txq_entry_t *txq_get_first(struct wilc *wilc, u8 q_num)
+{
+	struct txq_entry_t *tqe = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+
+	if (!list_empty(&wilc->txq[q_num].txq_head.list))
+		tqe = list_first_entry(&wilc->txq[q_num].txq_head.list,
+				       struct txq_entry_t, list);
+
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+
+	return tqe;
+}
+
+static struct txq_entry_t *txq_get_next(struct wilc *wilc,
+					struct txq_entry_t *tqe, u8 q_num)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+
+	if (!list_is_last(&tqe->list, &wilc->txq[q_num].txq_head.list))
+		tqe = list_next_entry(tqe, list);
+	else
+		tqe = NULL;
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+
+	return tqe;
+}
+
+static void rxq_add(struct wilc *wilc, struct rxq_entry_t *rqe)
+{
+	if (wilc->quit)
+		return;
+
+	mutex_lock(&wilc->rxq_cs);
+	list_add_tail(&rqe->list, &wilc->rxq_head.list);
+	mutex_unlock(&wilc->rxq_cs);
+}
+
+static struct rxq_entry_t *rxq_remove(struct wilc *wilc)
+{
+	struct rxq_entry_t *rqe = NULL;
+
+	mutex_lock(&wilc->rxq_cs);
+	if (!list_empty(&wilc->rxq_head.list)) {
+		rqe = list_first_entry(&wilc->rxq_head.list, struct rxq_entry_t,
+				       list);
+		list_del(&rqe->list);
+	}
+	mutex_unlock(&wilc->rxq_cs);
+	return rqe;
+}
+
+static int chip_allow_sleep_wilc1000(struct wilc *wilc, int source)
+{
+	u32 reg = 0;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+	u32 wakeup_reg, wakeup_bit;
+	u32 to_host_from_fw_reg, to_host_from_fw_bit;
+	u32 from_host_to_fw_reg, from_host_to_fw_bit;
+	u32 trials = 100;
+	int ret;
+
+	if (wilc->io_type == WILC_HIF_SDIO ||
+		wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		wakeup_reg = WILC1000_SDIO_WAKEUP_REG;
+		wakeup_bit = WILC1000_SDIO_WAKEUP_BIT;
+		from_host_to_fw_reg = WILC_SDIO_HOST_TO_FW_REG;
+		from_host_to_fw_bit = WILC_SDIO_HOST_TO_FW_BIT;
+		to_host_from_fw_reg = WILC_SDIO_FW_TO_HOST_REG;
+		to_host_from_fw_bit = WILC_SDIO_FW_TO_HOST_BIT;
+	} else {
+		wakeup_reg = WILC1000_SPI_WAKEUP_REG;
+		wakeup_bit = WILC1000_SPI_WAKEUP_BIT;
+		from_host_to_fw_reg = WILC_SPI_HOST_TO_FW_REG;
+		from_host_to_fw_bit = WILC_SPI_HOST_TO_FW_BIT;
+		to_host_from_fw_reg = WILC_SPI_FW_TO_HOST_REG;
+		to_host_from_fw_bit = WILC_SPI_FW_TO_HOST_BIT;
+	}
+
+	while (trials--) {
+		ret = hif_func->hif_read_reg(wilc, to_host_from_fw_reg, &reg);
+		if (ret)
+			return ret;
+		if ((reg & to_host_from_fw_bit) == 0)
+			break;
+	}
+	if (!trials)
+		pr_warn("FW not responding\n");
+
+	/* Clear bit 1 */
+	ret = hif_func->hif_read_reg(wilc, wakeup_reg, &reg);
+	if (ret)
+		return ret;
+	if (reg & wakeup_bit) {
+		reg &= ~wakeup_bit;
+		ret = hif_func->hif_write_reg(wilc, wakeup_reg, reg);
+		if (ret)
+			return ret;
+	}
+
+	ret = hif_func->hif_read_reg(wilc, from_host_to_fw_reg, &reg);
+	if (ret)
+		return ret;
+	if (reg & from_host_to_fw_bit) {
+		reg &= ~from_host_to_fw_bit;
+		ret = hif_func->hif_write_reg(wilc, from_host_to_fw_reg, reg);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int chip_allow_sleep_wilc3000(struct wilc *wilc, int source)
+{
+	u32 reg = 0;
+	int ret;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	if (wilc->io_type == WILC_HIF_SDIO ||
+		wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		ret = hif_func->hif_read_reg(wilc, WILC3000_SDIO_WAKEUP_REG,
+					     &reg);
+		if (ret)
+			return ret;
+		ret = hif_func->hif_write_reg(wilc, WILC3000_SDIO_WAKEUP_REG,
+					      reg & ~WILC3000_SDIO_WAKEUP_BIT);
+		if (ret)
+			return ret;
+	} else {
+		ret = hif_func->hif_read_reg(wilc, WILC3000_SPI_WAKEUP_REG,
+					     &reg);
+		if (ret)
+			return ret;
+		ret = hif_func->hif_write_reg(wilc, WILC3000_SPI_WAKEUP_REG,
+					      reg & ~WILC3000_SPI_WAKEUP_BIT);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+void chip_allow_sleep(struct wilc *wilc, int source)
+{
+	int ret = 0;
+
+	if (((source == DEV_WIFI) && (wilc->keep_awake[DEV_BT] == true)) ||
+	    ((source == DEV_BT) && (wilc->keep_awake[DEV_WIFI] == true)))
+		pr_warn("Another device is preventing allow sleep operation. request source is %s\n",
+			  (source == DEV_WIFI ? "Wifi" : "BT"));
+	else
+		if (wilc->chip == WILC_1000)
+			ret = chip_allow_sleep_wilc1000(wilc, source);
+		else
+			ret = chip_allow_sleep_wilc3000(wilc, source);
+	if (!ret)
+		wilc->keep_awake[source] = false;
+}
+
+static void chip_wakeup_wilc1000(struct wilc *wilc, int source)
+{
+	u32 ret = 0;
+	u32 clk_status_val = 0, trials = 0;
+	u32 wakeup_reg, wakeup_bit;
+	u32 clk_status_reg, clk_status_bit;
+	u32 to_host_from_fw_reg, to_host_from_fw_bit;
+	u32 from_host_to_fw_reg, from_host_to_fw_bit;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	if (wilc->io_type == WILC_HIF_SDIO ||
+		wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		wakeup_reg = WILC1000_SDIO_WAKEUP_REG;
+		wakeup_bit = WILC1000_SDIO_WAKEUP_BIT;
+		clk_status_reg = WILC1000_SDIO_CLK_STATUS_REG;
+		clk_status_bit = WILC1000_SDIO_CLK_STATUS_BIT;
+		from_host_to_fw_reg = WILC_SDIO_HOST_TO_FW_REG;
+		from_host_to_fw_bit = WILC_SDIO_HOST_TO_FW_BIT;
+		to_host_from_fw_reg = WILC_SDIO_FW_TO_HOST_REG;
+		to_host_from_fw_bit = WILC_SDIO_FW_TO_HOST_BIT;
+	} else {
+		wakeup_reg = WILC1000_SPI_WAKEUP_REG;
+		wakeup_bit = WILC1000_SPI_WAKEUP_BIT;
+		clk_status_reg = WILC1000_SPI_CLK_STATUS_REG;
+		clk_status_bit = WILC1000_SPI_CLK_STATUS_BIT;
+		from_host_to_fw_reg = WILC_SPI_HOST_TO_FW_REG;
+		from_host_to_fw_bit = WILC_SPI_HOST_TO_FW_BIT;
+		to_host_from_fw_reg = WILC_SPI_FW_TO_HOST_REG;
+		to_host_from_fw_bit = WILC_SPI_FW_TO_HOST_BIT;
+	}
+
+
+	/*USE bit 0 to indicate host wakeup*/
+	ret = hif_func->hif_write_reg(wilc, from_host_to_fw_reg,
+				      from_host_to_fw_bit);
+	if (ret)
+		goto _fail_;
+
+	/* Set bit 1 */
+	ret = hif_func->hif_write_reg(wilc, wakeup_reg,
+				      wakeup_bit);
+	if (ret)
+		goto _fail_;
+
+	while (trials < WAKUP_TRAILS_TIMEOUT) {
+		ret = hif_func->hif_read_reg(wilc, clk_status_reg,
+					     &clk_status_val);
+		if (ret) {
+			pr_err("Bus error (5).%d %x\n", ret, clk_status_val);
+			goto _fail_;
+		}
+		if (clk_status_val & clk_status_bit)
+			break;
+
+		//nm_bsp_sleep(2);
+		trials++;
+	}
+	if (trials >= WAKUP_TRAILS_TIMEOUT) {
+		pr_err("Failed to wakup the chip\n");
+		ret = -1;
+		goto _fail_;
+	}
+
+	if (wilc_get_chipid(wilc, false) < 0x1002b0) {
+		uint32_t val32;
+		/* Enable PALDO back right after wakeup */
+		hif_func->hif_read_reg(wilc, WILC_REG_4_TO_1_RX, &val32);
+		val32 |= BIT(6);
+		hif_func->hif_write_reg(wilc, WILC_REG_4_TO_1_RX, val32);
+
+		hif_func->hif_read_reg(wilc, WILC_REG_4_TO_1_TX_BANK0, &val32);
+		val32 |= BIT(6);
+		hif_func->hif_write_reg(wilc, WILC_REG_4_TO_1_TX_BANK0, val32);
+	}
+	/*workaround sometimes spi fail to read clock regs after reading
+	 * writing clockless registers
+	 */
+	reset_bus(wilc);
+
+_fail_:
+	return;
+}
+
+static void chip_wakeup_wilc3000(struct wilc *wilc, int source)
+{
+	u32 wakeup_reg_val, clk_status_reg_val, trials = 0;
+	u32 wakeup_reg, wakeup_bit;
+	u32 clk_status_reg, clk_status_bit;
+	int wake_seq_trials = 5;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	if (wilc->io_type == WILC_HIF_SDIO ||
+		wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		wakeup_reg = WILC3000_SDIO_WAKEUP_REG;
+		wakeup_bit = WILC3000_SDIO_WAKEUP_BIT;
+		clk_status_reg = WILC3000_SDIO_CLK_STATUS_REG;
+		clk_status_bit = WILC3000_SDIO_CLK_STATUS_BIT;
+	} else {
+		wakeup_reg = WILC3000_SPI_WAKEUP_REG;
+		wakeup_bit = WILC3000_SPI_WAKEUP_BIT;
+		clk_status_reg = WILC3000_SPI_CLK_STATUS_REG;
+		clk_status_bit = WILC3000_SPI_CLK_STATUS_BIT;
+	}
+
+	hif_func->hif_read_reg(wilc, wakeup_reg, &wakeup_reg_val);
+	do {
+		hif_func->hif_write_reg(wilc, wakeup_reg, wakeup_reg_val |
+							  wakeup_bit);
+		/* Check the clock status */
+		hif_func->hif_read_reg(wilc, clk_status_reg,
+				       &clk_status_reg_val);
+
+		/*
+		 * in case of clocks off, wait 1ms, and check it again.
+		 * if still off, wait for another 1ms, for a total wait of 3ms.
+		 * If still off, redo the wake up sequence
+		 */
+		while ((clk_status_reg_val & clk_status_bit) == 0 &&
+		       (++trials % 4) != 0) {
+			/* Wait for the chip to stabilize*/
+			usleep_range(1000, 1100);
+
+			/*
+			 * Make sure chip is awake. This is an extra step that
+			 * can be removed later to avoid the bus access
+			 * overhead
+			 */
+			hif_func->hif_read_reg(wilc, clk_status_reg,
+					       &clk_status_reg_val);
+		}
+		/* in case of failure, Reset the wakeup bit to introduce a new
+		 * edge on the next loop
+		 */
+		if ((clk_status_reg_val & clk_status_bit) == 0)
+			hif_func->hif_write_reg(wilc, wakeup_reg,
+						wakeup_reg_val & (~wakeup_bit));
+	} while (((clk_status_reg_val & clk_status_bit) == 0)
+		 && (wake_seq_trials-- > 0));
+	if (!wake_seq_trials)
+		dev_err(wilc->dev, "clocks still OFF. Wake up failed\n");
+	wilc->keep_awake[source] = true;
+}
+
+void chip_wakeup(struct wilc *wilc, int source)
+{
+	if (wilc->chip == WILC_1000)
+		chip_wakeup_wilc1000(wilc, source);
+	else
+		chip_wakeup_wilc3000(wilc, source);
+}
+
+void host_wakeup_notify(struct wilc *wilc, int source)
+{
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY, source);
+	if (wilc->chip == WILC_1000)
+		wilc->hif_func->hif_write_reg(wilc, WILC1000_CORTUS_INTERRUPT_2,
+					      1);
+	else
+		wilc->hif_func->hif_write_reg(wilc, WILC3000_CORTUS_INTERRUPT_2,
+					      1);
+	release_bus(wilc, WILC_BUS_RELEASE_ONLY, source);
+}
+
+void host_sleep_notify(struct wilc *wilc, int source)
+{
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY, source);
+	if (wilc->chip == WILC_1000)
+		wilc->hif_func->hif_write_reg(wilc, WILC1000_CORTUS_INTERRUPT_1,
+					      1);
+	else
+		wilc->hif_func->hif_write_reg(wilc, WILC3000_CORTUS_INTERRUPT_1,
+					      1);
+	release_bus(wilc, WILC_BUS_RELEASE_ONLY, source);
+}
+
+static u8 ac_fw_count[NQUEUES] = {0, 0, 0, 0};
+int wilc_wlan_handle_txq(struct wilc *wilc, u32 *txq_count)
+{
+	int i, entries = 0;
+	u8 k, ac;
+	u32 sum;
+	u32 reg;
+	u8 ac_desired_ratio[NQUEUES] = {0, 0, 0, 0};
+	u8 ac_preserve_ratio[NQUEUES] = {1, 1, 1, 1};
+	u8 *num_pkts_to_add;
+	u8 vmm_entries_ac[WILC_VMM_TBL_SIZE];
+	u8 *txb;
+	u32 offset = 0;
+	bool max_size_over = 0, ac_exist = 0;
+	int vmm_sz = 0;
+	struct txq_entry_t *tqe_q[NQUEUES];
+	int ret = 0;
+	int counter;
+	int timeout;
+	u32 vmm_table[WILC_VMM_TBL_SIZE];
+	u8 ac_pkt_num_to_chip[NQUEUES] = {0, 0, 0, 0};
+	struct wilc_vif *vif;
+	const struct wilc_hif_func *func;
+	int srcu_idx;
+
+	txb = wilc->tx_buffer;
+	if (!wilc->txq_entries) {
+		*txq_count = 0;
+		return 0;
+	}
+
+	if (wilc->quit)
+		goto out_update_cnt;
+	if (ac_balance(ac_fw_count, ac_desired_ratio))
+		return -1;
+
+	mutex_lock(&wilc->txq_add_to_head_cs);
+
+	srcu_idx = srcu_read_lock(&wilc->srcu);
+	list_for_each_entry_rcu(vif, &wilc->vif_list, list)
+		wilc_wlan_txq_filter_dup_tcp_ack(vif->ndev);
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
+
+	for (ac = 0; ac < NQUEUES; ac++)
+		tqe_q[ac] = txq_get_first(wilc, ac);
+
+	i = 0;
+	sum = 0;
+	max_size_over = 0;
+	num_pkts_to_add = ac_desired_ratio;
+	do {
+		ac_exist = 0;
+		for (ac = 0; (ac < NQUEUES) && (!max_size_over); ac++) {
+			if (!tqe_q[ac])
+				continue;
+			vif = tqe_q[ac]->vif;
+			ac_exist = 1;
+			for (k = 0; (k < num_pkts_to_add[ac]) &&
+				    (!max_size_over) && tqe_q[ac]; k++) {
+				if (i >= (WILC_VMM_TBL_SIZE - 1)) {
+					max_size_over = 1;
+					break;
+				}
+
+				if (tqe_q[ac]->type == WILC_CFG_PKT)
+					vmm_sz = ETH_CONFIG_PKT_HDR_OFFSET;
+				else if (tqe_q[ac]->type == WILC_NET_PKT)
+					vmm_sz = ETH_ETHERNET_HDR_OFFSET;
+				else
+					vmm_sz = HOST_HDR_OFFSET;
+
+				vmm_sz += tqe_q[ac]->buffer_size;
+				PRINT_INFO(vif->ndev, TX_DBG,
+					   "VMM Size before alignment = %d\n",
+					   vmm_sz);
+				vmm_sz = ALIGN(vmm_sz, 4);
+
+				if ((sum + vmm_sz) > WILC_TX_BUFF_SIZE) {
+					max_size_over = 1;
+					break;
+				}
+				PRINT_INFO(vif->ndev, TX_DBG,
+					   "VMM Size AFTER alignment = %d\n",
+					   vmm_sz);
+				vmm_table[i] = vmm_sz / 4;
+				PRINT_INFO(vif->ndev, TX_DBG,
+					   "VMMTable entry size = %d\n",
+					   vmm_table[i]);
+				if (tqe_q[ac]->type == WILC_CFG_PKT) {
+					vmm_table[i] |= BIT(10);
+					PRINT_INFO(vif->ndev, TX_DBG,
+						   "VMMTable entry changed for CFG packet = %d\n",
+						   vmm_table[i]);
+				}
+				cpu_to_le32s(&vmm_table[i]);
+				vmm_entries_ac[i] = ac;
+
+				i++;
+				sum += vmm_sz;
+				PRINT_INFO(vif->ndev, TX_DBG, "sum = %d\n",
+					   sum);
+				tqe_q[ac] = txq_get_next(wilc, tqe_q[ac], ac);
+			}
+		}
+		num_pkts_to_add = ac_preserve_ratio;
+	} while (!max_size_over && ac_exist);
+
+	if (i == 0)
+		goto out_unlock;
+	vmm_table[i] = 0x0;
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+	counter = 0;
+	func = wilc->hif_func;
+	do {
+		ret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
+		if (ret) {
+			PRINT_ER(vif->ndev,
+				 "fail read reg vmm_tbl_entry..\n");
+			break;
+		}
+		if ((reg & 0x1) == 0) {
+			ac_pkt_count(reg, ac_fw_count);
+			ac_acm_bit(wilc, reg);
+			break;
+		}
+
+		counter++;
+		if (counter > 200) {
+			counter = 0;
+			PRINT_INFO(vif->ndev, TX_DBG,
+				   "Looping in tx ctrl , force quit\n");
+			ret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, 0);
+			break;
+		}
+	} while (!wilc->quit);
+
+	if (ret)
+		goto out_release_bus;
+
+	timeout = 200;
+	do {
+		ret = func->hif_block_tx(wilc,
+					 VMM_TBL_RX_SHADOW_BASE,
+					 (u8 *)vmm_table,
+					 ((i + 1) * 4));
+		if (ret) {
+			PRINT_ER(vif->ndev,
+				 "ERR block TX of VMM table.\n");
+			break;
+		}
+
+		if (wilc->chip == WILC_1000) {
+			ret = wilc->hif_func->hif_write_reg(wilc,
+							    WILC_HOST_VMM_CTL,
+							    0x2);
+			if (ret) {
+				PRINT_ER(vif->ndev,
+					  "fail write reg host_vmm_ctl..\n");
+				break;
+			}
+
+			do {
+				ret = func->hif_read_reg(wilc,
+						      WILC_HOST_VMM_CTL,
+						      &reg);
+				if (ret)
+					break;
+				if (FIELD_GET(WILC_VMM_ENTRY_AVAILABLE, reg)) {
+					entries = FIELD_GET(WILC_VMM_ENTRY_CNT,
+							    reg);
+					break;
+				}
+			} while (--timeout);
+		} else {
+			ret = func->hif_write_reg(wilc,
+					      WILC_HOST_VMM_CTL,
+					      0);
+			if (ret) {
+				PRINT_ER(vif->ndev,
+					  "fail write reg host_vmm_ctl..\n");
+				break;
+			}
+			/* interrupt firmware */
+			ret = func->hif_write_reg(wilc,
+					      WILC_INTERRUPT_CORTUS_0,
+					      1);
+			if (ret) {
+				PRINT_ER(vif->ndev,
+					  "fail write reg WILC_INTERRUPT_CORTUS_0..\n");
+				break;
+			}
+
+			do {
+				ret = func->hif_read_reg(wilc,
+						      WILC_INTERRUPT_CORTUS_0,
+						      &reg);
+				if (ret) {
+					PRINT_ER(vif->ndev,
+						  "fail read reg WILC_INTERRUPT_CORTUS_0..\n");
+					break;
+				}
+				if (reg == 0) {
+					/* Get the entries */
+
+					ret = func->hif_read_reg(wilc,
+							      WILC_HOST_VMM_CTL,
+							      &reg);
+					if (ret) {
+						PRINT_ER(vif->ndev,
+							  "fail read reg host_vmm_ctl..\n");
+						break;
+					}
+					entries = FIELD_GET(WILC_VMM_ENTRY_CNT,
+							    reg);
+					break;
+				}
+			} while (--timeout);
+		}
+		if (timeout <= 0) {
+			ret = func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x0);
+			break;
+		}
+
+		if (ret)
+			break;
+
+		if (entries == 0) {
+			PRINT_INFO(vif->ndev, TX_DBG,
+				   "no buffer in the chip (reg: %08x), retry later [[ %d, %x ]]\n",
+				   reg, i, vmm_table[i-1]);
+			ret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
+			if (ret) {
+				PRINT_ER(vif->ndev,
+					  "fail read reg WILC_HOST_TX_CTRL..\n");
+				break;
+			}
+			reg &= ~BIT(0);
+			ret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, reg);
+			if (ret) {
+				PRINT_ER(vif->ndev,
+					  "fail write reg WILC_HOST_TX_CTRL..\n");
+			}
+		}
+	} while (0);
+
+	if (ret)
+		goto out_release_bus;
+
+	if (entries == 0) {
+		/* No VMM entry space available in firmware so try again to
+		 * transmit the packet from tx queue
+		 */
+		ret = WILC_VMM_ENTRY_FULL_RETRY;
+		goto out_release_bus;
+	}
+
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+	schedule();
+	offset = 0;
+	i = 0;
+	do {
+		struct txq_entry_t *tqe;
+		u32 header, buffer_offset;
+		u8 mgmt_ptk = 0;
+
+		tqe = wilc_wlan_txq_remove_from_head(wilc, vmm_entries_ac[i]);
+		ac_pkt_num_to_chip[vmm_entries_ac[i]]++;
+		if (!tqe)
+			break;
+
+		if (vmm_table[i] == 0)
+			break;
+
+		vif = tqe->vif;
+		le32_to_cpus(&vmm_table[i]);
+		vmm_sz = FIELD_GET(WILC_VMM_BUFFER_SIZE, vmm_table[i]);
+		vmm_sz *= 4;
+		if (tqe->type == WILC_MGMT_PKT)
+			mgmt_ptk = 1;
+
+		header = (FIELD_PREP(WILC_VMM_HDR_TYPE, tqe->type) |
+			FIELD_PREP(WILC_VMM_HDR_MGMT_FIELD, mgmt_ptk) |
+			FIELD_PREP(WILC_VMM_HDR_PKT_SIZE, tqe->buffer_size) |
+			FIELD_PREP(WILC_VMM_HDR_BUFF_SIZE, vmm_sz));
+
+		cpu_to_le32s(&header);
+		memcpy(&txb[offset], &header, 4);
+		if (tqe->type == WILC_CFG_PKT) {
+			buffer_offset = ETH_CONFIG_PKT_HDR_OFFSET;
+		} else if (tqe->type == WILC_NET_PKT) {
+			char *bssid = tqe->vif->bssid;
+			int prio = tqe->q_num;
+
+			buffer_offset = ETH_ETHERNET_HDR_OFFSET;
+			memcpy(&txb[offset + 4], &prio, sizeof(prio));
+			memcpy(&txb[offset + 8], bssid, 6);
+		} else {
+			buffer_offset = HOST_HDR_OFFSET;
+		}
+
+		memcpy(&txb[offset + buffer_offset],
+		       tqe->buffer, tqe->buffer_size);
+		offset += vmm_sz;
+		i++;
+		tqe->status = 1;
+		if (tqe->tx_complete_func)
+			tqe->tx_complete_func(tqe->priv,
+					      tqe->status);
+		if (tqe->ack_idx != NOT_TCP_ACK &&
+		    tqe->ack_idx < MAX_PENDING_ACKS)
+			vif->ack_filter.pending_acks[tqe->ack_idx].txqe = NULL;
+		kfree(tqe);
+	} while (--entries);
+	for (i = 0; i < NQUEUES; i++)
+		ac_fw_count[i] += ac_pkt_num_to_chip[i];
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+
+	ret = func->hif_clear_int_ext(wilc, ENABLE_TX_VMM);
+	if (ret) {
+		PRINT_ER(vif->ndev, "fail start tx VMM ...\n");
+		goto out_release_bus;
+	}
+
+	ret = func->hif_block_tx_ext(wilc, 0, txb, offset);
+	if (ret)
+		PRINT_ER(vif->ndev, "fail block tx ext...\n");
+
+	if (!ret)
+		cfg_packet_timeout = 0;
+
+out_release_bus:
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+	schedule();
+
+out_unlock:
+	mutex_unlock(&wilc->txq_add_to_head_cs);
+
+out_update_cnt:
+	*txq_count = wilc->txq_entries;
+	return ret;
+}
+
+static void wilc_wlan_handle_rx_buff(struct wilc *wilc, u8 *buffer, int size)
+{
+	int offset = 0;
+	u32 header;
+	u32 pkt_len, pkt_offset, tp_len;
+	int is_cfg_packet;
+	u8 *buff_ptr;
+
+	do {
+		buff_ptr = buffer + offset;
+		header = get_unaligned_le32(buff_ptr);
+
+		is_cfg_packet = FIELD_GET(WILC_PKT_HDR_CONFIG_FIELD, header);
+		pkt_offset = FIELD_GET(WILC_PKT_HDR_OFFSET_FIELD, header);
+		tp_len = FIELD_GET(WILC_PKT_HDR_TOTAL_LEN_FIELD, header);
+		pkt_len = FIELD_GET(WILC_PKT_HDR_LEN_FIELD, header);
+
+		if (pkt_len == 0 || tp_len == 0) {
+			pr_err("%s: Data corrupted %d, %d\n", __func__,
+				   pkt_len, tp_len);
+			break;
+		}
+
+		if (is_cfg_packet) {
+			struct wilc_cfg_rsp rsp;
+
+			buff_ptr += pkt_offset;
+
+			cfg_indicate_rx(wilc, buff_ptr, pkt_len,
+					&rsp);
+			if (rsp.type == WILC_CFG_RSP) {
+				if (wilc->cfg_seq_no == rsp.seq_no)
+					complete(&wilc->cfg_event);
+			} else if (rsp.type == WILC_CFG_RSP_STATUS) {
+				wilc_mac_indicate(wilc);
+			}
+		} else if (pkt_offset & IS_MANAGMEMENT) {
+			buff_ptr += HOST_HDR_OFFSET;
+
+			if (pkt_offset & IS_MON_PKT)
+				wilc_wfi_handle_monitor_rx(wilc, buff_ptr, pkt_len);
+			else
+				wilc_wfi_mgmt_rx(wilc, buff_ptr, pkt_len);
+		} else {
+			struct net_device *wilc_netdev;
+			struct wilc_vif *vif;
+			int srcu_idx;
+
+			srcu_idx = srcu_read_lock(&wilc->srcu);
+			wilc_netdev = get_if_handler(wilc, buff_ptr);
+			if (!wilc_netdev) {
+				pr_err("%s: wilc_netdev in wilc is NULL\n",
+				       __func__);
+				srcu_read_unlock(&wilc->srcu, srcu_idx);
+				return;
+			}
+			vif = netdev_priv(wilc_netdev);
+			wilc_frmw_to_host(vif, buff_ptr, pkt_len,
+					  pkt_offset, PKT_STATUS_NEW);
+			srcu_read_unlock(&wilc->srcu, srcu_idx);
+		}
+
+		offset += tp_len;
+	} while (offset < size);
+}
+
+static void wilc_wlan_handle_rxq(struct wilc *wilc)
+{
+	int size;
+	u8 *buffer;
+	struct rxq_entry_t *rqe;
+
+	while (!wilc->quit) {
+		rqe = rxq_remove(wilc);
+		if (!rqe)
+			break;
+
+		buffer = rqe->buffer;
+		size = rqe->buffer_size;
+
+		wilc_wlan_handle_rx_buff(wilc, buffer, size);
+
+		kfree(rqe);
+	}
+	if (wilc->quit) {
+		pr_info("%s Quitting. Exit handle RX queue\n",
+			__func__);
+		complete(&wilc->cfg_event);
+	}
+}
+
+static void wilc_unknown_isr_ext(struct wilc *wilc)
+{
+	wilc->hif_func->hif_clear_int_ext(wilc, 0);
+}
+
+static void wilc_wlan_handle_isr_ext(struct wilc *wilc, u32 int_status)
+{
+	u32 offset = wilc->rx_buffer_offset;
+	u8 *buffer = NULL;
+	u32 size;
+	u32 retries = 0;
+	int ret = 0;
+	struct rxq_entry_t *rqe;
+
+	size = FIELD_GET(WILC_INTERRUPT_DATA_SIZE, int_status) << 2;
+
+	while (!size && retries < 10) {
+		pr_err("%s: RX Size equal zero Trying to read it again\n",
+		       __func__);
+		wilc->hif_func->hif_read_size(wilc, &size);
+		size = FIELD_GET(WILC_INTERRUPT_DATA_SIZE, size) << 2;
+		retries++;
+	}
+
+	if (size <= 0)
+		return;
+
+	if (WILC_RX_BUFF_SIZE - offset < size)
+		offset = 0;
+
+	buffer = &wilc->rx_buffer[offset];
+
+	wilc->hif_func->hif_clear_int_ext(wilc, DATA_INT_CLR | ENABLE_RX_VMM);
+
+	ret = wilc->hif_func->hif_block_rx_ext(wilc, 0, buffer, size);
+	if (ret) {
+		pr_err("%s: fail block rx\n", __func__);
+		return;
+	}
+
+	offset += size;
+	wilc->rx_buffer_offset = offset;
+	rqe = kmalloc(sizeof(*rqe), GFP_KERNEL);
+	if (!rqe)
+		return;
+
+	rqe->buffer = buffer;
+	rqe->buffer_size = size;
+	rxq_add(wilc, rqe);
+	wilc_wlan_handle_rxq(wilc);
+}
+
+void wilc_handle_isr(struct wilc *wilc)
+{
+	u32 int_status;
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+	wilc->hif_func->hif_read_int(wilc, &int_status);
+
+	if (int_status & DATA_INT_EXT)
+		wilc_wlan_handle_isr_ext(wilc, int_status);
+
+	if (!(int_status & (ALL_INT_EXT))) {
+		pr_warn("%s,>> UNKNOWN_INTERRUPT - 0x%08x\n", __func__,
+			  int_status);
+		wilc_unknown_isr_ext(wilc);
+	}
+
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+}
+
+int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
+				u32 buffer_size)
+{
+	u32 offset;
+	u32 addr, size, size2, blksz;
+	u8 *dma_buffer;
+	int ret = 0;
+	u32 reg = 0;
+
+	blksz = BIT(12);
+
+	dma_buffer = kmalloc(blksz, GFP_KERNEL);
+	if (!dma_buffer)
+		return -EIO;
+
+	offset = 0;
+	pr_info("%sDownloading firmware size = %d\n", __func__, buffer_size);
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+
+	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+	reg &= ~(1ul << 10);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
+	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+	if ((reg & (1ul << 10)) != 0)
+		pr_err("%s: Failed to reset Wifi CPU\n", __func__);
+
+	release_bus(wilc, WILC_BUS_RELEASE_ONLY, DEV_WIFI);
+	do {
+		addr = get_unaligned_le32(&buffer[offset]);
+		size = get_unaligned_le32(&buffer[offset + 4]);
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+		offset += 8;
+		while (((int)size) && (offset < buffer_size)) {
+			if (size <= blksz)
+				size2 = size;
+			else
+				size2 = blksz;
+
+			memcpy(dma_buffer, &buffer[offset], size2);
+			ret = wilc->hif_func->hif_block_tx(wilc, addr,
+							   dma_buffer, size2);
+			if (ret)
+				break;
+
+			addr += size2;
+			offset += size2;
+			size -= size2;
+		}
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+
+		if (ret) {
+			pr_err("%s Bus error\n", __func__);
+			goto fail;
+		}
+		pr_info("%s Offset = %d\n", __func__, offset);
+	} while (offset < buffer_size);
+
+fail:
+
+	kfree(dma_buffer);
+
+	return (ret < 0) ? ret : 0;
+}
+
+int wilc_wlan_start(struct wilc *wilc)
+{
+	u32 reg = 0;
+	int ret;
+
+	if (wilc->io_type == WILC_HIF_SDIO ||
+	    wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ)
+		reg |= BIT(3);
+	else if (wilc->io_type == WILC_HIF_SPI)
+		reg = 1;
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_VMM_CORE_CFG, reg);
+	if (ret) {
+		pr_err("[wilc start]: fail write reg vmm_core_cfg...\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return ret;
+	}
+	reg = 0;
+	if (wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ)
+		reg |= WILC_HAVE_SDIO_IRQ_GPIO;
+
+	if (wilc->chip == WILC_3000)
+		reg |= WILC_HAVE_SLEEP_CLK_SRC_RTC;
+
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_1, reg);
+	if (ret) {
+		pr_err("[wilc start]: fail write WILC_GP_REG_1...\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return ret;
+	}
+
+	wilc->hif_func->hif_sync_ext(wilc, NUM_INT_EXT);
+
+
+	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+	if ((reg & BIT(10)) == BIT(10)) {
+		reg &= ~BIT(10);
+		wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
+		wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+	}
+
+	reg |= BIT(10);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
+	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+
+	if (!ret)
+		wilc->initialized = 1;
+	else
+		wilc->initialized = 0;
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+
+	return (ret < 0) ? ret : 0;
+}
+
+int wilc_wlan_stop(struct wilc *wilc, struct wilc_vif *vif)
+{
+	u32 reg = 0;
+	int ret;
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+
+	/* Clear Wifi mode*/
+	ret = wilc->hif_func->hif_read_reg(wilc, GLOBAL_MODE_CONTROL, &reg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "Error while reading reg\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return -EIO;
+	}
+
+	reg &= ~BIT(0);
+	ret = wilc->hif_func->hif_write_reg(wilc, GLOBAL_MODE_CONTROL, reg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "Error while writing reg\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return -EIO;
+	}
+
+	/* Configure the power sequencer to ignore WIFI sleep signal on making
+	 * chip sleep decision
+	 */
+	ret = wilc->hif_func->hif_read_reg(wilc, PWR_SEQ_MISC_CTRL, &reg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "Error while reading reg\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return ret;
+	}
+
+	reg &= ~BIT(28);
+	ret = wilc->hif_func->hif_write_reg(wilc, PWR_SEQ_MISC_CTRL, reg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "Error while writing reg\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return ret;
+	}
+
+	ret = wilc->hif_func->hif_read_reg(wilc, WILC_GP_REG_0, &reg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "Error while reading reg\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return ret;
+	}
+
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_0,
+					(reg | WILC_ABORT_REQ_BIT));
+	if (ret) {
+		PRINT_ER(vif->ndev, "Error while writing reg\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return ret;
+	}
+
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+
+	return 0;
+}
+
+void wilc_wlan_cleanup(struct net_device *dev)
+{
+	struct txq_entry_t *tqe;
+	struct rxq_entry_t *rqe;
+	u8 ac;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+
+	wilc->quit = 1;
+	for (ac = 0; ac < NQUEUES; ac++) {
+		while ((tqe = wilc_wlan_txq_remove_from_head(wilc, ac))) {
+			if (tqe->tx_complete_func)
+				tqe->tx_complete_func(tqe->priv, 0);
+			kfree(tqe);
+		}
+	}
+
+	while ((rqe = rxq_remove(wilc)))
+		kfree(rqe);
+
+	kfree(wilc->rx_buffer);
+	wilc->rx_buffer = NULL;
+	kfree(wilc->tx_buffer);
+	wilc->tx_buffer = NULL;
+}
+
+static int wilc_wlan_cfg_commit(struct wilc_vif *vif, int type,
+				u32 drv_handler)
+{
+	struct wilc *wilc = vif->wilc;
+	struct wilc_cfg_frame *cfg = &wilc->cfg_frame;
+	int t_len = wilc->cfg_frame_offset + sizeof(struct wilc_cfg_cmd_hdr);
+
+	if (type == WILC_CFG_SET)
+		cfg->hdr.cmd_type = 'W';
+	else
+		cfg->hdr.cmd_type = 'Q';
+
+	cfg->hdr.seq_no = wilc->cfg_seq_no % 256;
+	cfg->hdr.total_len = cpu_to_le16(t_len);
+	cfg->hdr.driver_handler = cpu_to_le32(drv_handler);
+	wilc->cfg_seq_no = cfg->hdr.seq_no;
+
+	if (!wilc_wlan_txq_add_cfg_pkt(vif, (u8 *)&cfg->hdr, t_len))
+		return -1;
+
+	return 0;
+}
+
+int cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
+		      u32 buffer_size, int commit, u32 drv_handler)
+{
+	u32 offset;
+	int ret_size;
+	struct wilc *wilc = vif->wilc;
+
+	mutex_lock(&wilc->cfg_cmd_lock);
+
+	if (start)
+		wilc->cfg_frame_offset = 0;
+
+	offset = wilc->cfg_frame_offset;
+	ret_size = cfg_set_wid(vif, wilc->cfg_frame.frame, offset,
+					 wid, buffer, buffer_size);
+	offset += ret_size;
+	wilc->cfg_frame_offset = offset;
+
+	if (!commit) {
+		mutex_unlock(&wilc->cfg_cmd_lock);
+		return ret_size;
+	}
+
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "[WILC]PACKET Commit with sequence number%d\n",
+		   wilc->cfg_seq_no);
+
+	if (wilc_wlan_cfg_commit(vif, WILC_CFG_SET, drv_handler))
+		ret_size = 0;
+
+	if (!wait_for_completion_timeout(&wilc->cfg_event,
+					 WILC_CFG_PKTS_TIMEOUT)) {
+		pr_err("%s Timed Out\n", __func__);
+		ret_size = 0;
+	}
+
+	wilc->cfg_frame_offset = 0;
+	wilc->cfg_seq_no += 1;
+	mutex_unlock(&wilc->cfg_cmd_lock);
+
+	return ret_size;
+}
+
+int cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
+		      u32 drv_handler)
+{
+	u32 offset;
+	int ret_size;
+	struct wilc *wilc = vif->wilc;
+
+	mutex_lock(&wilc->cfg_cmd_lock);
+
+	if (start)
+		wilc->cfg_frame_offset = 0;
+
+	offset = wilc->cfg_frame_offset;
+	ret_size = cfg_get_wid(wilc->cfg_frame.frame, offset, wid);
+	offset += ret_size;
+	wilc->cfg_frame_offset = offset;
+
+	if (!commit) {
+		mutex_unlock(&wilc->cfg_cmd_lock);
+		return ret_size;
+	}
+
+	if (wilc_wlan_cfg_commit(vif, WILC_CFG_QUERY, drv_handler))
+		ret_size = 0;
+
+	if (!wait_for_completion_timeout(&wilc->cfg_event,
+					 WILC_CFG_PKTS_TIMEOUT)) {
+		pr_err("%s Timed Out\n", __func__);
+		ret_size = 0;
+	}
+
+	wilc->cfg_frame_offset = 0;
+	wilc->cfg_seq_no += 1;
+	mutex_unlock(&wilc->cfg_cmd_lock);
+
+	return ret_size;
+}
+
+unsigned int cfg_packet_timeout;
+int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
+			 u32 count)
+{
+	int i;
+	int ret = 0;
+	u32 drv = wilc_get_vif_idx(vif);
+
+	if (wait_for_recovery) {
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "Host interface is suspended\n");
+		while (wait_for_recovery)
+			msleep(300);
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "Host interface is resumed\n");
+	}
+
+	if (mode == WILC_GET_CFG) {
+		for (i = 0; i < count; i++) {
+			PRINT_D(vif->ndev, CORECONFIG_DBG,
+				"Sending CFG packet [%d][%d]\n", !i,
+				(i == count - 1));
+			if (!cfg_get(vif, !i, wids[i].id, (i == count - 1),
+				     drv)) {
+				ret = -ETIMEDOUT;
+				PRINT_ER(vif->ndev, "Get Timed out\n");
+				break;
+			}
+		}
+		for (i = 0; i < count; i++) {
+			wids[i].size = cfg_get_val(vif->wilc, wids[i].id,
+							     wids[i].val,
+							     wids[i].size);
+		}
+	} else if (mode == WILC_SET_CFG) {
+		for (i = 0; i < count; i++) {
+			PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+				   "Sending config SET PACKET WID:%x\n",
+				   wids[i].id);
+			if (!cfg_set(vif, !i, wids[i].id, wids[i].val,
+				     wids[i].size, (i == count - 1), drv)) {
+				ret = -ETIMEDOUT;
+				PRINT_ER(vif->ndev, "Set Timed out\n");
+				break;
+			}
+		}
+	}
+	cfg_packet_timeout = (ret < 0) ? cfg_packet_timeout + 1 : 0;
+	return ret;
+}
+
+static int init_chip(struct net_device *dev)
+{
+	u32 chipid, reg;
+	int ret = 0;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+
+	chipid = wilc_get_chipid(wilc, true);
+
+	ret = wilc->hif_func->hif_read_reg(wilc, WILC_CORTUS_RESET_MUX_SEL,
+					   &reg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "fail read reg 0x1118\n");
+		goto end;
+	}
+
+	reg |= BIT(0);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_CORTUS_RESET_MUX_SEL,
+					    reg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "fail write reg 0x1118\n");
+		goto end;
+	}
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_CORTUS_BOOT_REGISTER,
+					    WILC_CORTUS_BOOT_FROM_IRAM);
+	if (ret) {
+		PRINT_ER(vif->ndev, "fail write reg 0xc0000 ...\n");
+		goto end;
+	}
+
+	if (wilc->chip == WILC_3000) {
+		ret = wilc->hif_func->hif_read_reg(wilc, 0x207ac, &reg);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Bootrom sts = %x\n", reg);
+		ret = wilc->hif_func->hif_write_reg(wilc, 0x4f0000,
+						    0x71);
+		if (ret) {
+			PRINT_ER(vif->ndev, "fail write reg 0x4f0000 ...\n");
+			goto end;
+		}
+	}
+
+end:
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+
+	return ret;
+}
+
+u32 wilc_get_chipid(struct wilc *wilc, bool update)
+{
+	static u32 chipid;
+	int ret;
+	u32 tempchipid = 0;
+
+	if (chipid == 0 || update) {
+		ret = wilc->hif_func->hif_read_reg(wilc, WILC3000_CHIP_ID,
+						     &tempchipid);
+		if (ret)
+			pr_err("[wilc start]: fail read reg 0x3b0000\n");
+		if (!is_wilc3000(tempchipid)) {
+			wilc->hif_func->hif_read_reg(wilc, WILC_CHIPID,
+						     &tempchipid);
+			if (!is_wilc1000(tempchipid)) {
+				chipid = 0;
+				return chipid;
+			}
+			if (tempchipid < 0x1003a0) {
+				pr_err("WILC1002 isn't suported %x\n", chipid);
+				chipid = 0;
+				return chipid;
+			}
+		}
+		chipid = tempchipid;
+	}
+
+	return chipid;
+}
+
+int wilc_wlan_init(struct net_device *dev)
+{
+	int ret = 0;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc;
+
+	wilc = vif->wilc;
+
+	wilc->quit = 0;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Initializing WILC_Wlan\n");
+
+	if (!wilc->hif_func->hif_is_init(wilc)) {
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY, DEV_WIFI);
+		ret = wilc->hif_func->hif_init(wilc, false);
+		if (ret) {
+			release_bus(wilc, WILC_BUS_RELEASE_ONLY, DEV_WIFI);
+			goto fail;
+		}
+		release_bus(wilc, WILC_BUS_RELEASE_ONLY, DEV_WIFI);
+	}
+
+	if (!wilc->tx_buffer)
+		wilc->tx_buffer = kmalloc(WILC_TX_BUFF_SIZE, GFP_KERNEL);
+
+	if (!wilc->tx_buffer) {
+		ret = -ENOBUFS;
+		PRINT_ER(vif->ndev, "Can't allocate Tx Buffer");
+		goto fail;
+	}
+
+	if (!wilc->rx_buffer)
+		wilc->rx_buffer = kmalloc(WILC_RX_BUFF_SIZE, GFP_KERNEL);
+	PRINT_D(vif->ndev, TX_DBG, "g_wlan.rx_buffer =%p\n", wilc->rx_buffer);
+	if (!wilc->rx_buffer) {
+		ret = -ENOBUFS;
+		PRINT_ER(vif->ndev, "Can't allocate Rx Buffer");
+		goto fail;
+	}
+
+	ret = init_chip(dev);
+	if (ret)
+		goto fail;
+
+	return 0;
+
+fail:
+
+	kfree(wilc->rx_buffer);
+	wilc->rx_buffer = NULL;
+	kfree(wilc->tx_buffer);
+	wilc->tx_buffer = NULL;
+
+	return ret;
+}
diff --git a/drivers/staging/wilc1000/wilc_wlan.h b/drivers/staging/wilc1000/wlan.h
similarity index 58%
rename from drivers/staging/wilc1000/wilc_wlan.h
rename to drivers/staging/wilc1000/wlan.h
index 7469fa47d..b19741774 100644
--- a/drivers/staging/wilc1000/wilc_wlan.h
+++ b/drivers/staging/wilc1000/wlan.h
@@ -8,6 +8,21 @@
 #define WILC_WLAN_H
 
 #include <linux/types.h>
+#include <linux/version.h>
+
+#if KERNEL_VERSION(4, 9, 0) <= LINUX_VERSION_CODE
+#include <linux/bitfield.h>
+#endif
+
+static inline bool is_wilc1000(u32 id)
+{
+	return (id & 0xfffff000) == 0x100000;
+}
+
+static inline bool is_wilc3000(u32 id)
+{
+	return (id & 0xfffff000) == 0x300000;
+}
 
 /********************************************
  *
@@ -37,6 +52,8 @@
 
 #define ETH_CONFIG_PKT_HDR_OFFSET	(ETH_ETHERNET_HDR_OFFSET + \
 					 ETH_CONFIG_PKT_HDR_LEN)
+#define PKT_STATUS_NEW          0
+#define PKT_STATUS_BUFFERED     1
 
 /********************************************
  *
@@ -44,7 +61,6 @@
  *
  ********************************************/
 #define WILC_PERIPH_REG_BASE		0x1000
-#define WILC_CHANGING_VIR_IF		0x108c
 #define WILC_CHIPID			WILC_PERIPH_REG_BASE
 #define WILC_GLB_RESET_0		(WILC_PERIPH_REG_BASE + 0x400)
 #define WILC_PIN_MUX_0			(WILC_PERIPH_REG_BASE + 0x408)
@@ -57,6 +73,14 @@
 #define WILC_HOST_TX_CTRL_1		(WILC_PERIPH_REG_BASE + 0x88)
 #define WILC_MISC			(WILC_PERIPH_REG_BASE + 0x428)
 #define WILC_INTR_REG_BASE		(WILC_PERIPH_REG_BASE + 0xa00)
+
+#define WILC_INTERRUPT_CORTUS_0		(WILC_PERIPH_REG_BASE + 0xa8)
+#define WILC1000_CORTUS_INTERRUPT_1	(WILC_INTERRUPT_CORTUS_0 + 0x4)
+#define WILC3000_CORTUS_INTERRUPT_1	(WILC_INTERRUPT_CORTUS_0 + 0x14)
+
+#define WILC1000_CORTUS_INTERRUPT_2	(WILC_INTERRUPT_CORTUS_0 + 0x8)
+#define WILC3000_CORTUS_INTERRUPT_2	(WILC_INTERRUPT_CORTUS_0 + 0x18)
+
 #define WILC_INTR_ENABLE		WILC_INTR_REG_BASE
 #define WILC_INTR2_ENABLE		(WILC_INTR_REG_BASE + 4)
 
@@ -88,29 +112,112 @@
 #define WILC_SPI_TX_MODE		(WILC_SPI_REG_BASE + 0x20)
 #define WILC_SPI_PROTOCOL_CONFIG	(WILC_SPI_REG_BASE + 0x24)
 #define WILC_SPI_INTR_CTL		(WILC_SPI_REG_BASE + 0x2c)
+#define WILC_SPI_INT_STATUS		(WILC_SPI_REG_BASE + 0x40)
+#define WILC_SPI_INT_CLEAR		(WILC_SPI_REG_BASE + 0x44)
+
+/* WILC1000 specific */
+#define WILC1000_SPI_WAKEUP_REG	0x1
+#define WILC1000_SPI_WAKEUP_BIT	BIT(1)
+
+#define WILC1000_SPI_CLK_STATUS_REG	0x0f
+#define WILC1000_SPI_CLK_STATUS_BIT	BIT(2)
+
+/* WILC3000 specific */
+#define WILC3000_SPI_WAKEUP_REG	0x1
+#define WILC3000_SPI_WAKEUP_BIT	BIT(1)
+
+#define WILC3000_SPI_CLK_STATUS_REG	0x13
+#define WILC3000_SPI_CLK_STATUS_BIT	BIT(2)
 
+#define WILC_SPI_HOST_TO_FW_REG		0x0b
+#define WILC_SPI_HOST_TO_FW_BIT		BIT(0)
+
+#define WILC_SPI_FW_TO_HOST_REG		0x10
+#define WILC_SPI_FW_TO_HOST_BIT		BIT(0)
+
+#define WILC_SPI_CLOCKLESS_ADDR_LIMIT	0x30
 #define WILC_SPI_PROTOCOL_OFFSET	(WILC_SPI_PROTOCOL_CONFIG - \
 					 WILC_SPI_REG_BASE)
 
+/* Function IO enables bits */
+#define WILC_SDIO_CCCR_IO_EN_FUNC1	BIT(1)
+
+/* Function/Interrupt enables bits */
+#define WILC_SDIO_CCCR_IEN_MASTER	BIT(0)
+#define WILC_SDIO_CCCR_IEN_FUNC1	BIT(1)
+
+#define WILC_SDIO_CCCR_ABORT_RESET	BIT(3)
+
+/* Vendor specific CCCR registers */
+/* WILC1000 */
+#define WILC1000_SDIO_WAKEUP_REG	0xf0
+#define WILC1000_SDIO_WAKEUP_BIT	BIT(0)
+
+#define WILC1000_SDIO_CLK_STATUS_REG	0xf1
+#define WILC1000_SDIO_CLK_STATUS_BIT	BIT(0)
+
+#define WILC1000_SDIO_IRQ_FLAG_REG	0xf7
+#define WILC1000_SDIO_IRQ_CLEAR_FLAG_REG	0xf8
+
+/* WILC3000 specific */
+#define WILC3000_SDIO_WAKEUP_REG	0xf0
+#define WILC3000_SDIO_WAKEUP_BIT	BIT(0)
+
+#define WILC3000_SDIO_CLK_STATUS_REG	0xf0 /* clk & wakeup are on same reg*/
+#define WILC3000_SDIO_CLK_STATUS_BIT	BIT(4)
+
+#define WILC3000_SDIO_IRQ_FLAG_REG	0xfe
+#define WILC3000_SDIO_IRQ_CLEAR_FLAG_REG	0xfe
+#define WILC3000_SDIO_VMM_TBL_CTRL_REG	0xf1
+
+
+/* Common vendor specific CCCR register */
+#define WILC_SDIO_INTERRUPT_DATA_SZ_REG	0xf2 /* Read size (2 bytes) */
+
+#define WILC_SDIO_VMM_TBL_CTRL_REG	0xf6
+
+#define WILC_SDIO_HOST_TO_FW_REG	0xfa
+#define WILC_SDIO_HOST_TO_FW_BIT	BIT(0)
+
+#define WILC_SDIO_FW_TO_HOST_REG	0xfc
+#define WILC_SDIO_FW_TO_HOST_BIT	BIT(0)
+
+/* Function 1 specific FBR register */
+#define WILC_SDIO_FBR_CSA_REG		0x10C /* CSA pointer (3 bytes) */
+#define WILC_SDIO_FBR_DATA_REG		0x10F
+
+#define WILC_SDIO_F1_DATA_REG		0x0
+#define WILC_SDIO_EXT_IRQ_FLAG_REG	0x4
+
 #define WILC_AHB_DATA_MEM_BASE		0x30000
 #define WILC_AHB_SHARE_MEM_BASE		0xd0000
 
-#define WILC_VMM_TBL_RX_SHADOW_BASE	WILC_AHB_SHARE_MEM_BASE
-#define WILC_VMM_TBL_RX_SHADOW_SIZE	256
+#define VMM_TBL_RX_SHADOW_BASE		WILC_AHB_SHARE_MEM_BASE
+#define VMM_TBL_RX_SHADOW_SIZE		256
 
-#define WILC_FW_HOST_COMM		0x13c0
 #define WILC_GP_REG_0			0x149c
 #define WILC_GP_REG_1			0x14a0
 
+#define WILC_COEXIST_CTL		0x161E00
+#define GLOBAL_MODE_CONTROL		0x1614
+#define PWR_SEQ_MISC_CTRL		0x3008
+#define COE_AUTO_PS_ON_NULL_PKT		0x160468
+#define COE_AUTO_PS_OFF_NULL_PKT	0x16046C
+#define CCA_CTL_2 (0x160EF4)
+#define CCA_CTL_7 (0x160F08)
+
 #define WILC_HAVE_SDIO_IRQ_GPIO		BIT(0)
-#define WILC_HAVE_USE_PMU		BIT(1)
 #define WILC_HAVE_SLEEP_CLK_SRC_RTC	BIT(2)
 #define WILC_HAVE_SLEEP_CLK_SRC_XO	BIT(3)
-#define WILC_HAVE_EXT_PA_INV_TX_RX	BIT(4)
-#define WILC_HAVE_LEGACY_RF_SETTINGS	BIT(5)
-#define WILC_HAVE_XTAL_24		BIT(6)
-#define WILC_HAVE_DISABLE_WILC_UART	BIT(7)
-#define WILC_HAVE_USE_IRQ_AS_HOST_WAKE	BIT(8)
+
+#define WILC_REG_4_TO_1_RX		0x1e1c
+#define WILC_REG_4_TO_1_TX_BANK0	0x1e9c
+
+#define WILC_CORTUS_RESET_MUX_SEL	0x1118
+#define WILC_CORTUS_BOOT_REGISTER	0xc0000
+#define WILC3000_CHIP_ID		0x3b0000
+
+#define WILC_CORTUS_BOOT_FROM_IRAM	0x71
 
 /********************************************
  *
@@ -127,14 +234,41 @@
 #define WILC_CFG_RSP		1
 #define WILC_CFG_RSP_STATUS	2
 #define WILC_CFG_RSP_SCAN	3
-
 #define WILC_ABORT_REQ_BIT		BIT(31)
 
 #define WILC_RX_BUFF_SIZE	(96 * 1024)
 #define WILC_TX_BUFF_SIZE	(64 * 1024)
 
 #define MODALIAS		"WILC_SPI"
-#define GPIO_NUM		0x44
+#define GPIO_NUM_CHIP_EN	94
+#define GPIO_NUM_RESET		60
+
+#define NQUEUES			4
+#define VO_AC_COUNT_POS		25
+#define VO_AC_ACM_STAT_POS	24
+#define VI_AC_COUNT_POS		17
+#define VI_AC_ACM_STAT_POS	16
+#define BE_AC_COUNT_POS		9
+#define BE_AC_ACM_STAT_POS	8
+#define BK_AC_COUNT_POS		2
+#define BK_AC_ACM_STAT_POS	1
+#define AC_BUFFER_SIZE		1000
+
+#define WILC_PKT_HDR_CONFIG_FIELD	BIT(31)
+#define WILC_PKT_HDR_OFFSET_FIELD	GENMASK(30, 22)
+#define WILC_PKT_HDR_TOTAL_LEN_FIELD	GENMASK(21, 11)
+#define WILC_PKT_HDR_LEN_FIELD		GENMASK(10, 0)
+
+#define WILC_INTERRUPT_DATA_SIZE	GENMASK(14, 0)
+
+#define WILC_VMM_BUFFER_SIZE		GENMASK(9, 0)
+#define WILC_VMM_HDR_TYPE		BIT(31)
+#define WILC_VMM_HDR_MGMT_FIELD		BIT(30)
+#define WILC_VMM_HDR_PKT_SIZE		GENMASK(29, 15)
+#define WILC_VMM_HDR_BUFF_SIZE		GENMASK(14, 0)
+
+#define WILC_VMM_ENTRY_AVAILABLE	BIT(2)
+#define WILC_VMM_ENTRY_CNT		GENMASK(8, 3)
 /*******************************************/
 /*        E0 and later Interrupt flags.    */
 /*******************************************/
@@ -150,14 +284,15 @@
 /* 21: INT5 flag                           */
 /*******************************************/
 #define IRG_FLAGS_OFFSET	16
-#define IRQ_DMA_WD_CNT_MASK	((1ul << IRG_FLAGS_OFFSET) - 1)
+#define IRQ_DMA_WD_CNT_MASK	GENMASK(IRG_FLAGS_OFFSET - 1, 0)
 #define INT_0			BIT(IRG_FLAGS_OFFSET)
 #define INT_1			BIT(IRG_FLAGS_OFFSET + 1)
 #define INT_2			BIT(IRG_FLAGS_OFFSET + 2)
 #define INT_3			BIT(IRG_FLAGS_OFFSET + 3)
 #define INT_4			BIT(IRG_FLAGS_OFFSET + 4)
-#define INT_5			BIT(IRG_FLAGS_OFFSET + 5)
-#define MAX_NUM_INT		6
+#define MAX_NUM_INT		5
+#define IRG_FLAGS_MASK		GENMASK(IRG_FLAGS_OFFSET + MAX_NUM_INT, \
+					IRG_FLAGS_OFFSET)
 
 /*******************************************/
 /*        E0 and later Interrupt flags.    */
@@ -183,29 +318,41 @@
 #define EN_VMM			BIT(8)
 
 #define DATA_INT_EXT		INT_0
-#define ALL_INT_EXT		DATA_INT_EXT
+#define ALL_INT_EXT		(DATA_INT_EXT)
 #define NUM_INT_EXT		1
+#define UNHANDLED_IRQ_MASK	GENMASK(MAX_NUM_INT - 1, NUM_INT_EXT)
 
 #define DATA_INT_CLR		CLR_INT0
 
 #define ENABLE_RX_VMM		(SEL_VMM_TBL1 | EN_VMM)
 #define ENABLE_TX_VMM		(SEL_VMM_TBL0 | EN_VMM)
-/*time for expiring the completion of cfg packets*/
-#define WILC_CFG_PKTS_TIMEOUT	msecs_to_jiffies(2000)
+/* time for expiring the completion of cfg packets */
+#define WILC_CFG_PKTS_TIMEOUT	msecs_to_jiffies(3000)
 
 #define IS_MANAGMEMENT		0x100
 #define IS_MANAGMEMENT_CALLBACK	0x080
 #define IS_MGMT_STATUS_SUCCES	0x040
+#define IS_MON_PKT		0x020
 
+#define WILC_WID_TYPE          GENMASK(15, 12)
+#define WILC_VMM_ENTRY_FULL_RETRY	1
 /********************************************
  *
  *      Tx/Rx Queue Structure
  *
  ********************************************/
 
+enum ip_pkt_priority {
+	AC_VO_Q = 0,
+	AC_VI_Q = 1,
+	AC_BE_Q = 2,
+	AC_BK_Q = 3
+};
+
 struct txq_entry_t {
 	struct list_head list;
 	int type;
+	u8 q_num;
 	int ack_idx;
 	u8 *buffer;
 	int buffer_size;
@@ -215,12 +362,23 @@ struct txq_entry_t {
 	void (*tx_complete_func)(void *priv, int status);
 };
 
+struct txq_handle {
+	struct txq_entry_t txq_head;
+	u16 count;
+	u8 acm;
+};
+
 struct rxq_entry_t {
 	struct list_head list;
 	u8 *buffer;
 	int buffer_size;
 };
 
+enum wilc_chip_type {
+	WILC_1000,
+	WILC_3000,
+};
+
 /********************************************
  *
  *      Host IF Structure
@@ -242,6 +400,8 @@ struct wilc_hif_func {
 	int (*hif_sync_ext)(struct wilc *wilc, int nint);
 	int (*enable_interrupt)(struct wilc *nic);
 	void (*disable_interrupt)(struct wilc *nic);
+	int (*hif_reset)(struct wilc *wilc);
+	bool (*hif_is_init)(struct wilc *wilc);
 };
 
 #define WILC_MAX_CFG_FRAME_SIZE		1468
@@ -250,6 +410,7 @@ struct tx_complete_data {
 	int size;
 	void *buff;
 	struct sk_buff *skb;
+	struct wilc_vif *vif;
 };
 
 struct wilc_cfg_cmd_hdr {
@@ -276,29 +437,40 @@ int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
 				u32 buffer_size);
 int wilc_wlan_start(struct wilc *wilc);
 int wilc_wlan_stop(struct wilc *wilc, struct wilc_vif *vif);
-int wilc_wlan_txq_add_net_pkt(struct net_device *dev, void *priv, u8 *buffer,
+int txq_add_net_pkt(struct net_device *dev, void *priv, u8 *buffer,
 			      u32 buffer_size,
 			      void (*tx_complete_fn)(void *, int));
-int wilc_wlan_handle_txq(struct wilc *wl, u32 *txq_count);
+int wilc_wlan_handle_txq(struct wilc *wilc, u32 *txq_count);
 void wilc_handle_isr(struct wilc *wilc);
 void wilc_wlan_cleanup(struct net_device *dev);
-int wilc_wlan_cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
+int cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
 		      u32 buffer_size, int commit, u32 drv_handler);
-int wilc_wlan_cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
+int cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
 		      u32 drv_handler);
-int wilc_wlan_txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
-			       u32 buffer_size, void (*func)(void *, int));
+int txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
+			       u32 buffer_size,
+			       void (*tx_complete_fn)(void *, int));
+
 void wilc_enable_tcp_ack_filter(struct wilc_vif *vif, bool value);
-int wilc_wlan_get_num_conn_ifcs(struct wilc *wilc);
 netdev_tx_t wilc_mac_xmit(struct sk_buff *skb, struct net_device *dev);
 
-void wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size);
-void host_wakeup_notify(struct wilc *wilc);
-void host_sleep_notify(struct wilc *wilc);
-void chip_allow_sleep(struct wilc *wilc);
-void chip_wakeup(struct wilc *wilc);
+bool wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size);
+void host_wakeup_notify(struct wilc *wilc, int source);
+void host_sleep_notify(struct wilc *wilc, int source);
+void chip_allow_sleep(struct wilc *wilc, int source);
+void chip_wakeup(struct wilc *wilc, int source);
 int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
 			 u32 count);
+void wilc_bt_init(struct wilc *wilc);
+void wilc_bt_deinit(void);
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+void eap_buff_timeout(struct timer_list *t);
+#else
+void eap_buff_timeout(unsigned long user);
+#endif
+void acquire_bus(struct wilc *wilc, enum bus_acquire acquire, int source);
+void release_bus(struct wilc *wilc, enum bus_release release, int source);
 int wilc_wlan_init(struct net_device *dev);
 u32 wilc_get_chipid(struct wilc *wilc, bool update);
+void wilc_wfi_handle_monitor_rx(struct wilc *wilc, u8 *buff, u32 size);
 #endif
diff --git a/drivers/staging/wilc1000/wilc_wlan_cfg.c b/drivers/staging/wilc1000/wlan_cfg.c
similarity index 55%
rename from drivers/staging/wilc1000/wilc_wlan_cfg.c
rename to drivers/staging/wilc1000/wlan_cfg.c
index 3f53807ce..bdda32072 100644
--- a/drivers/staging/wilc1000/wilc_wlan_cfg.c
+++ b/drivers/staging/wilc1000/wlan_cfg.c
@@ -3,11 +3,15 @@
  * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
  * All rights reserved.
  */
+#include "wlan_if.h"
+#include "wlan.h"
+#include "wlan_cfg.h"
+#include "netdev.h"
+#include "cfg80211.h"
 
-#include "wilc_wlan_if.h"
-#include "wilc_wlan.h"
-#include "wilc_wlan_cfg.h"
-#include "wilc_wfi_netdevice.h"
+#if KERNEL_VERSION(4, 9, 0) <= LINUX_VERSION_CODE
+#include <linux/bitfield.h>
+#endif
 
 enum cfg_cmd_type {
 	CFG_BYTE_CMD	= 0,
@@ -17,18 +21,20 @@ enum cfg_cmd_type {
 	CFG_BIN_CMD	= 4
 };
 
-static const struct wilc_cfg_byte g_cfg_byte[] = {
+static struct wilc_cfg_byte g_cfg_byte[] = {
 	{WID_STATUS, 0},
 	{WID_RSSI, 0},
 	{WID_LINKSPEED, 0},
+	{WID_TX_POWER, 0},
+	{WID_WOWLAN_TRIGGER, 0},
 	{WID_NIL, 0}
 };
 
-static const struct wilc_cfg_hword g_cfg_hword[] = {
+static struct wilc_cfg_hword g_cfg_hword[] = {
 	{WID_NIL, 0}
 };
 
-static const struct wilc_cfg_word g_cfg_word[] = {
+static struct wilc_cfg_word g_cfg_word[] = {
 	{WID_FAILED_COUNT, 0},
 	{WID_RECEIVED_FRAGMENT_COUNT, 0},
 	{WID_SUCCESS_FRAME_COUNT, 0},
@@ -37,13 +43,23 @@ static const struct wilc_cfg_word g_cfg_word[] = {
 
 };
 
-static const struct wilc_cfg_str g_cfg_str[] = {
+static struct wilc_cfg_str g_cfg_str[] = {
 	{WID_FIRMWARE_VERSION, NULL},
 	{WID_MAC_ADDR, NULL},
 	{WID_ASSOC_RES_INFO, NULL},
 	{WID_NIL, NULL}
 };
 
+static struct wilc_cfg_bin g_cfg_bin[] = {
+	{WID_ANTENNA_SELECTION, NULL},
+	{WID_NIL, NULL}
+};
+
+#define WILC_RESP_MSG_TYPE_CONFIG_REPLY     'R'
+#define WILC_RESP_MSG_TYPE_STATUS_INFO      'I'
+#define WILC_RESP_MSG_TYPE_NETWORK_INFO     'N'
+#define WILC_RESP_MSG_TYPE_SCAN_COMPLETE    'S'
+
 /********************************************
  *
  *      Configuration Functions
@@ -52,6 +68,7 @@ static const struct wilc_cfg_str g_cfg_str[] = {
 
 static int wilc_wlan_cfg_set_byte(u8 *frame, u32 offset, u16 id, u8 val8)
 {
+
 	if ((offset + 4) >= WILC_MAX_CFG_FRAME_SIZE)
 		return 0;
 
@@ -69,7 +86,6 @@ static int wilc_wlan_cfg_set_hword(u8 *frame, u32 offset, u16 id, u16 val16)
 	put_unaligned_le16(id, &frame[offset]);
 	put_unaligned_le16(2, &frame[offset + 2]);
 	put_unaligned_le16(val16, &frame[offset + 4]);
-
 	return 6;
 }
 
@@ -81,7 +97,6 @@ static int wilc_wlan_cfg_set_word(u8 *frame, u32 offset, u16 id, u32 val32)
 	put_unaligned_le16(id, &frame[offset]);
 	put_unaligned_le16(4, &frame[offset + 2]);
 	put_unaligned_le32(val32, &frame[offset + 4]);
-
 	return 8;
 }
 
@@ -93,6 +108,7 @@ static int wilc_wlan_cfg_set_str(u8 *frame, u32 offset, u16 id, u8 *str,
 
 	put_unaligned_le16(id, &frame[offset]);
 	put_unaligned_le16(size, &frame[offset + 2]);
+
 	if (str && size != 0)
 		memcpy(&frame[offset + 4], str, size);
 
@@ -117,7 +133,6 @@ static int wilc_wlan_cfg_set_bin(u8 *frame, u32 offset, u16 id, u8 *b, u32 size)
 	}
 
 	frame[offset + size + 4] = checksum;
-
 	return (size + 5);
 }
 
@@ -127,78 +142,91 @@ static int wilc_wlan_cfg_set_bin(u8 *frame, u32 offset, u16 id, u8 *b, u32 size)
  *
  ********************************************/
 
-#define GET_WID_TYPE(wid)		(((wid) >> 12) & 0x7)
 static void wilc_wlan_parse_response_frame(struct wilc *wl, u8 *info, int size)
 {
 	u16 wid;
 	u32 len = 0, i = 0;
+	struct wilc_cfg *cfg = &wl->cfg;
 
 	while (size > 0) {
 		i = 0;
 		wid = get_unaligned_le16(info);
 
-		switch (GET_WID_TYPE(wid)) {
+		switch (FIELD_GET(WILC_WID_TYPE, wid)) {
 		case WID_CHAR:
-			do {
-				if (wl->cfg.b[i].id == WID_NIL)
-					break;
-
-				if (wl->cfg.b[i].id == wid) {
-					wl->cfg.b[i].val = info[4];
-					break;
-				}
+			while (cfg->b[i].id != WID_NIL && cfg->b[i].id != wid)
 				i++;
-			} while (1);
+
+			if (cfg->b[i].id == wid)
+				cfg->b[i].val = info[4];
+
 			len = 3;
 			break;
 
 		case WID_SHORT:
-			do {
-				struct wilc_cfg_hword *hw = &wl->cfg.hw[i];
+			while (cfg->hw[i].id != WID_NIL && cfg->hw[i].id != wid)
+				i++;
 
-				if (hw->id == WID_NIL)
-					break;
+			if (cfg->hw[i].id == wid)
+				cfg->hw[i].val = get_unaligned_le16(&info[4]);
 
-				if (hw->id == wid) {
-					hw->val = get_unaligned_le16(&info[4]);
-					break;
-				}
-				i++;
-			} while (1);
 			len = 4;
 			break;
 
 		case WID_INT:
-			do {
-				struct wilc_cfg_word *w = &wl->cfg.w[i];
+			while (cfg->w[i].id != WID_NIL && cfg->w[i].id != wid)
+				i++;
 
-				if (w->id == WID_NIL)
-					break;
+			if (cfg->w[i].id == wid)
+				cfg->w[i].val = get_unaligned_le32(&info[4]);
 
-				if (w->id == wid) {
-					w->val = get_unaligned_le32(&info[4]);
-					break;
-				}
-				i++;
-			} while (1);
 			len = 6;
 			break;
 
 		case WID_STR:
-			do {
-				if (wl->cfg.s[i].id == WID_NIL)
-					break;
-
-				if (wl->cfg.s[i].id == wid) {
-					memcpy(wl->cfg.s[i].str, &info[2],
-					       (info[2] + 2));
-					break;
-				}
+			while (cfg->s[i].id != WID_NIL && cfg->s[i].id != wid)
 				i++;
-			} while (1);
-			len = 2 + info[2];
+
+			if (cfg->s[i].id == wid)
+				memcpy(cfg->s[i].str, &info[2],
+				       (2 + ((info[3] << 8) | info[2])));
+
+			len = 2 + ((info[3] << 8) | info[2]);
 			break;
+		case WID_BIN_DATA:
+			while (cfg->bin[i].id != WID_NIL &&
+			       cfg->bin[i].id != wid)
+				i++;
 
+			if (cfg->bin[i].id == wid) {
+				u16 length = (info[3] << 8) | info[2];
+				u8 checksum = 0;
+				int j = 0;
+
+				/*
+				 * Compute the Checksum of received
+				 * data field
+				 */
+				for (j = 0; j < length; j++)
+					checksum += info[4 + j];
+				/*
+				 * Verify the checksum of recieved BIN
+				 * DATA
+				 */
+				if (checksum != info[4 + length]) {
+					pr_err("%s: Checksum Failed\n",
+					       __func__);
+					return;
+				}
+
+				memcpy(cfg->bin[i].bin, &info[2], length + 2);
+				/*
+				 * value length + data length +
+				 * checksum
+				 */
+				len = 2 + length + 1;
+			}
+			break;
 		default:
 			break;
 		}
@@ -218,16 +246,12 @@ static void wilc_wlan_parse_info_frame(struct wilc *wl, u8 *info)
 	if (len == 1 && wid == WID_STATUS) {
 		int i = 0;
 
-		do {
-			if (wl->cfg.b[i].id == WID_NIL)
-				break;
-
-			if (wl->cfg.b[i].id == wid) {
-				wl->cfg.b[i].val = info[3];
-				break;
-			}
+		while (wl->cfg.b[i].id != WID_NIL &&
+		       wl->cfg.b[i].id != wid)
 			i++;
-		} while (1);
+
+		if (wl->cfg.b[i].id == wid)
+			wl->cfg.b[i].val = info[3];
 	}
 }
 
@@ -237,9 +261,10 @@ static void wilc_wlan_parse_info_frame(struct wilc *wl, u8 *info)
  *
  ********************************************/
 
-int wilc_wlan_cfg_set_wid(u8 *frame, u32 offset, u16 id, u8 *buf, int size)
+int cfg_set_wid(struct wilc_vif *vif, u8 *frame, u32 offset, u16 id, u8 *buf,
+			  int size)
 {
-	u8 type = (id >> 12) & 0xf;
+	u8 type = FIELD_GET(WILC_WID_TYPE, id);
 	int ret = 0;
 
 	switch (type) {
@@ -267,89 +292,87 @@ int wilc_wlan_cfg_set_wid(u8 *frame, u32 offset, u16 id, u8 *buf, int size)
 	case CFG_BIN_CMD:
 		ret = wilc_wlan_cfg_set_bin(frame, offset, id, buf, size);
 		break;
+	default:
+		PRINT_ER(vif->ndev, "illegal id\n");
 	}
 
 	return ret;
 }
 
-int wilc_wlan_cfg_get_wid(u8 *frame, u32 offset, u16 id)
+int cfg_get_wid(u8 *frame, u32 offset, u16 id)
 {
 	if ((offset + 2) >= WILC_MAX_CFG_FRAME_SIZE)
 		return 0;
 
 	put_unaligned_le16(id, &frame[offset]);
-
 	return 2;
 }
 
-int wilc_wlan_cfg_get_val(struct wilc *wl, u16 wid, u8 *buffer,
-			  u32 buffer_size)
+int cfg_get_val(struct wilc *wl, u16 wid, u8 *buffer, u32 buffer_size)
 {
-	u32 type = (wid >> 12) & 0xf;
+	u8 type = FIELD_GET(WILC_WID_TYPE, wid);
 	int i, ret = 0;
+	struct wilc_cfg *cfg = &wl->cfg;
 
 	i = 0;
 	if (type == CFG_BYTE_CMD) {
-		do {
-			if (wl->cfg.b[i].id == WID_NIL)
-				break;
-
-			if (wl->cfg.b[i].id == wid) {
-				memcpy(buffer, &wl->cfg.b[i].val, 1);
-				ret = 1;
-				break;
-			}
+		while (cfg->b[i].id != WID_NIL && cfg->b[i].id != wid)
 			i++;
-		} while (1);
+
+		if (wl->cfg.b[i].id == wid) {
+			memcpy(buffer, &wl->cfg.b[i].val, 1);
+			ret = 1;
+		}
 	} else if (type == CFG_HWORD_CMD) {
-		do {
-			if (wl->cfg.hw[i].id == WID_NIL)
-				break;
-
-			if (wl->cfg.hw[i].id == wid) {
-				memcpy(buffer, &wl->cfg.hw[i].val, 2);
-				ret = 2;
-				break;
-			}
+		while (cfg->hw[i].id != WID_NIL && cfg->hw[i].id != wid)
 			i++;
-		} while (1);
+
+		if (wl->cfg.hw[i].id == wid) {
+			memcpy(buffer,  &wl->cfg.hw[i].val, 2);
+			ret = 2;
+		}
 	} else if (type == CFG_WORD_CMD) {
-		do {
-			if (wl->cfg.w[i].id == WID_NIL)
-				break;
-
-			if (wl->cfg.w[i].id == wid) {
-				memcpy(buffer, &wl->cfg.w[i].val, 4);
-				ret = 4;
-				break;
-			}
+		while (cfg->w[i].id != WID_NIL && cfg->w[i].id != wid)
 			i++;
-		} while (1);
-	} else if (type == CFG_STR_CMD) {
-		do {
-			u32 id = wl->cfg.s[i].id;
 
-			if (id == WID_NIL)
-				break;
+		if (wl->cfg.w[i].id == wid) {
+			memcpy(buffer, &wl->cfg.w[i].val, 4);
+			ret = 4;
+		}
+	} else if (type == CFG_STR_CMD) {
+		while (cfg->s[i].id != WID_NIL && cfg->s[i].id != wid)
+			i++;
 
-			if (id == wid) {
-				u16 size = get_unaligned_le16(wl->cfg.s[i].str);
+		if (cfg->s[i].id == wid) {
+			u16 size = get_unaligned_le16(wl->cfg.s[i].str);
 
-				if (buffer_size >= size) {
-					memcpy(buffer, &wl->cfg.s[i].str[2],
-					       size);
-					ret = size;
-				}
-				break;
+			if (buffer_size >= size) {
+				memcpy(buffer, &wl->cfg.s[i].str[2], size);
+				ret = size;
 			}
+		}
+	} else if (type == CFG_BIN_CMD) { /* binary command */
+		while (cfg->bin[i].id != WID_NIL && cfg->bin[i].id != wid)
 			i++;
-		} while (1);
+
+		if (cfg->bin[i].id == wid) {
+			u32 size = cfg->bin[i].bin[0] |
+				(cfg->bin[i].bin[1] << 8);
+
+			if (buffer_size >= size) {
+				memcpy(buffer, &cfg->bin[i].bin[2], size);
+				ret = size;
+			}
+		}
+	} else {
+		pr_err("[CFG]: illegal type (%08x)\n", wid);
 	}
+
 	return ret;
 }
 
-void wilc_wlan_cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
-			       struct wilc_cfg_rsp *rsp)
+void cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
+		     struct wilc_cfg_rsp *rsp)
 {
 	u8 msg_type;
 	u8 msg_id;
@@ -360,45 +383,44 @@ void wilc_wlan_cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
 	size -= 4;
 	rsp->type = 0;
 
-	/*
-	 * The valid types of response messages are
-	 * 'R' (Response),
-	 * 'I' (Information), and
-	 * 'N' (Network Information)
-	 */
-
 	switch (msg_type) {
-	case 'R':
+	case WILC_RESP_MSG_TYPE_CONFIG_REPLY:
 		wilc_wlan_parse_response_frame(wilc, frame, size);
 		rsp->type = WILC_CFG_RSP;
 		rsp->seq_no = msg_id;
 		break;
 
-	case 'I':
+	case WILC_RESP_MSG_TYPE_STATUS_INFO:
 		wilc_wlan_parse_info_frame(wilc, frame);
 		rsp->type = WILC_CFG_RSP_STATUS;
 		rsp->seq_no = msg_id;
-		/*call host interface info parse as well*/
+		/* call host interface info parse as well */
+		pr_info("%s: Info message received\n", __func__);
 		wilc_gnrl_async_info_received(wilc, frame - 4, size + 4);
 		break;
 
-	case 'N':
+	case WILC_RESP_MSG_TYPE_NETWORK_INFO:
 		wilc_network_info_received(wilc, frame - 4, size + 4);
 		break;
 
-	case 'S':
+	case WILC_RESP_MSG_TYPE_SCAN_COMPLETE:
+		pr_info("%s: Scan Notification Received\n", __func__);
 		wilc_scan_complete_received(wilc, frame - 4, size + 4);
 		break;
 
 	default:
+		pr_err("%s: Receive unknown message %d-%d-%d-%d-%d-%d-%d-%d\n",
+		       __func__, frame[0], frame[1], frame[2], frame[3],
+		       frame[4], frame[5], frame[6], frame[7]);
 		rsp->seq_no = msg_id;
 		break;
 	}
 }
 
-int wilc_wlan_cfg_init(struct wilc *wl)
+int cfg_init(struct wilc *wl)
 {
 	struct wilc_cfg_str_vals *str_vals;
+	struct wilc_bin_vals *bin_vals;
 	int i = 0;
 
 	wl->cfg.b = kmemdup(g_cfg_byte, sizeof(g_cfg_byte), GFP_KERNEL);
@@ -421,8 +443,16 @@ int wilc_wlan_cfg_init(struct wilc *wl)
 	if (!str_vals)
 		goto out_s;
 
-	wl->cfg.str_vals = str_vals;
+	wl->cfg.bin = kmemdup(g_cfg_bin, sizeof(g_cfg_bin), GFP_KERNEL);
+	if (!wl->cfg.bin)
+		goto out_str_val;
+
+	bin_vals = kzalloc(sizeof(*bin_vals), GFP_KERNEL);
+	if (!bin_vals)
+		goto out_bin;
+
 	/* store the string cfg parameters */
+	wl->cfg.str_vals = str_vals;
 	wl->cfg.s[i].id = WID_FIRMWARE_VERSION;
 	wl->cfg.s[i].str = str_vals->firmware_version;
 	i++;
@@ -434,8 +464,22 @@ int wilc_wlan_cfg_init(struct wilc *wl)
 	i++;
 	wl->cfg.s[i].id = WID_NIL;
 	wl->cfg.s[i].str = NULL;
+
+	/* store the bin parameters */
+	i = 0;
+	wl->cfg.bin[i].id = WID_ANTENNA_SELECTION;
+	wl->cfg.bin[i].bin = bin_vals->antenna_param;
+	i++;
+
+	wl->cfg.bin[i].id = WID_NIL;
+	wl->cfg.bin[i].bin = NULL;
+
 	return 0;
 
+out_bin:
+	kfree(wl->cfg.bin);
+out_str_val:
+	kfree(str_vals);
 out_s:
 	kfree(wl->cfg.s);
 out_w:
@@ -447,11 +491,14 @@ int wilc_wlan_cfg_init(struct wilc *wl)
 	return -ENOMEM;
 }
 
-void wilc_wlan_cfg_deinit(struct wilc *wl)
+void cfg_deinit(struct wilc *wl)
 {
 	kfree(wl->cfg.b);
 	kfree(wl->cfg.hw);
 	kfree(wl->cfg.w);
 	kfree(wl->cfg.s);
 	kfree(wl->cfg.str_vals);
+	kfree(wl->cfg.bin);
+	kfree(wl->cfg.bin_vals);
 }
+
diff --git a/drivers/staging/wilc1000/wilc_wlan_cfg.h b/drivers/staging/wilc1000/wlan_cfg.h
similarity index 58%
rename from drivers/staging/wilc1000/wilc_wlan_cfg.h
rename to drivers/staging/wilc1000/wlan_cfg.h
index 614c5673f..d24ab36c1 100644
--- a/drivers/staging/wilc1000/wilc_wlan_cfg.h
+++ b/drivers/staging/wilc1000/wlan_cfg.h
@@ -18,7 +18,7 @@ struct wilc_cfg_hword {
 };
 
 struct wilc_cfg_word {
-	u16 id;
+	u32 id;
 	u32 val;
 };
 
@@ -27,28 +27,39 @@ struct wilc_cfg_str {
 	u8 *str;
 };
 
+struct wilc_cfg_bin {
+	u16 id;
+	u8 *bin;
+};
+
 struct wilc_cfg_str_vals {
 	u8 mac_address[7];
 	u8 firmware_version[129];
 	u8 assoc_rsp[256];
 };
 
+struct wilc_bin_vals {
+	u8 antenna_param[5];
+};
+
 struct wilc_cfg {
 	struct wilc_cfg_byte *b;
 	struct wilc_cfg_hword *hw;
 	struct wilc_cfg_word *w;
 	struct wilc_cfg_str *s;
 	struct wilc_cfg_str_vals *str_vals;
+	struct wilc_cfg_bin *bin;
+	struct wilc_bin_vals *bin_vals;
 };
 
 struct wilc;
-int wilc_wlan_cfg_set_wid(u8 *frame, u32 offset, u16 id, u8 *buf, int size);
-int wilc_wlan_cfg_get_wid(u8 *frame, u32 offset, u16 id);
-int wilc_wlan_cfg_get_val(struct wilc *wl, u16 wid, u8 *buffer,
-			  u32 buffer_size);
-void wilc_wlan_cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
+int cfg_set_wid(struct wilc_vif *vif, u8 *frame, u32 offset, u16 id, u8 *buf,
+		int size);
+int cfg_get_wid(u8 *frame, u32 offset, u16 id);
+int cfg_get_val(struct wilc *wl, u16 wid, u8 *buffer, u32 buffer_size);
+void cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
 			       struct wilc_cfg_rsp *rsp);
-int wilc_wlan_cfg_init(struct wilc *wl);
-void wilc_wlan_cfg_deinit(struct wilc *wl);
+int cfg_init(struct wilc *wl);
+void cfg_deinit(struct wilc *wl);
 
 #endif
diff --git a/drivers/staging/wilc1000/wilc_wlan_if.h b/drivers/staging/wilc1000/wlan_if.h
similarity index 97%
rename from drivers/staging/wilc1000/wilc_wlan_if.h
rename to drivers/staging/wilc1000/wlan_if.h
index 70eac586f..37066ac89 100644
--- a/drivers/staging/wilc1000/wilc_wlan_if.h
+++ b/drivers/staging/wilc1000/wlan_if.h
@@ -8,13 +8,19 @@
 #define WILC_WLAN_IF_H
 
 #include <linux/netdevice.h>
+#include "debugfs.h"
+#include "fw.h"
 
 /********************************************
  *
- *      Wlan Configuration ID
+ *      Host Interface Defines
  *
  ********************************************/
 
+#define	FW_WILC1000_WIFi		"mchp/wilc1000_wifi_firmware.bin"
+#define	FW_WILC3000_WIFI		"mchp/wilc3000_wifi_firmware.bin"
+#define	FW_WILC3000_BLE		"mchp/wilc3000_ble_firmware.bin"
+
 enum bss_types {
 	WILC_FW_BSS_TYPE_INFRA = 0,
 	WILC_FW_BSS_TYPE_INDEPENDENT,
@@ -34,6 +40,10 @@ enum {
 	WILC_FW_PREAMBLE_AUTO = 2,	/* Auto Preamble Selection */
 };
 
+#define DEV_WIFI	0
+#define DEV_BT		1
+#define DEV_MAX		2
+
 enum {
 	WILC_FW_PASSIVE_SCAN = 0,
 	WILC_FW_ACTIVE_SCAN = 1,
@@ -47,12 +57,6 @@ enum {
 	WILC_FW_MAX_PSPOLL_PS = 4
 };
 
-enum chip_ps_states {
-	WILC_CHIP_WAKEDUP = 0,
-	WILC_CHIP_SLEEPING_AUTO = 1,
-	WILC_CHIP_SLEEPING_MANUAL = 2
-};
-
 enum bus_acquire {
 	WILC_BUS_ACQUIRE_ONLY = 0,
 	WILC_BUS_ACQUIRE_AND_WAKEUP = 1,
@@ -193,6 +197,13 @@ enum wid_type {
 	WID_BIN			= 5,
 };
 
+enum {
+	ANTENNA1		= 0,
+	ANTENNA2		= 1,
+	DIVERSITY		= 2,
+	NUM_ANT_MODE
+};
+
 struct wid {
 	u16 id;
 	enum wid_type type;
@@ -661,6 +672,7 @@ enum {
 
 	WID_LOG_TERMINAL_SWITCH		= 0x00CD,
 	WID_TX_POWER			= 0x00CE,
+	WID_WOWLAN_TRIGGER		= 0X00CF,
 	/*  EMAC Short WID list */
 	/*  RTS Threshold */
 	/*
@@ -750,10 +762,10 @@ enum {
 	WID_REMOVE_KEY			= 0x301E,
 	WID_ASSOC_REQ_INFO		= 0x301F,
 	WID_ASSOC_RES_INFO		= 0x3020,
-	WID_MANUFACTURER		= 0x3026, /*Added for CAPI tool */
-	WID_MODEL_NAME			= 0x3027, /*Added for CAPI tool */
-	WID_MODEL_NUM			= 0x3028, /*Added for CAPI tool */
-	WID_DEVICE_NAME			= 0x3029, /*Added for CAPI tool */
+	WID_MANUFACTURER		= 0x3026, /* Added for CAPI tool */
+	WID_MODEL_NAME			= 0x3027, /* Added for CAPI tool */
+	WID_MODEL_NUM			= 0x3028, /* Added for CAPI tool */
+	WID_DEVICE_NAME			= 0x3029, /* Added for CAPI tool */
 
 	/* NMAC String WID list */
 	WID_SET_OPERATION_MODE		= 0x3079,
@@ -794,9 +806,12 @@ enum {
 
 	WID_SETUP_MULTICAST_FILTER	= 0x408b,
 
+	WID_ANTENNA_SELECTION		= 0x408c,
 	/* Miscellaneous WIDs */
 	WID_ALL				= 0x7FFE,
 	WID_MAX				= 0xFFFF
 };
 
+struct wilc;
+
 #endif
-- 
2.25.1

